<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>BeanFactory和FactoryBean和ObjectFactory</title>
    <link href="/2021/01/28/spring/BeanFactory%E5%92%8CFactoryBean%E5%92%8CObjectFactory/"/>
    <url>/2021/01/28/spring/BeanFactory%E5%92%8CFactoryBean%E5%92%8CObjectFactory/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring中的BeanFactory和FactoryBean（以及它和ObjectFactory的区别）的区别"><a href="#Spring中的BeanFactory和FactoryBean（以及它和ObjectFactory的区别）的区别" class="headerlink" title="Spring中的BeanFactory和FactoryBean（以及它和ObjectFactory的区别）的区别"></a>Spring中的BeanFactory和FactoryBean（以及它和ObjectFactory的区别）的区别</h1><h4 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h4><p>开始重视这个问题，源自一次阿里巴巴的二面面试题：说说你对 Spring 中 BeanFactory 的理解，它和 FactoryBean 有什么区别呢？</p><h4 id="直接区别"><a href="#直接区别" class="headerlink" title="直接区别"></a>直接区别</h4><p>直面意思：Bean 工厂、工厂 Bean</p><p><strong>BeanFactory，以 Factory 结尾，表示它是一个工厂类 (接口)，用于管理 Bean 的一个工厂。在 Spring 中，BeanFactory 是 IOC 容器的核心接口，它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。</strong></p><p><strong>FactoryBean 以 Bean 结尾，表示它是一个 Bean，不同于普通 Bean 的是：它是实现了 FactoryBean<T> 接口的 Bean，根据该 Bean 的 ID 从 BeanFactory 中获取的实际上是 FactoryBean 的 getObject() 返回的对象，而不是 FactoryBean 本身，如果要获取 FactoryBean 对象，请在 id 前面加一个 &amp; 符号来获取。</strong></p><span id="more"></span><p>[TOC]</p><h4 id="BeanFacotry"><a href="#BeanFacotry" class="headerlink" title="BeanFacotry"></a>BeanFacotry</h4><p>BeanFactory 定义了 IOC 容器的最基本形式，并提供了 IOC 容器应遵守的的最基本的接口，也就是 Spring IOC 所遵守的最底层和最基本的编程规范。</p><p>Spring 代码中，BeanFactory 只是个接口，并不是 IOC 容器的具体实现，但是 Spring 容器给出了很多种实现，如 <code>DefaultListableBeanFactory</code>、<code>XmlBeanFactory</code>、<code>ApplicationContex</code>t 等，都是附加了某种功能的实现。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public interface BeanFactory &#123;<br><br><br>String FACTORY_BEAN_PREFIX = <span class="hljs-string">&quot;&amp;&quot;</span>;<br><br><br>Object get<span class="hljs-constructor">Bean(String <span class="hljs-params">name</span>)</span> throws BeansException;<br>&lt;T&gt; T get<span class="hljs-constructor">Bean(String <span class="hljs-params">name</span>, Class&lt;T&gt; <span class="hljs-params">requiredType</span>)</span> throws BeansException;<br>Object get<span class="hljs-constructor">Bean(String <span class="hljs-params">name</span>, Object<span class="hljs-operator">...</span> <span class="hljs-params">args</span>)</span> throws BeansException;<br>&lt;T&gt; T get<span class="hljs-constructor">Bean(Class&lt;T&gt; <span class="hljs-params">requiredType</span>)</span> throws BeansException;<br>&lt;T&gt; T get<span class="hljs-constructor">Bean(Class&lt;T&gt; <span class="hljs-params">requiredType</span>, Object<span class="hljs-operator">...</span> <span class="hljs-params">args</span>)</span> throws BeansException;<br><br><br>&lt;T&gt; ObjectProvider&lt;T&gt; get<span class="hljs-constructor">BeanProvider(Class&lt;T&gt; <span class="hljs-params">requiredType</span>)</span>;<br>&lt;T&gt; ObjectProvider&lt;T&gt; get<span class="hljs-constructor">BeanProvider(ResolvableType <span class="hljs-params">requiredType</span>)</span>;<br><br><br>boolean contains<span class="hljs-constructor">Bean(String <span class="hljs-params">name</span>)</span>;<br><br>   <br>boolean is<span class="hljs-constructor">Singleton(String <span class="hljs-params">name</span>)</span> throws NoSuchBeanDefinitionException;<br>boolean is<span class="hljs-constructor">Prototype(String <span class="hljs-params">name</span>)</span> throws NoSuchBeanDefinitionException;<br>boolean is<span class="hljs-constructor">TypeMatch(String <span class="hljs-params">name</span>, ResolvableType <span class="hljs-params">typeToMatch</span>)</span> throws NoSuchBeanDefinitionException;<br>boolean is<span class="hljs-constructor">TypeMatch(String <span class="hljs-params">name</span>, Class&lt;?&gt; <span class="hljs-params">typeToMatch</span>)</span> throws NoSuchBeanDefinitionException;<br><br><br>@Nullable<br>Class&lt;?&gt; get<span class="hljs-constructor">Type(String <span class="hljs-params">name</span>)</span> throws NoSuchBeanDefinitionException;<br>String<span class="hljs-literal">[]</span> get<span class="hljs-constructor">Aliases(String <span class="hljs-params">name</span>)</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在 Spring 中，<strong>所有的 Bean</strong> 都是由 BeanFactory(也就是 IOC 容器) 来进行管理的。但对 FactoryBean 而言，这个 Bean 不是简单的 Bean，而是一个能生产或者修饰对象生成的工厂 Bean, 它的实现与设计模式中的工厂模式和修饰器模式类似</p><p>BeanFacotry 是 spring 中比较原始的 Factory。如 XMLBeanFactory 就是一种典型的 BeanFactory。原始的 BeanFactory 无法支持 spring 的许多插件，如 AOP 功能、Web 应用等。ApplicationContext 接口, 它由 BeanFactory 接口派生而来，</p><blockquote><p>ApplicationContext 包含 BeanFactory 的所有功能，通常建议比 BeanFactory 优先</p></blockquote><p>ApplicationContext 以一种<strong>更向面向框架的方式工作以及对上下文进行分层和实现继承</strong>，ApplicationContext 包还提供了以下的功能：</p><ul><li>MessageSource, 提供国际化的消息访问</li><li>资源访问，如 URL 和文件</li><li>事件传播</li><li>载入多个（有继承关系）上下文 ，使得每一个上下文都专<strong>注于一个特定的层次</strong>，比如应用的 web 层;</li></ul><h6 id="常见的初始化例子"><a href="#常见的初始化例子" class="headerlink" title="常见的初始化例子"></a>常见的初始化例子</h6><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Resource resource = <span class="hljs-keyword">new</span> <span class="hljs-constructor">FileSystemResource(<span class="hljs-string">&quot;beans.xml&quot;</span>)</span>;<br>BeanFactory factory = <span class="hljs-keyword">new</span> <span class="hljs-constructor">XmlBeanFactory(<span class="hljs-params">resource</span>)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ClassPathResource resource = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ClassPathResource(<span class="hljs-string">&quot;beans.xml&quot;</span>)</span>;<br>BeanFactory factory = <span class="hljs-keyword">new</span> <span class="hljs-constructor">XmlBeanFactory(<span class="hljs-params">resource</span>)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart">ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>[] &#123;<span class="hljs-string">&quot;applicationContext.xml&quot;</span>, <span class="hljs-string">&quot;applicationContext-part2.xml&quot;</span>&#125;);<br>BeanFactory <span class="hljs-keyword">factory</span> = (BeanFactory) context;<br></code></pre></td></tr></table></figure><p>分析了从 BeanFactory 到 ConfigurableListableBeanFactory 接口的概要功能：</p><ul><li>BeanFactory–&gt;<code>SpringIoC容器顶级接口,定义了对单个bean的获取,对bean的作用域判断,获取bean类型,获取bean别名的功能</code></li><li>ListableBeanFactory–&gt;<code>扩展了BeanFactory接口,并提供了对bean的枚举能力</code></li><li>HierarchicalBeanFactory–&gt;<code>扩展了BeanFactory接口,并提供了访问父容器的能力</code></li><li>AutowireCapableBeanFactory–&gt;<code>扩展了BeanFactory接口,并提供了自动装配能力</code></li><li>ConfigurableBeanFactory–&gt;<code>扩展了HierarchicalBeanFactory,并提供了对容器的配置能力</code></li><li>ConfigurableListableBeanFactory–&gt;<code>扩展了ListableBeanFactory, AutowireCapableBeanFactory, ConfigurableBeanFactory接口,并提供了忽略依赖,自动装配判断,冻结bean的定义,枚举所有bean名称的功能</code></li></ul><h4 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h4><blockquote><p>这是个特殊的 Bean 他是个工厂 Bean，可以产生 Bean 的 Bean</p></blockquote><p>一般情况下，Spring 通过反射机制利用 <bean> 的 class 属性指定实现类实例化 Bean，<strong>在某些情况下，实例化 Bean 过程比较复杂，如果按照传统的方式，则需要在 <bean> 中提供大量的配置信息。</strong></p><p>配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring 为此提供了一个 org.springframework.bean.factory.FactoryBean 的工厂类接口，用户可以通过实现该接口定制实例化 Bean 的逻辑。</p><p>FactoryBean 接口对于 Spring 框架来说占用重要的地位，Spring 自身就提供了 70 多个 FactoryBean 的实现。</p><blockquote><p>第三方框架要继承进 Spring，往往就是通过实现 FactoryBean 来集成的。比如 MyBatis 的 SqlSessionFactoryBean、RedisRepositoryFactoryBean、EhCacheManagerFactoryBean 等等</p></blockquote><p>当然，我们也可以自己手动来实现一个 FactoryBean，用来代理一个对象。从而可以很方便的在对象前后都做出对应的操作，比如输出一句日志：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFactoryBean</span> <span class="hljs-title">implements</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;<br><br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final Logger logger = LoggerFactory.getLogger(MyFactoryBean.class);<br>    <span class="hljs-keyword">private</span> Class&lt;?&gt; interfaceClazz; <br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Object</span> target; <br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Object</span> proxyObj;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">MyFactoryBean</span>(<span class="hljs-params">Class&lt;?&gt; interfaceClazz, <span class="hljs-built_in">Object</span> target</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.interfaceClazz = interfaceClazz;<br>        <span class="hljs-built_in">this</span>.target = target;<br>        <span class="hljs-built_in">this</span>.proxyObj = <span class="hljs-built_in">Proxy</span>.newProxyInstance(<br>                <span class="hljs-built_in">this</span>.getClass().getClassLoader(),<br>                <span class="hljs-keyword">new</span> Class[]&#123;interfaceClazz&#125;, <br>                (proxy, method, args) -&gt; &#123;<br>                    logger.debug(<span class="hljs-string">&quot;invoke method......&quot;</span> + method.getName());<br>                    logger.debug(<span class="hljs-string">&quot;invoke method before......&quot;</span> + System.currentTimeMillis());<br>                    <span class="hljs-built_in">Object</span> result = method.invoke(target, args);<br>                    logger.debug(<span class="hljs-string">&quot;invoke method after......&quot;</span> + System.currentTimeMillis());<br><br>                    <span class="hljs-keyword">return</span> result;<br>                &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Object</span> <span class="hljs-function"><span class="hljs-title">getObject</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> proxyObj; <br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; <span class="hljs-function"><span class="hljs-title">getObjectType</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> proxyObj == <span class="hljs-literal">null</span> ? <span class="hljs-built_in">Object</span>.class : proxyObj.getClass();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">isSingleton</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有了这个工厂 Bean，我们出去的 Bean 都将是代理 Bean。 main 方法单元测试：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        MyFactoryBean factoryBean = <span class="hljs-keyword">new</span> <span class="hljs-type">MyFactoryBean</span>(UserService.class, <span class="hljs-keyword">new</span> <span class="hljs-type">UserServiceImpl</span>());<br><br>        UserService userService = (UserService) factoryBean.getObject();<br>        System.out.println(userService.sayHello());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;<br>        <span class="hljs-keyword">String</span> sayHello();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">MyFactoryBean</span></span>.<span class="hljs-title">UserService</span> </span>&#123;<br><br>        @Override<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> sayHello() &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">16:17:05.330 [main] DEBUG com.fsx.single.temp.MyFactoryBean -<span class="hljs-built_in"> invoke </span>method......sayHello<br>16:17:05.334 [main] DEBUG com.fsx.single.temp.MyFactoryBean -<span class="hljs-built_in"> invoke </span>method before......1545121025334<br>16:17:05.334 [main] DEBUG com.fsx.single.temp.MyFactoryBean -<span class="hljs-built_in"> invoke </span>method after......1545121025334<br>hello world<br></code></pre></td></tr></table></figure><h4 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h4><p>通过接口内容来看，两者都是属于工厂模式用来创建对象使用的。 啥都不说，先看个例子吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RootConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FactoryBean <span class="hljs-title">myFactoryBean</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyFactoryBean();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ObjectFactory <span class="hljs-title">myObjectFactory</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyObjectFactory();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">Daughter</span>&gt; </span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Daughter <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Daughter();<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;<br>            <span class="hljs-keyword">return</span> Daughter.class;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyObjectFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ObjectFactory</span>&lt;<span class="hljs-title">Son</span>&gt; </span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Son <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Son();<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ApplicationContext applicationContext;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RootConfig.MyFactoryBean myFactoryBean;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RootConfig.MyObjectFactory myObjectFactory;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Daughter daughter;<br>    <br>    <br><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">helloGet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <br>        System.out.println(applicationContext); <br>        System.out.println(applicationContext.getParent()); <br><br>        <br>        System.out.println(myFactoryBean); <br>        <br>        System.out.println(myObjectFactory.getObject()); <br>        System.out.println(daughter); <br><br>        <br>        System.out.println(myFactoryBean.getObject() == myFactoryBean.getObject()); <br>        System.out.println(myObjectFactory.getObject() == myObjectFactory.getObject()); <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello...Get&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>从上面的现象打印值的不同，可以看出<code>FactoryBean和ObjectFactory</code>最直接的区别。上面已经介绍了 FactoryBean，这里简单先介绍下</p><h6 id="ObjectFactory："><a href="#ObjectFactory：" class="headerlink" title="ObjectFactory："></a><code>ObjectFactory</code>：</h6><p>ObjectFactory 则只是一个<strong>普通的</strong>对象工厂接口。在查看 AbstractBeanFacotry 的 doGetBean(…) 部分的源码时，可以看到 spring 对 ObjectFactory 的应用之一就是，将创建对象<strong>的步骤封装到 ObjectFactory 中</strong> 交给自定义的 Scope 来选择是否需要创建对象来灵活的实现 scope</p><p><strong>区别：</strong> <code>FactoryBean</code>的着重于自定义创建对象<strong>过程</strong>，<strong>由 BeanFactory 通过 FactoryBean</strong> 来获取目标对象，而如果是 isSingleton 返回 true 的话，spring 会利用<strong>单例缓存来缓存通过 FactoryBean 创建的对象</strong>。</p><p>而<code>ObjectFactory</code>就是一个<strong>普通的工厂对象接口</strong>，对于 spring 在 doGetBean 处的使用时，在于创建对象的过程由框架通过 ObjectFactory 定义，而创建的时机交给拓展接口 Scope，<strong>除此之外 ObjectFactory 就是一个普通的接口</strong> 此外在将给依赖注入列表注册一个 ObjectFactory 类型的对象，在<strong>注入过程中</strong>会调用<code>objectFactory.getObject()</code>来创建目标对象注入进去。<code>（如beanFactory.registerResolvableDependency(HttpSession.class, new SessionObjectFactory());）</code></p><blockquote><p>简单来说就是通过 FactoryBean 你可以控制对象如何创建，而 ObjectFactory 借助 Scope 接口自定义 scope 你可以控制对象的创建时机</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>thinking-in-spirng</title>
    <link href="/2021/01/27/spring/thinking-in-spirng/"/>
    <url>/2021/01/27/spring/thinking-in-spirng/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章：Spring-Framework-总览（Overview）"><a href="#第一章：Spring-Framework-总览（Overview）" class="headerlink" title="第一章：Spring Framework 总览（Overview）"></a>第一章：Spring Framework 总览（Overview）</h2><table><thead><tr><th>Spring Framework 版本</th><th>Java 标准版</th><th>Java 企业版</th></tr></thead><tbody><tr><td>1.x</td><td>1.3+</td><td>J2EE 1.3 +</td></tr><tr><td>2.x</td><td>1.4.2+</td><td>J2EE 1.3 +</td></tr><tr><td>3.x</td><td>5+</td><td>J2EE 1.4 和 Java EE 5</td></tr><tr><td>4.x</td><td>6+</td><td>Java EE 6 和 7</td></tr><tr><td>5.x</td><td>8+</td><td>Java EE 7</td></tr></tbody></table><h3 id="Spring-编程模型："><a href="#Spring-编程模型：" class="headerlink" title="Spring 编程模型："></a>Spring 编程模型：</h3><ul><li><p>面向对象编程</p><ul><li><p>契约接口：Aware、BeanPostProcessor …</p></li><li><p>设计模式：观察者模式、组合模式、模板模式 …</p></li><li><p>对象继承：Abstract* 类</p></li></ul></li><li><p>面向切面编程</p><ul><li>动态代理：JdkDynamicAopProxy</li><li>字节码提升：ASM、CGLib、AspectJ…</li></ul></li><li><p>面向元编程</p><ul><li>注解：模式注解（@Component、@Service、@Respository …）</li><li>配置：Environment 抽象、PropertySources、BeanDefinition …</li><li>泛型：GenericTypeResolver、ResolvableType …</li></ul></li><li><p>函数驱动</p><ul><li>函数接口：ApplicationEventPublisher</li><li>Reactive：Spring WebFlux</li></ul></li><li><p>模块驱动</p><ul><li>Maven Artifacts</li><li><del>OSGI Bundles</del></li><li>Java 9 Automatic Modules</li><li>Spring @Enable*</li></ul></li></ul><h2 id="第二章：重新认识-IoC"><a href="#第二章：重新认识-IoC" class="headerlink" title="第二章：重新认识 IoC"></a>第二章：重新认识 IoC</h2><h3 id="2-1-IoC-容器的职责："><a href="#2-1-IoC-容器的职责：" class="headerlink" title="2.1 IoC 容器的职责："></a>2.1 IoC 容器的职责：</h3><ul><li>通用职责<ul><li>依赖处理<ul><li>依赖查找</li><li>依赖注入</li></ul></li><li>生命周期管理<ul><li>容器    </li><li>托管的资源（Java Beans 或其他资源）</li></ul></li><li>配置<ul><li>容器</li><li>外部化配置</li><li>托管的资源（Java Beans 或其他资源）</li></ul></li></ul></li></ul><h3 id="2-2-Spring-作为-IoC-容器的优势："><a href="#2-2-Spring-作为-IoC-容器的优势：" class="headerlink" title="2.2 Spring 作为 IoC 容器的优势："></a>2.2 Spring 作为 IoC 容器的优势：</h3><ul><li>典型的 IoC 管理，依赖查找和依赖注入</li><li>AOP 抽象</li><li>事务抽象</li><li>事件机制</li><li>SPI 扩展</li><li>强大的第三方整合</li><li>易测试性</li><li>更好的面向对象</li></ul><h2 id="第三章：Spring-IoC-容器概述"><a href="#第三章：Spring-IoC-容器概述" class="headerlink" title="第三章：Spring IoC 容器概述"></a>第三章：Spring IoC 容器概述</h2><h3 id="3-1-Spring-IoC-依赖查找："><a href="#3-1-Spring-IoC-依赖查找：" class="headerlink" title="3.1 Spring IoC 依赖查找："></a>3.1 Spring IoC 依赖查找：</h3><p><code>BeanFactory beanFactory = new ClassPathXmlApplicationContext(&quot;...&quot;)</code></p><ul><li>根据 Bean 名称查找<ul><li>实时查找 <code>(User) beanFactory.getBean(&quot;user&quot;)</code></li><li>延迟查找 <code>org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean</code></li></ul></li><li>根据 Bean 类型查找<ul><li>单个 Bean 对象 <code>beanFactory.getBean(User.class);</code></li><li>集合 Bean 对象 </li></ul></li><li>根据 Bean 名称 + 类型查找 <code>beanFactory.getBean(&quot;user&quot;, User.class);</code></li><li>根据 Java 注解查找</li><li>单个 Bean 对象<ul><li>集合 Bean 对象</li></ul></li></ul><h3 id="3-2-Spring-IoC-依赖注入："><a href="#3-2-Spring-IoC-依赖注入：" class="headerlink" title="3.2 Spring IoC 依赖注入："></a>3.2 Spring IoC 依赖注入：</h3><ul><li>根据 Bean 名称注入</li><li>根据 Bean 类型注入<ul><li>单个 Bean 对象</li><li>集合 Bean 对象</li></ul></li><li>注入容器內建 Bean 对象</li><li>注入非 Bean 对象</li><li>注入类型<ul><li>实时注入</li><li>延迟注入</li></ul></li></ul><p>延迟查找和延迟注入，使用到接口 <code>org.springframework.beans.factory.ObjectProvider</code> 和 <code>org.springframework.beans.factory.ObjectFactory</code> ，<code>ObjectProvider</code> 继承 <code>ObjectFactory</code></p><p><code>BeanFactory</code> 和 <code>ApplicationContext</code> 谁才是 Spring IoC 容器？</p><ul><li><code>BeanFactory</code> 是 Spring 底层 IoC 容器</li><li><code>ApplicationContext</code> 是具备应用特性的 <code>BeanFactory</code> 超集</li><li><code>BeanFactory</code> 是基本的 IoC 容器，<code>ApplicationContext</code> 实现 <code>BeanFactory</code> 接口，并在内部使用 <code>ConfigurableListableBeanFactory</code> 实现接口方法。</li></ul><h3 id="3-3-ApplicationContext-除了-IoC-容器角色，还有提供："><a href="#3-3-ApplicationContext-除了-IoC-容器角色，还有提供：" class="headerlink" title="3.3 ApplicationContext 除了 IoC 容器角色，还有提供："></a>3.3 ApplicationContext 除了 IoC 容器角色，还有提供：</h3><ul><li>面向切面（AOP）</li><li>配置元信息（Configuration Metadata）</li><li>资源管理（Resources）</li><li>事件（Events）</li><li>国际化（i18n）</li><li>注解（Annotations）</li><li>Environment 抽象（Environment Abstraction）</li></ul><h2 id="第四章：Spring-Bean-基础"><a href="#第四章：Spring-Bean-基础" class="headerlink" title="第四章：Spring Bean 基础"></a>第四章：Spring Bean 基础</h2><p>什么是 <code>BeanDefinition</code>？</p><ul><li><code>org.springframework.beans.factory.config.BeanDefinition</code></li><li><code>BeanDefinition</code> 是 Spring Framework 中定义 Bean 的配置元信息接口，包含：<ul><li>Bean 的类名</li><li>Bean 行为配置元素，如作用域、自动绑定的模式，生命周期回调等</li><li>其他 Bean 引用，又可称作合作者（collaborators）或者依赖（dependencies）</li><li>配置设置，比如 Bean 属性（Properties）</li></ul></li><li>BeanDefinition 构建<ul><li>通过 <code>BeanDefinitionBuilder</code></li><li>通过 <code>AbstractBeanDefinition</code> 以及派生类</li></ul></li></ul><p>Bean 名称生成器：<code>org.springframework.beans.factory.support.BeanNameGenerator</code></p><p>注册 Spring Bean：</p><ul><li>BeanDefinition 注册<ul><li>XML 配置元信息<ul><li><code>&lt;bean ... /&gt;</code></li></ul></li><li>Java 注解配置元信息<ul><li><code>@Bean</code></li><li><code>@Component</code></li><li><code>@Import</code></li></ul></li><li>Java API 配置元信息<ul><li>命名方式：<code>BeanDefinitionRegistry#registerBeanDefinition(String,BeanDefinition)</code></li><li>非命名方式：<code>BeanDefinitionReaderUtils#registerWithGeneratedName(AbstractBeanDefinition,Be</code><br><code>anDefinitionRegistry)</code></li><li>配置类方式：<code>AnnotatedBeanDefinitionReader#register(Class...)</code></li></ul></li></ul></li><li>外部单例对象注册<ul><li>Java API 配置元信息<ul><li><code>SingletonBeanRegistry#registerSingleton</code></li></ul></li></ul></li></ul><p>Bean 实例化（Instantiation）</p><ul><li>常规方式<ul><li>通过构造器（配置元信息：XML、Java 注解和 Java API ）</li><li>通过静态工厂方法（配置元信息：XML 和 Java API ）</li><li>通过 Bean 工厂方法（配置元信息：XML 和 Java API ）</li><li>通过 <code>FactoryBean</code>（配置元信息：XML、Java 注解和 Java API ）</li></ul></li><li>特殊方式<ul><li>通过 <code>ServiceLoaderFactoryBean</code>（配置元信息：XML、Java 注解和 Java API ）</li><li>通过 <code>AutowireCapableBeanFactory#createBean(java.lang.Class, int, boolean)</code></li><li>通过 <code>BeanDefinitionRegistry#registerBeanDefinition(String,BeanDefinition)</code></li></ul></li></ul><p>Bean 初始化（Initialization），同时存在时，顺序从上到下：</p><ul><li><code>@PostConstruct</code> 标注方法</li><li>实现 <code>InitializingBean</code> 接口的 <code>afterPropertiesSet()</code> 方法</li><li>自定义初始化方法（<code>BeanDefinition</code>）<ul><li>XML 配置：<code>&lt;bean init-method=”init” ... /&gt;</code></li><li>Java 注解：<code>@Bean(initMethod=”init”)</code></li><li>Java API：<code>AbstractBeanDefinition#setInitMethodName(String)</code></li></ul></li></ul><p>Bean 延迟初始化（Lazy Initialization）</p><ul><li>XML 配置：<code>&lt;bean lazy-init=”true” ... /&gt;</code></li><li>Java 注解：<code>@Lazy(true)</code></li></ul><p>Bean 销毁（Destroy），同时存在时，顺序从上到下：</p><ul><li><code>@PreDestroy</code> 标注方法</li><li>实现 <code>DisposableBean</code> 接口的 <code>destroy()</code> 方法</li><li>自定义销毁方法<ul><li>XML 配置：<code>&lt;bean destroy=”destroy” ... /&gt;</code></li><li>Java 注解：<code>@Bean(destroy=”destroy”)</code></li><li>Java API：<code>AbstractBeanDefinition#setDestroyMethodName(String)</code></li></ul></li></ul><h2 id="第五章：Spring-IoC-依赖查找"><a href="#第五章：Spring-IoC-依赖查找" class="headerlink" title="第五章：Spring IoC 依赖查找"></a>第五章：Spring IoC 依赖查找</h2><p>单一类型依赖查找接口 - <code>BeanFactory</code></p><ul><li>根据 Bean 名称查找<ul><li><code>getBean(String)</code></li><li>Spring 2.5 覆盖默认参数：<code>getBean(String,Object...)</code></li></ul></li><li>根据 Bean 类型查找<ul><li>Bean 实时查找<ul><li>Spring 3.0 ： <code>getBean(Class)</code></li><li>Spring 4.1 覆盖默认参数：<code>getBean(Class,Object...)</code></li></ul></li><li>Spring 5.1 Bean 延迟查找<ul><li><code>getBeanProvider(Class)</code></li><li><code>getBeanProvider(ResolvableType)</code></li></ul></li></ul></li><li>根据 Bean 名称 + 类型查找：<code>getBean(String,Class)</code></li></ul><p>集合类型依赖查找接口 - <code>ListableBeanFactory</code></p><ul><li>根据 Bean 类型查找<ul><li>获取同类型 Bean 名称列表<ul><li><code>getBeanNamesForType(Class)</code></li><li>Spring 4.2 <code>getBeanNamesForType(ResolvableType)</code></li></ul></li><li>获取同类型 Bean 实例列表<ul><li><code>getBeansOfType(Class)</code> 以及重载方法</li></ul></li></ul></li><li>通过注解类型查找<ul><li>Spring 3.0 获取标注类型 Bean 名称列表<ul><li><code>getBeanNamesForAnnotation(Class&lt;? extends Annotation&gt;)</code></li></ul></li><li>Spring 3.0 获取标注类型 Bean 实例列表<ul><li><code>getBeansWithAnnotation(Class&lt;? extends Annotation&gt;)</code></li></ul></li><li>Spring 3.0 获取指定名称 + 标注类型 Bean 实例<ul><li><code>findAnnotationOnBean(String,Class&lt;? extends Annotation&gt;)</code></li></ul></li></ul></li></ul><p>层次性依赖查找接口 - <code>HierarchicalBeanFactory</code></p><ul><li>双亲 BeanFactory：<code>getParentBeanFactory()</code></li><li>层次性查找<ul><li>根据 Bean 名称查找<ul><li>基于 <code>containsLocalBean</code> 方法实现</li></ul></li><li>根据 Bean 类型查找实例列表<ul><li>单一类型：<code>BeanFactoryUtils#beanOfType</code></li><li>集合类型：<code>BeanFactoryUtils#beansOfTypeIncludingAncestors</code></li></ul></li><li>根据 Java 注解查找名称列表<ul><li><code>BeanFactoryUtils#beanNamesForTypeIncludingAncestors</code></li></ul></li></ul></li></ul><p>Bean 延迟依赖查找接口</p><ul><li><code>org.springframework.beans.factory.ObjectFactory</code></li><li><code>org.springframework.beans.factory.ObjectProvider</code><ul><li>Spring 5 对 Java 8 特性扩展<ul><li>函数式接口<ul><li><code>getIfAvailable(Supplier)</code></li><li><code>ifAvailable(Consumer)</code></li></ul></li><li>Stream 扩展 - <code>stream()</code></li></ul></li></ul></li></ul><p>依赖查找安全性对比：</p><table><thead><tr><th>依赖查找类型</th><th>代表实现</th><th>是否安全</th></tr></thead><tbody><tr><td>单一类型查找</td><td><code>BeanFactory#getBean</code></td><td>否</td></tr><tr><td></td><td><code>ObjectFactory#getObject</code></td><td>否</td></tr><tr><td></td><td><code>ObjectProvider#getIfAvailable</code></td><td>是</td></tr><tr><td>集合类型查找</td><td><code>ListableBeanFactory#getBeansOfType</code></td><td>是</td></tr><tr><td></td><td><code>ObjectProvider#stream</code></td><td>是</td></tr></tbody></table><p>注意：层次性依赖查找的安全性取决于其扩展的单一或集合类型的 BeanFactory 接口</p><p>AbstractApplicationContext 内建可查找的依赖</p><table><thead><tr><th>Bean 名称</th><th>Bean 实例</th><th>使用场景</th></tr></thead><tbody><tr><td>environment</td><td>Environment 对象</td><td>外部化配置以及 Profiles</td></tr><tr><td>systemProperties</td><td>java.util.Properties 对象</td><td>Java 系统属性</td></tr><tr><td>systemEnvironment</td><td>java.util.Map 对象</td><td>操作系统环境变量</td></tr><tr><td>messageSource</td><td>MessageSource 对象</td><td>国际化文案</td></tr><tr><td>lifecycleProcessor</td><td>LifecycleProcessor 对象</td><td>Lifecycle Bean 处理器</td></tr><tr><td>applicationEventMulticaster</td><td>ApplicationEventMulticaster 对 象</td><td>Spring 事件广播器</td></tr></tbody></table><p>注解驱动 Spring 应用上下文内建可查找的依赖</p><table><thead><tr><th>Bean 名称</th><th>Bean 实例</th><th>使用场景</th></tr></thead><tbody><tr><td>org.springframework.context.annotation.internalConfigurationAnnotationProcessor</td><td>ConfigurationClassPostProcesso</td><td>处理 Spring 配置类</td></tr><tr><td>org.springframework.context.annotation.internalAutowiredAnnotationProcessor</td><td>AutowiredAnnotationBeanPostProcessor 对象</td><td>处理 @Autowired 以及 @Value 注解</td></tr><tr><td>org.springframework.context.annotation.internalCommonAnnotationProcessor</td><td>CommonAnnotationBeanPostProcessor 对象</td><td>（条件激活）处理 JSR-250 注解，如 @PostConstruct 等</td></tr><tr><td>org.springframework.context.event.internalEventListenerProcessor</td><td>EventListenerMethodProcessor 对象</td><td>处理标注 @EventListener 的 Spring 事件监听方法</td></tr><tr><td>org.springframework.context.event.internalEventListenerFactory</td><td>DefaultEventListenerFactory 对象</td><td>@EventListener 事件监听方法适配为 ApplicationListener</td></tr><tr><td>org.springframework.context.annotation.internalPersistenceAnnotationProcessor</td><td>PersistenceAnnotationBeanPostProcessor 对象</td><td>（条件激活）处理 JPA 注解场景</td></tr></tbody></table><p>依赖查找中的经典异常，<code>BeansException</code> 子类型</p><table><thead><tr><th>异常类型</th><th>触发条件（举例）</th><th>场景举例</th></tr></thead><tbody><tr><td>NoSuchBeanDefinitionException</td><td>当查找 Bean 不存在于 IoC 容器时 BeanFactory#getBean</td><td>ObjectFactory#getObject</td></tr><tr><td>NoUniqueBeanDefinitionException</td><td>类型依赖查找时，IoC 容器存在多个 Bean 实例</td><td>BeanFactory#getBean(Class)</td></tr><tr><td>BeanInstantiationException</td><td>当 Bean 所对应的类型非具体类时</td><td>BeanFactory#getBean</td></tr><tr><td>BeanCreationException</td><td>当 Bean 初始化过程中</td><td>Bean 初始化方法执行异常时</td></tr><tr><td>BeanDefinitionStoreException</td><td>当 BeanDefinition 配置元信息非法时</td><td>XML 配置资源无法打开时</td></tr></tbody></table><p><code>BeanFactory.getBean</code> 方法的执行是<strong>线程安全</strong>的，超过过程中会增加互斥锁</p><h2 id="第六章：Spring-IoC-依赖注入（Dependency-Injection）"><a href="#第六章：Spring-IoC-依赖注入（Dependency-Injection）" class="headerlink" title="第六章：Spring IoC 依赖注入（Dependency Injection）"></a>第六章：Spring IoC 依赖注入（Dependency Injection）</h2><p>依赖注入的模式和类型</p><ul><li>手动模式 - 配置或者编程的方式，提前安排注入规则<ul><li>XML 资源配置元信息</li><li>Java 注解配置元信息</li><li>API 配置元信息</li></ul></li><li>自动模式 - 实现方提供依赖自动关联的方式，按照內建的注入规则<ul><li>Autowiring（自动绑定）</li></ul></li></ul><p>依赖注入类型</p><table><thead><tr><th>依赖注入类型</th><th>配置元数据举例</th></tr></thead><tbody><tr><td>Setter 方法</td><td><code>&lt;proeprty /&gt;</code></td></tr><tr><td>构造器</td><td><code>&lt;constructor-arg /&gt;</code></td></tr><tr><td>字段</td><td><code>@Autowired User user;</code></td></tr><tr><td>方法</td><td><code>@Autowired public void user(User user) &#123; ... &#125;</code></td></tr><tr><td>接口回调</td><td><code>class MyBean implements BeanFactoryAware &#123; ... &#125;</code></td></tr></tbody></table><p>自动绑定（Autowiring）模式，Autowiring modes</p><p>参考枚举：<code>org.springframework.beans.factory.annotation.Autowire</code></p><table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>no</td><td>默认值，未激活 Autowiring，需要手动指定依赖注入对象。</td></tr><tr><td>byName</td><td>根据被注入属性的名称作为 Bean 名称进行依赖查找，并将对象设置到该属性。</td></tr><tr><td>byType</td><td>根据被注入属性的类型作为依赖类型进行查找，并将对象设置到该属性。</td></tr><tr><td>constructor</td><td>特殊 byType 类型，用于构造器参数。</td></tr></tbody></table><p>Java 注解配置元信息</p><ul><li><p><code>@Autowired</code></p></li><li><p><code>@Resource</code></p></li><li><p><code>@Inject</code></p><p>可选，需要环境中存在 JSR-330 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.inject<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.inject<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><code>@Bean</code></p></li></ul><p>Aware 系列接口回调</p><table><thead><tr><th>內建接口</th><th>说明</th></tr></thead><tbody><tr><td>BeanFactoryAware</td><td>获取 IoC 容器 - BeanFactory</td></tr><tr><td>ApplicationContextAware</td><td>获取 Spring 应用上下文 - ApplicationContext 对象</td></tr><tr><td>EnvironmentAware</td><td>获取 Environment 对象</td></tr><tr><td>ResourceLoaderAware</td><td>获取资源加载器 对象 - ResourceLoader</td></tr><tr><td>BeanClassLoaderAware</td><td>获取加载当前 Bean Class 的 ClassLoader</td></tr><tr><td>BeanNameAware</td><td>获取当前 Bean 的名称</td></tr><tr><td>MessageSourceAware</td><td>获取 MessageSource 对象，用于 Spring 国际化</td></tr><tr><td>ApplicationEventPublisherAware</td><td>获取 ApplicationEventPublishAware 对象，用于 Spring 事件</td></tr><tr><td>EmbeddedValueResolverAware</td><td>获取 StringValueResolver 对象，用于占位符处理</td></tr></tbody></table><p>依赖注入类型选择</p><ul><li>低依赖：构造器注入</li><li>多依赖：Setter 方法注入</li><li>便利性：字段注入</li><li>声明类：方法注入</li></ul><p>各种类型注入：</p><ul><li><p>基础类型</p><ul><li>原生类型（Primitive）：boolean、byte、char、short、int、float、long、double</li><li>标量类型（Scalar）：Number、Character、Boolean、Enum、Locale、Charset、Currency、Properties、UUID</li><li>常规类型（General）：Object、String、TimeZone、Calendar、Optional 等</li><li>Spring 类型：Resource、InputSource、Formatter 等</li></ul></li><li><p>集合类型</p><ul><li>数组类型（Array）：原生类型、标量类型、常规类型、Spring 类型</li><li>集合类型（Collection）<ul><li>Collection：List、Set（SortedSet、NavigableSet、EnumSet）</li><li>Map：Properties</li></ul></li></ul></li><li><p>限定注入</p><ul><li>使用注解 @Qualifier 限定<ul><li>通过 Bean 名称限定</li><li>通过分组限定</li></ul></li><li>基于注解 @Qualifier 扩展限定<ul><li>自定义注解，如 Spring Cloud @LoadBalanced</li></ul></li></ul></li><li><p>延迟依赖注入</p></li><li><p>使用 API ObjectFactory 延迟注入</p><ul><li>单一类型</li><li>集合类型</li></ul></li><li><p>使用 API ObjectProvider 延迟注入（推荐）</p><ul><li>单一类型</li><li>集合类型</li></ul></li></ul><p>依赖处理过程</p><ul><li>入口 - <code>DefaultListableBeanFactory#resolveDependency</code></li><li>依赖描述符 - DependencyDescriptor</li><li>自定绑定候选对象处理器 - AutowireCandidateResolver</li></ul><p>@Autowired、@Inject 注入，参考 <code>AutowiredAnnotationBeanPostProcessor</code></p><p>Java 通用注解注入原理：</p><ul><li><code>CommonAnnotationBeanPostProcessor</code></li><li>注入注解<ul><li>javax.xml.ws.WebServiceRef</li><li>javax.ejb.EJB</li><li>javax.annotation.Resource</li></ul></li><li>生命周期注解<ul><li>javax.annotation.PostConstruct</li><li>javax.annotation.PreDestroy</li></ul></li></ul><p>自定义依赖注入注解</p><ul><li><p>基于 <code>AutowiredAnnotationBeanPostProcessor</code> 实现</p></li><li><p>自定义实现</p><ul><li>生命周期处理<ul><li>InstantiationAwareBeanPostProcessor</li><li>MergedBeanDefinitionPostProcessor</li></ul></li><li>元数据<ul><li>InjectedElement</li><li>InjectionMetadata</li></ul></li></ul></li><li><p><code>org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor</code></p><ul><li><code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor</code><ul><li><code>@Autowired</code></li><li><code>@Value</code></li><li><code>@Inject</code></li></ul></li><li><code>org.springframework.context.annotation.CommonAnnotationBeanPostProcessor</code><ul><li><code>@PostConstruct</code></li><li><code>@PreDestroy</code></li></ul></li></ul></li></ul><p>初始化 Bean 时，<code>AutowiredAnnotationBeanPostProcessor</code> 先解析 Bean 中的依赖（<code>@Autowire</code>，<code>@Value</code>），然后 <code>CommonAnnotationBeanPostProcessor</code> 调用初始化方法 <code>@@PostConstruct</code></p><p>将 <code>@Bean</code> 方法设置为 <code>static</code> ，可以让 Bean 提前初始化。</p><ul><li><p>依赖查找：<code>ApplicationContext#getBean</code></p></li><li><p>依赖处理过程：<code>org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveDependency</code></p></li></ul><h2 id="第七章：Spring-IoC-依赖来源（Dependency-Sources）"><a href="#第七章：Spring-IoC-依赖来源（Dependency-Sources）" class="headerlink" title="第七章：Spring IoC 依赖来源（Dependency Sources）"></a>第七章：Spring IoC 依赖来源（Dependency Sources）</h2><h3 id="Spring-IoC-依赖来源"><a href="#Spring-IoC-依赖来源" class="headerlink" title="Spring IoC 依赖来源"></a>Spring IoC 依赖来源</h3><table><thead><tr><th>来源</th><th>配置元数据</th><th>注册 API</th><th>Spring Bean 对象</th><th>生命周期管理</th><th>配置元信息</th><th>使用场景</th></tr></thead><tbody><tr><td>Spring BeanDefinition</td><td><code>&lt;bean&gt;</code><br><code>@Bean public User user()&#123;...&#125;</code><br>BeanDefinitionBuilder</td><td>BeanDefinitionRegistry#registerBeanDefinition</td><td>是</td><td>是</td><td>有</td><td>依赖查找、依赖注入</td></tr><tr><td>单例对象</td><td>API 实现</td><td>SingletonBeanRegistry#registerSingleton</td><td>是</td><td>否</td><td>无</td><td>依赖查找、依赖注入</td></tr><tr><td>非 Spring 容器管理对象</td><td>Resolvable Dependency</td><td>ConfigurableListableBeanFactory#registerResolvableDependency</td><td>否</td><td>否</td><td>无</td><td>依赖注入</td></tr><tr><td>外部化配置</td><td>@Value</td><td>Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);</td><td>否</td><td>否</td><td>无</td><td>依赖注入</td></tr></tbody></table><p>依赖注入比依赖查找多一个来源，Resolvable Dependency。也就是说，可以通过注入的方式获取这类对象，但不能通过 <code>BeanFactory#getBean</code> 方法从容器中获取。</p><h3 id="Spring-內建-BeanDefintion"><a href="#Spring-內建-BeanDefintion" class="headerlink" title="Spring 內建 BeanDefintion"></a>Spring 內建 BeanDefintion</h3><p>在使用 <code>AnnotationConfigApplicationContext</code> 或者在 XML 配置中配置了注解驱动 <code>&lt;context:annotation-config/&gt;</code> ，或组件扫描 <code>&lt;context:component-scan base-package=&quot;org.acme&quot; /&gt;</code> ，会触发<code>org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors</code> 注入一些 Spring 内建的 Bean：</p><ul><li><p><code>org.springframework.context.annotation.ConfigurationClassPostProcessor</code></p></li><li><p><code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor</code></p></li><li><p><code>org.springframework.context.annotation.CommonAnnotationBeanPostProcessor</code></p></li><li><p><code>org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor</code></p><p>需要环境中有 JPA 依赖</p></li><li><p><code>org.springframework.context.event.EventListenerMethodProcessor</code></p></li><li><p><code>org.springframework.context.event.DefaultEventListenerFactory</code></p></li></ul><h3 id="Spring-內建单例对象"><a href="#Spring-內建单例对象" class="headerlink" title="Spring 內建单例对象"></a>Spring 內建单例对象</h3><p>Spring 启动时，<code>refresh()</code> 方法会调用 <code>org.springframework.context.support.AbstractApplicationContext#prepareBeanFactory</code> ，会注入一些单例对象，名称为：</p><ul><li><code>environment</code></li><li><code>systemProperties</code></li><li><code>systemEnvironment</code></li></ul><p>单例对象由 <code>org.springframework.beans.factory.config.SingletonBeanRegistry</code> 注册，<code>org.springframework.beans.factory.support.AbstractBeanFactory</code> 实现了这个接口，从容器中获取 Bean 的方法 <code>org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</code> 中，会先从单例对象中查找，如果查找到，直接返回；查找不到，则从 Spring BeanDefinition 中获取，并<strong>执行生命周期函数</strong></p><h3 id="Resolvable-Dependency-非-Spring-容器管理对象-可解析依赖"><a href="#Resolvable-Dependency-非-Spring-容器管理对象-可解析依赖" class="headerlink" title="Resolvable Dependency / 非 Spring 容器管理对象 / 可解析依赖"></a>Resolvable Dependency / 非 Spring 容器管理对象 / 可解析依赖</h3><p><code>org.springframework.context.support.AbstractApplicationContext#prepareBeanFactory</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span><br><span class="hljs-comment">// MessageSource registered (and found for autowiring) as a bean.</span><br>beanFactory.register<span class="hljs-constructor">ResolvableDependency(BeanFactory.<span class="hljs-params">class</span>, <span class="hljs-params">beanFactory</span>)</span>;<br>beanFactory.register<span class="hljs-constructor">ResolvableDependency(ResourceLoader.<span class="hljs-params">class</span>, <span class="hljs-params">this</span>)</span>;<br>beanFactory.register<span class="hljs-constructor">ResolvableDependency(ApplicationEventPublisher.<span class="hljs-params">class</span>, <span class="hljs-params">this</span>)</span>;<br>beanFactory.register<span class="hljs-constructor">ResolvableDependency(ApplicationContext.<span class="hljs-params">class</span>, <span class="hljs-params">this</span>)</span>;<br></code></pre></td></tr></table></figure><p>后三个实际上都是同一个 <code>ApplicationContext</code></p><p><strong>order 值越大，优先级越小</strong></p><h2 id="第八章：Spring-Bean-作用域"><a href="#第八章：Spring-Bean-作用域" class="headerlink" title="第八章：Spring Bean 作用域"></a>第八章：Spring Bean 作用域</h2><table><thead><tr><th>作用域</th><th>说明</th></tr></thead><tbody><tr><td><strong>singleton</strong></td><td>默认 Spring Bean 作用域，一个 BeanFactory 有且仅有一个实例</td></tr><tr><td><strong>prototype</strong></td><td>原型作用域，每次依赖查找和依赖注入生成新 Bean 对象</td></tr><tr><td>request</td><td>将 Spring Bean 存储在 ServletRequest 上下文中</td></tr><tr><td>session</td><td>将 Spring Bean 存储在 HttpSession 中</td></tr><tr><td>application</td><td>将 Spring Bean 存储在 ServletContext 中</td></tr></tbody></table><p><strong>注意事项</strong>：</p><ul><li>Spring 容器没有办法管理 prototype Bean 的完整生命周期，也没有办法记录示例的存<br>在。销毁回调方法将不会执行，可以利用 BeanPostProcessor 进行清扫工作。</li><li><strong>无论是 Singleton 还是 Prototype Bean 均会执行初始化方法回调，不过仅 Singleton Bean 会执行销毁方法回调</strong></li></ul><p><code>@Scope</code> 注解定义原型 Bean ：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Bean</span><br><span class="hljs-variable">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)<br>public static User prototypeUser() &#123;<br><span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">createUser</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="“request”-Bean-作用域"><a href="#“request”-Bean-作用域" class="headerlink" title="“request” Bean 作用域"></a>“request” Bean 作用域</h3><ul><li>XML - <code>&lt;bean class= &quot;...&quot; scope = &quot;request&quot; /&gt;</code></li><li>Java 注解 - <code>@RequestScope</code> 或 <code>@Scope(WebApplicationContext.SCOPE_REQUEST)</code></li></ul><p>每次使用的 CGLIB 代理对象是同一个，但是被代理的对象每次都会重新生成。</p><p>使用 IDEA 进行远程调试：</p><ul><li>在 Edit Configurations 中新增一个 Remote ，使用命令启动 jar 时，在启动命令中增加 Remote 里的内容，启动 jar 以及 Remote，打断点进行调试。</li></ul><p>实现 API</p><ul><li><code>@RequestScope</code></li><li><code>RequestScope</code></li></ul><h3 id="“session”-Bean-作用域"><a href="#“session”-Bean-作用域" class="headerlink" title="“session” Bean 作用域"></a>“session” Bean 作用域</h3><p>配置</p><ul><li>XML - <code>&lt;bean class= &quot;...&quot; scope = &quot;session&quot; /&gt;</code></li><li>Java 注解 - <code>@RequestScope</code> 或 <code>@Scope(WebApplicationContext.SCOPE_REQUEST)</code></li></ul><p>实现 API</p><ul><li><code>@SessionScope</code></li><li><code>SessionScope</code></li></ul><h3 id="“application”-Bean-作用域"><a href="#“application”-Bean-作用域" class="headerlink" title="“application” Bean 作用域"></a>“application” Bean 作用域</h3><p>配置</p><ul><li>XML - <code>&lt;bean class= &quot;...&quot; scope = &quot;application&quot; /&gt;</code></li><li>Java 注解 - <code>@ApplicationScope</code> 或 <code>@Scope(WebApplicationContext.SCOPE_APPLICATION)</code></li></ul><p>实现 API</p><ul><li><code>@ApplicationScope</code></li><li><code>ServletContextScope</code></li></ul><p>实现方式与 request 和 session 不同，这里直接将 Bean 放入 <code>ServletContext</code> 中</p><h3 id="自定义-Bean-作用域"><a href="#自定义-Bean-作用域" class="headerlink" title="自定义 Bean 作用域"></a>自定义 Bean 作用域</h3><p>实现 Scope</p><ul><li><code>org.springframework.beans.factory.config.Scope</code></li></ul><p>注册 Scope</p><ul><li><p>API</p><p><code>org.springframework.beans.factory.config.ConfigurableBeanFactory#registerScope</code></p></li><li><p>配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.beans.factory.config.CustomScopeConfigurer&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="第九章：Spring-Bean-生命周期（Bean-Lifecycle）"><a href="#第九章：Spring-Bean-生命周期（Bean-Lifecycle）" class="headerlink" title="第九章：Spring Bean 生命周期（Bean Lifecycle）"></a>第九章：Spring Bean 生命周期（Bean Lifecycle）</h2><h3 id="Spring-Bean-元信息配置阶段"><a href="#Spring-Bean-元信息配置阶段" class="headerlink" title="Spring Bean 元信息配置阶段"></a>Spring Bean 元信息配置阶段</h3><p>BeanDefinition 配置</p><ul><li>面向资源<ul><li>XML 配置</li><li>Properties 资源配置</li></ul></li><li>面向注解</li><li>面向 API</li></ul><h3 id="Spring-Bean-元信息解析阶段"><a href="#Spring-Bean-元信息解析阶段" class="headerlink" title="Spring Bean 元信息解析阶段"></a>Spring Bean 元信息解析阶段</h3><p>BeanDefinition 解析</p><ul><li>面向资源 BeanDefinition 解析 - <code>BeanDefinitionReader</code><ul><li>XML 解析器 - <code>XmlBeanDefinitionReader</code></li><li>Properties 解析器 - <code>PropertiesBeanDefinitionReader</code></li></ul></li><li>面向注解 BeanDefinition 解析 - <code>AnnotatedBeanDefinitionReader</code></li></ul><h3 id="Spring-Bean-注册阶段"><a href="#Spring-Bean-注册阶段" class="headerlink" title="Spring Bean 注册阶段"></a>Spring Bean 注册阶段</h3><p>BeanDefinition 注册接口</p><p><code>BeanDefinitionRegistry</code></p><h3 id="Spring-BeanDefinition-合并阶段"><a href="#Spring-BeanDefinition-合并阶段" class="headerlink" title="Spring BeanDefinition 合并阶段"></a>Spring BeanDefinition 合并阶段</h3><p>BeanDefinition 合并</p><p>父子 BeanDefinition 合并</p><ul><li>当前 BeanFactory 查找</li><li>层次性 BeanFactory 查找</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;org.geekbang.thinking.in.spring.ioc.overview.domain.User&quot;</span>&gt;<br>    &lt;<span class="hljs-keyword">property</span> /&gt;<br>    ...<br>&lt;/bean&gt;<br><br>&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;superUser&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;org.geekbang.thinking.in.spring.ioc.overview.domain.SuperUser&quot;</span> parent=<span class="hljs-string">&quot;user&quot;</span><br>      primary=<span class="hljs-string">&quot;true&quot;</span>&gt;<br>    &lt;<span class="hljs-keyword">property</span> /&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p><code>XmlBeanDefinitionReader#loadBeanDefinitions</code> 加载 XML 文件时，赋值 <code>DefaultListableBeanFactory#beanDefinitionMap</code>，这个 Map 中的 <code>BeanDefinition</code> 还没有合并，也就是说 superUser 的属性值还没有从 user 中继承过来。</p><p><code>AbstractBeanFactory#getBean</code> 获取 bean 时，执行 <code>AbstractBeanFactory#getMergedBeanDefinition</code> ，对 superUser 进行合并，放入 <code>AbstractBeanFactory#mergedBeanDefinitions</code> 中。</p><h3 id="Spring-Bean-Class-加载阶段"><a href="#Spring-Bean-Class-加载阶段" class="headerlink" title="Spring Bean Class 加载阶段"></a>Spring Bean Class 加载阶段</h3><ul><li>ClassLoader 类加载</li><li>Java Security 安全控制</li><li>ConfigurableBeanFactory 临时 ClassLoader</li></ul><p><code>AbstractBeanDefinition#beanClass</code> 被定义为 Object ，有两种形式，一种是 全类名 的 String，另一种是 Class 对象</p><p>Java Security 安全控制 相关</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>get<span class="hljs-constructor">SecurityManager()</span> != null) &#123;<br>return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AccessController</span>.</span></span><span class="hljs-keyword">do</span><span class="hljs-constructor">Privileged((PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;)</span> <span class="hljs-literal">()</span> -&gt;<br><span class="hljs-keyword">do</span><span class="hljs-constructor">ResolveBeanClass(<span class="hljs-params">mbd</span>, <span class="hljs-params">typesToMatch</span>)</span>, get<span class="hljs-constructor">AccessControlContext()</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>临时 ClassLoader 与 load-time weaving 技术有关，用于进行类型检查时（即尚未创建实际实例）</p><h3 id="Spring-Bean-实例化阶段"><a href="#Spring-Bean-实例化阶段" class="headerlink" title="Spring Bean 实例化阶段"></a>Spring Bean 实例化阶段</h3><ul><li><p>传统实例化方式</p><ul><li>实例化策略 - InstantiationStrategy</li></ul></li><li><p>构造器依赖注入</p><p><strong>实例化阶段，如果使用构造器注入，将解析构造器注入的依赖</strong></p></li></ul><p><code>AbstractAutowireCapableBeanFactory#createBeanInstance</code></p><h4 id="Spring-Bean-实例化前阶段"><a href="#Spring-Bean-实例化前阶段" class="headerlink" title="Spring Bean 实例化前阶段"></a>Spring Bean 实例化前阶段</h4><ul><li>非主流生命周期 - Bean 实例化前阶段<ul><li><code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</code></li></ul></li></ul><p>返回非 null 时，阻止 bean 的默认实例化过程及以下生命周期</p><p>唯一可以进一步生命周期处理的是 <code>BeanPostProcessor#postProcessAfterInitialization</code></p><h4 id="Spring-Bean-实例化后阶段"><a href="#Spring-Bean-实例化后阶段" class="headerlink" title="Spring Bean 实例化后阶段"></a>Spring Bean 实例化后阶段</h4><ul><li>Bean 属性赋值（Populate）判断<ul><li><code>InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation</code></li></ul></li></ul><p>在给 bean 实例做属性赋值的方法 <code>AbstractAutowireCapableBeanFactory#populateBean</code> 的最开始调用，如果返回 false ，阻止 bean 的属性赋值及以下生命周期</p><h3 id="Spring-Bean-属性赋值前阶段"><a href="#Spring-Bean-属性赋值前阶段" class="headerlink" title="Spring Bean 属性赋值前阶段"></a>Spring Bean 属性赋值前阶段</h3><ul><li><p>Bean 属性值元信息</p><ul><li>PropertyValues</li></ul></li><li><p>Bean 属性赋值前回调</p><ul><li><p>Spring 1.2 - 5.0：<code>InstantiationAwareBeanPostProcessor#postProcessPropertyValues</code></p><p>此方法已过期，使用 <code>postProcessProperties</code> 替代，为了兼容，只有在 <code>postProcessProperties</code> 返回 null 时（默认实现），才会调用此方法</p></li><li><p>Spring 5.1：<code>InstantiationAwareBeanPostProcessor#postProcessProperties</code></p></li></ul></li></ul><p>在工厂将给定属性值应用于给定 bean 之前，对它们进行处理。</p><p>在依赖注入（ <code>byName</code> 或 <code>byType</code> ）之后，在将配置的属性赋值给 bean 实例 <code>AbstractAutowireCapableBeanFactory#applyPropertyValues</code> 之前执行此阶段方法</p><h3 id="Spring-Bean-初始化阶段"><a href="#Spring-Bean-初始化阶段" class="headerlink" title="Spring Bean 初始化阶段"></a>Spring Bean 初始化阶段</h3><p><code>AbstractAutowireCapableBeanFactory#initializeBean</code></p><h4 id="Spring-Bean-Aware-接口回调阶段"><a href="#Spring-Bean-Aware-接口回调阶段" class="headerlink" title="Spring Bean Aware 接口回调阶段"></a>Spring Bean Aware 接口回调阶段</h4><p>Spring Aware 接口，执行顺序从上到下</p><ul><li><code>BeanNameAware</code></li><li><code>BeanClassLoaderAware</code></li><li><code>BeanFactoryAware</code></li></ul><p>依赖于 <code>ApplicationContext</code> ：</p><ul><li><code>EnvironmentAware</code></li><li><code>EmbeddedValueResolverAware</code></li><li><code>ResourceLoaderAware</code></li><li><code>ApplicationEventPublisherAware</code></li><li><code>MessageSourceAware</code></li><li><code>ApplicationContextAware</code></li></ul><p>在初始化 Bean 实例 <code>AbstractAutowireCapableBeanFactory#initializeBean</code> 的最开始执行此阶段，前三个接口直接调用，而依赖于 ApplicationContext 的几个 Aware 接口，在 ApplicationContext 的生命周期中，会在 beanFactory 中加入 <code>ApplicationContextAwareProcessor</code> ，在其 <code>postProcessBeforeInitialization</code> 方法中执行调用</p><p><code>ApplicationContextAwareProcessor</code> 是包权限的</p><h4 id="Spring-Bean-初始化前阶段"><a href="#Spring-Bean-初始化前阶段" class="headerlink" title="Spring Bean 初始化前阶段"></a>Spring Bean 初始化前阶段</h4><p>已完成</p><ul><li><p>Bean 实例化</p></li><li><p>Bean 属性赋值</p></li><li><p>Bean Aware 接口回调</p></li></ul><p>方法回调</p><ul><li><code>BeanPostProcessor#postProcessBeforeInitialization</code></li></ul><h4 id="Spring-Bean-初始化阶段-1"><a href="#Spring-Bean-初始化阶段-1" class="headerlink" title="Spring Bean 初始化阶段"></a>Spring Bean 初始化阶段</h4><p>Bean 初始化（Initialization）</p><ul><li><code>@PostConstruct</code> 标注方法</li><li>实现 <code>InitializingBean</code> 接口的 <code>afterPropertiesSet()</code> 方法</li><li>自定义初始化方法</li></ul><p>对 <code>@PostConstruct</code> 的处理需要依赖于注解驱动，<code>CommonAnnotationBeanPostProcessor#postProcessBeforeInitialization</code></p><h4 id="Spring-Bean-初始化后阶段"><a href="#Spring-Bean-初始化后阶段" class="headerlink" title="Spring Bean 初始化后阶段"></a>Spring Bean 初始化后阶段</h4><p>方法回调</p><ul><li><code>BeanPostProcessor#postProcessAfterInitialization</code></li></ul><h4 id="Spring-Bean-初始化完成阶段"><a href="#Spring-Bean-初始化完成阶段" class="headerlink" title="Spring Bean 初始化完成阶段"></a>Spring Bean 初始化完成阶段</h4><p>方法回调</p><ul><li>Spring 4.1 +：<code>SmartInitializingSingleton#afterSingletonsInstantiated</code></li></ul><p><code>SmartInitializingSingleton</code> 通常在 Spring ApplicationContext 场景使用</p><p>使用 <code>BeanFactory</code> 时，需要显式的调用此方法；在 <code>ApplicationContext</code> 启动时，调用了此方法 <code>AbstractApplicationContext#finishBeanFactoryInitialization</code> ，这个方法做了两件事情：</p><ol><li>将已注册的 <code>BeanDefinition</code> 初始化成 Spring Bean</li><li>调用所有 <code>SmartInitializingSingleton#afterSingletonsInstantiated</code></li></ol><h3 id="Spring-Bean-销毁前阶段"><a href="#Spring-Bean-销毁前阶段" class="headerlink" title="Spring Bean 销毁前阶段"></a>Spring Bean 销毁前阶段</h3><ul><li>方法回调<ul><li><code>DestructionAwareBeanPostProcessor#postProcessBeforeDestruction</code></li></ul></li></ul><p>执行 <code>ConfigurableBeanFactory#destroyBean</code> 时，触发 Bean 前销毁阶段</p><p>对 <code>@PreDestroy</code> 的处理需要依赖于注解驱动，<code>CommonAnnotationBeanPostProcessor#postProcessBeforeDestruction</code></p><h3 id="Spring-Bean-销毁阶段"><a href="#Spring-Bean-销毁阶段" class="headerlink" title="Spring Bean 销毁阶段"></a>Spring Bean 销毁阶段</h3><p>Bean 销毁（Destroy）</p><ul><li><code>@PreDestroy</code> 标注方法</li><li>实现 <code>DisposableBean</code> 接口的 <code>destroy()</code> 方法</li><li>自定义销毁方法</li></ul><p>对 <code>@PreDestroy</code> 的处理需要依赖于注解驱动，<code>CommonAnnotationBeanPostProcessor#postProcessBeforeDestruction</code></p><p><code>CommonAnnotationBeanPostProcessor</code> 是 <code>DestructionAwareBeanPostProcessor</code> 的实现类之一</p><p>如果其他 <code>DestructionAwareBeanPostProcessor</code> 排序在 <code>CommonAnnotationBeanPostProcessor</code> 后，会先执行 <code>@PreDestroy</code> 标注方法，后执行其他 <code>DestructionAwareBeanPostProcessor</code> 销毁前阶段方法</p><h3 id="Spring-Bean-垃圾收集"><a href="#Spring-Bean-垃圾收集" class="headerlink" title="Spring Bean 垃圾收集"></a>Spring Bean 垃圾收集</h3><p>Bean 垃圾回收（GC）</p><ul><li>关闭 Spring 容器（应用上下文）</li><li>执行 GC</li><li>Spring Bean 覆盖的 <code>finalize()</code> 方法被回调</li></ul><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="BeanPostProcessor-的使用场景有哪些？"><a href="#BeanPostProcessor-的使用场景有哪些？" class="headerlink" title="BeanPostProcessor 的使用场景有哪些？"></a>BeanPostProcessor 的使用场景有哪些？</h3><p>答：<code>BeanPostProcessor</code> 提供 Spring Bean 初始化前和初始化后的生命周期回调，分别对应 <code>postProcessBeforeInitialization</code> 以及 <code>postProcessAfterInitialization</code> 方法，允许对关心的 Bean 进行扩展，甚至是替换。</p><p>加分项：其中，<code>ApplicationContext</code> 相关的 <code>Aware</code> 回调也是基于 <code>BeanPostProcessor</code> 实现，即 <code>ApplicationContextAwareProcessor</code> 。</p><h3 id="BeanFactoryPostProcessor-与-BeanPostProcessor-的区别"><a href="#BeanFactoryPostProcessor-与-BeanPostProcessor-的区别" class="headerlink" title="BeanFactoryPostProcessor 与 BeanPostProcessor 的区别"></a>BeanFactoryPostProcessor 与 BeanPostProcessor 的区别</h3><p>答：<code>BeanFactoryPostProcessor</code> 是 Spring <code>BeanFactory</code>（实际为 <code>ConfigurableListableBeanFactory</code>） 的后置处理器，用于扩展 <code>BeanFactory</code>，或通过 <code>BeanFactory</code> 进行依赖查找和依赖注入。</p><p>加分项：<code>BeanFactoryPostProcessor</code> 必须有 Spring <code>ApplicationContext</code> 执行，<code>BeanFactory</code> 无法与其直接交互。而 <code>BeanPostProcessor</code> 则直接与 <code>BeanFactory</code> 关联，属于 N 对 1 的关系。</p><h3 id="BeanFactory-是怎样处理-Bean-生命周期？"><a href="#BeanFactory-是怎样处理-Bean-生命周期？" class="headerlink" title="BeanFactory 是怎样处理 Bean 生命周期？"></a>BeanFactory 是怎样处理 Bean 生命周期？</h3><p><code>BeanFactory</code> 的默认实现为 <code>DefaultListableBeanFactory</code>，其中 Bean 生命周期与方法映射如下：</p><ul><li>BeanDefinition 注册阶段 - <code>registerBeanDefinition</code></li><li>BeanDefinition 合并阶段 - <code>getMergedBeanDefinition</code></li><li>Bean 实例化前阶段 - <code>resolveBeforeInstantiation</code></li><li>Bean 实例化阶段 - <code>createBeanInstance</code></li><li>Bean 实例化后阶段 - <code>populateBean</code></li><li>Bean 属性赋值前阶段 - <code>populateBean</code></li><li>Bean 属性赋值阶段 - <code>populateBean</code></li><li>Bean Aware 接口回调阶段 - <code>initializeBean</code></li><li>Bean 初始化前阶段 - <code>initializeBean</code></li><li>Bean 初始化阶段 - <code>initializeBean</code></li><li>Bean 初始化后阶段 - <code>initializeBean</code></li><li>Bean 初始化完成阶段 - <code>preInstantiateSingletons</code></li><li>Bean 销毁前阶段 - <code>destroyBean</code></li><li>Bean 销毁阶段 - <code>destroyBean</code></li></ul><h2 id="第十章：Spring-配置元信息（Configuration-Metadata）"><a href="#第十章：Spring-配置元信息（Configuration-Metadata）" class="headerlink" title="第十章：Spring 配置元信息（Configuration Metadata）"></a>第十章：Spring 配置元信息（Configuration Metadata）</h2><h3 id="Spring-配置元信息"><a href="#Spring-配置元信息" class="headerlink" title="Spring 配置元信息"></a>Spring 配置元信息</h3><ul><li>Spring Bean 配置元信息 - <code>BeanDefinition</code></li><li>Spring Bean 属性元信息 - <code>PropertyValues</code></li><li>Spring 容器配置元信息</li><li>Spring 外部化配置元信息 - <code>PropertySource</code></li><li>Spring Profile 元信息 - <code>@Profile</code></li></ul><h3 id="Spring-Bean-配置元信息"><a href="#Spring-Bean-配置元信息" class="headerlink" title="Spring Bean 配置元信息"></a>Spring Bean 配置元信息</h3><p>Bean 配置元信息 - <code>BeanDefinition</code></p><ul><li><code>GenericBeanDefinition</code>：通用型 <code>BeanDefinition</code></li><li><code>RootBeanDefinition</code>：无 Parent 的 <code>BeanDefinition</code> 或者合并后 <code>BeanDefinition</code></li><li><code>AnnotatedBeanDefinition</code>：注解标注的 <code>BeanDefinition</code></li></ul><h3 id="Spring-Bean-属性元信息"><a href="#Spring-Bean-属性元信息" class="headerlink" title="Spring Bean 属性元信息"></a>Spring Bean 属性元信息</h3><ul><li>Bean 属性元信息 - <code>PropertyValues</code><ul><li>可修改实现 - <code>MutablePropertyValues</code></li><li>元素成员 - <code>PropertyValue</code></li></ul></li><li>Bean 属性上下文存储 - <code>AttributeAccessor</code></li><li>Bean 元信息元素 - <code>BeanMetadataElement</code></li></ul><p><code>AttributeAccessorSupport#attributes</code> 是附加属性（不影响 Bean populate、initialize）</p><p><code>BeanMetadataAttributeAccessor#source</code> 存储当前 BeanDefinition 来自于何方（辅助作用）</p><h3 id="Spring-容器配置元信息"><a href="#Spring-容器配置元信息" class="headerlink" title="Spring 容器配置元信息"></a>Spring 容器配置元信息</h3><h4 id="Spring-XML-配置元信息-beans-元素相关"><a href="#Spring-XML-配置元信息-beans-元素相关" class="headerlink" title="Spring XML 配置元信息 - beans 元素相关"></a>Spring XML 配置元信息 - beans 元素相关</h4><table><thead><tr><th>beans 元素属性</th><th>默认值</th><th>使用场景</th></tr></thead><tbody><tr><td>profile</td><td>null（留空）</td><td>Spring Profiles 配置值</td></tr><tr><td>default-lazy-init</td><td>default</td><td>当 outter beans “default-lazy-init” 属性存在时，继承该值，否则为 “false”</td></tr><tr><td>default-merge</td><td>default</td><td>当 outter beans “default-merge” 属性存在时，继承该值，否则为 “false”</td></tr><tr><td>default-autowire</td><td>default</td><td>当 outter beans “default-autowire” 属性存在时，继承该值，否则为 “no”</td></tr><tr><td>default-autowire-candidates</td><td>null（留空）</td><td>默认 Spring Beans 名称 pattern</td></tr><tr><td>default-init-method</td><td>null（留空）</td><td>默认 Spring Beans 自定义初始化方法</td></tr><tr><td>default-destroy-method</td><td>null（留空）</td><td>默认 Spring Beans 自定义销毁方法</td></tr></tbody></table><h4 id="Spring-XML-配置元信息-应用上下文相关"><a href="#Spring-XML-配置元信息-应用上下文相关" class="headerlink" title="Spring XML 配置元信息 - 应用上下文相关"></a>Spring XML 配置元信息 - 应用上下文相关</h4><table><thead><tr><th>XML 元素</th><th>使用场景</th></tr></thead><tbody><tr><td>&lt;context:annotation-config /&gt;</td><td>激活 Spring 注解驱动</td></tr><tr><td>&lt;context:component-scan /&gt;</td><td>Spring @Component 以及自定义注解扫描</td></tr><tr><td>&lt;context:load-time-weaver /&gt;</td><td>激活 Spring LoadTimeWeaver</td></tr><tr><td>&lt;context:mbean-export /&gt;</td><td>暴露 Spring Beans 作为 JMX Beans</td></tr><tr><td>&lt;context:mbean-server /&gt;</td><td>将当前平台作为 MBeanServer</td></tr><tr><td>&lt;context:property-placeholder /&gt;</td><td>加载外部化配置资源作为 Spring 属性配置</td></tr><tr><td>&lt;context:property-override /&gt;</td><td>利用外部化配置资源覆盖 Spring 属性值</td></tr></tbody></table><p><code>org.springframework.beans.factory.xml.BeanDefinitionParserDelegate</code></p><p><code>populateDefaults</code></p><h3 id="基于-XML-资源装载-Spring-Bean-配置元信息"><a href="#基于-XML-资源装载-Spring-Bean-配置元信息" class="headerlink" title="基于 XML 资源装载 Spring Bean 配置元信息"></a>基于 XML 资源装载 Spring Bean 配置元信息</h3><table><thead><tr><th>XML 元素</th><th>使用场景</th></tr></thead><tbody><tr><td>&lt;beans:beans /&gt;</td><td>单 XML 资源下的多个 Spring Beans 配置</td></tr><tr><td>&lt;beans:bean /&gt;</td><td>单个 Spring Bean 定义（BeanDefinition）配置</td></tr><tr><td>&lt;beans:alias /&gt;</td><td>为 Spring Bean 定义（BeanDefinition）映射别名</td></tr><tr><td>&lt;beans:import /&gt;</td><td>加载外部 Spring XML 配置资源</td></tr></tbody></table><p>底层实现 - <code>XmlBeanDefinitionReader</code></p><p>加载 BeanDefinition 入口方法 <code>loadBeanDefinitions</code></p><p>使用 DOM 来解析 XML 文件，实现为 <code>BeanDefinitionDocumentReader</code></p><p>解析方法：<code>XmlBeanDefinitionReader#parseBeanDefinitions</code></p><ol><li>判断 beans 标签的 profile 属性，如果不在激活状态，直接返回，不再向下解析</li><li>如果是 beans 标签下的特殊元素，进行特殊处理，方法为 <code>DefaultBeanDefinitionDocumentReader#parseDefaultElement</code><ul><li>beans</li><li>bean</li><li>alias</li><li>import</li></ul></li><li>否则，<code>BeanDefinitionParserDelegate#parseCustomElement</code></li></ol><h3 id="基于-Properties-资源装载-Spring-Bean-配置元信息"><a href="#基于-Properties-资源装载-Spring-Bean-配置元信息" class="headerlink" title="基于 Properties 资源装载 Spring Bean 配置元信息"></a>基于 Properties 资源装载 Spring Bean 配置元信息</h3><table><thead><tr><th>Properties 属性名</th><th>使用场景</th></tr></thead><tbody><tr><td>(class)</td><td>Bean 类全称限定名</td></tr><tr><td>(abstract)</td><td>是否为抽象的 BeanDefinition</td></tr><tr><td>(parent)</td><td>指定 parent BeanDefinition 名称</td></tr><tr><td>(lazy-init)</td><td>是否为延迟初始化</td></tr><tr><td>(ref)</td><td>引用其他 Bean 的名称</td></tr><tr><td>(scope)</td><td>设置 Bean 的 scope 属性</td></tr><tr><td>${n}</td><td>n 表示第 n+1 个构造器参数</td></tr></tbody></table><p>底层实现 - <code>PropertiesBeanDefinitionReader</code></p><p>如果出现重复的 Bean 定义，后者不会被注册进 <code>BeanFactory</code> 中</p><h3 id="基于-Java-注解装载-Spring-Bean-配置元信息"><a href="#基于-Java-注解装载-Spring-Bean-配置元信息" class="headerlink" title="基于 Java 注解装载 Spring Bean 配置元信息"></a>基于 Java 注解装载 Spring Bean 配置元信息</h3><h4 id="Spring-模式注解"><a href="#Spring-模式注解" class="headerlink" title="Spring 模式注解"></a>Spring 模式注解</h4><table><thead><tr><th>Spring 注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td>@Repository</td><td>数据仓储模式注解</td><td>2.0</td></tr><tr><td>@Component</td><td>通用组件模式注解</td><td>2.5</td></tr><tr><td>@Service</td><td>服务模式注解</td><td>2.5</td></tr><tr><td>@Controller</td><td>Web 控制器模式注解</td><td>2.5</td></tr><tr><td>@Configuration</td><td>配置类模式注解</td><td>3.0</td></tr></tbody></table><p><code>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#registerDefaultFilters</code> 将 <code>@Component</code> 及其派生注解加入筛选</p><h4 id="Spring-Bean-定义注解"><a href="#Spring-Bean-定义注解" class="headerlink" title="Spring Bean 定义注解"></a>Spring Bean 定义注解</h4><table><thead><tr><th>Spring 注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td>@Bean</td><td>替换 XML 元素 <code>&lt;bean&gt;</code></td><td>3.0</td></tr><tr><td>@DependsOn</td><td>替代 XML 属性 <code>&lt;bean depends-on="..."/&gt;</code></td><td>3.0</td></tr><tr><td>@Lazy</td><td>替代 XML 属性 <code>&lt;bean lazy-init="true|falses" /&gt;</code></td><td>3.0</td></tr><tr><td>@Primary</td><td>替换 XML 元素 <code>&lt;bean primary="true|false" /&gt;</code></td><td>3.0</td></tr><tr><td>@Role</td><td>替换 XML 元素 <code>&lt;bean role="..." /&gt;</code></td><td>3.1</td></tr><tr><td>@Lookup</td><td>替代 XML 属性 <code>&lt;bean lookup-method="..."&gt;</code></td><td>4.1</td></tr></tbody></table><h4 id="Spring-Bean-依赖注入注解"><a href="#Spring-Bean-依赖注入注解" class="headerlink" title="Spring Bean 依赖注入注解"></a>Spring Bean 依赖注入注解</h4><table><thead><tr><th>Spring 注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td>@Autowired</td><td>Bean 依赖注入，支持多种依赖查找方式</td><td>2.5</td></tr><tr><td>@Qualifier</td><td>细粒度的 @Autowired 依赖查找</td><td>2.5</td></tr></tbody></table><p><code>AutowiredAnnotationBeanPostProcessor</code> 与 <code>@Autowired</code> 相关</p><table><thead><tr><th>Java 注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td>@Resource</td><td>类似于 @Autowired</td><td>2.5</td></tr><tr><td>@Inject</td><td>类似于 @Autowired</td><td>2.5</td></tr></tbody></table><p><code>CommonAnnotationBeanPostProcessor</code> 与 <code>@Resource</code> 相关</p><p><code>AutowiredAnnotationBeanPostProcessor</code> 与 <code>@Inject</code> 相关</p><h4 id="Spring-Bean-条件装配注解"><a href="#Spring-Bean-条件装配注解" class="headerlink" title="Spring Bean 条件装配注解"></a>Spring Bean 条件装配注解</h4><table><thead><tr><th>Spring 注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td>@Profile</td><td>配置化条件装配</td><td>3.1</td></tr><tr><td>@Conditional</td><td>编程条件装配</td><td>4.0</td></tr></tbody></table><p><code>@Profile</code> 基于 <code>@Conditional</code> 实现</p><p><code>@Conditional</code> 相关 API，<code>ConditionEvaluator</code> ，用于判断 Bean 是否满足条件，满足则注册</p><h4 id="Spring-Bean-生命周期回调注解"><a href="#Spring-Bean-生命周期回调注解" class="headerlink" title="Spring Bean 生命周期回调注解"></a>Spring Bean 生命周期回调注解</h4><table><thead><tr><th>Spring 注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td>@PostConstruct</td><td>替换 XML 元素 <code>&lt;bean init-method="..." /&gt;</code> 或 <code>InitializingBean</code></td><td>2.5</td></tr><tr><td>@PreDestroy</td><td>替换 XML 元素 <code>&lt;bean destroy-method="..." /&gt;</code> 或 <code>DisposableBean</code></td><td>2.5</td></tr></tbody></table><p><code>CommonAnnotationBeanPostProcessor</code></p><h3 id="Spring-Bean-配置元信息底层实现"><a href="#Spring-Bean-配置元信息底层实现" class="headerlink" title="Spring Bean 配置元信息底层实现"></a>Spring Bean 配置元信息底层实现</h3><h4 id="Spring-BeanDefinition-解析与注册"><a href="#Spring-BeanDefinition-解析与注册" class="headerlink" title="Spring BeanDefinition 解析与注册"></a>Spring BeanDefinition 解析与注册</h4><table><thead><tr><th>实现场景</th><th>实现类</th><th>起始版本</th></tr></thead><tbody><tr><td>XML 资源</td><td>XmlBeanDefinitionReader</td><td>1.0</td></tr><tr><td>Properties 资源</td><td>PropertiesBeanDefinitionReader</td><td>1.0</td></tr><tr><td>Java 注解</td><td>AnnotatedBeanDefinitionReader</td><td>3.0</td></tr></tbody></table><ul><li><p><code>XmlBeanDefinitionReader</code> 和 <code>PropertiesBeanDefinitionReader</code> 都继承自 <code>AbstractBeanDefinitionReader</code>，实现了 <code>BeanDefinitionReader</code> 接口，与资源（Resource）相关联</p></li><li><p><code>AnnotatedBeanDefinitionReader</code> 是独立的类，与 <code>Resource</code> 无关</p></li><li><p>Spring XML 资源 BeanDefinition 解析与注册</p><ul><li>核心 API - <code>XmlBeanDefinitionReader</code><ul><li>资源 - Resource</li><li>底层 - <code>BeanDefinitionDocumentReader</code><ul><li>XML 解析 - Java DOM Level 3 API</li><li>BeanDefinition 解析 - <code>BeanDefinitionParserDelegate</code></li><li>BeanDefinition 注册 - <code>BeanDefinitionRegistry</code></li></ul></li></ul></li></ul></li><li><p>Spring Properties 资源 BeanDefinition 解析与注册</p><ul><li>核心 API - <code>PropertiesBeanDefinitionReader</code><ul><li>资源<ul><li>字节流 - <code>Resource</code></li><li>字符流 - <code>EncodedResouce</code></li></ul></li><li>底层<ul><li>存储 - <code>java.util.Properties</code></li><li>BeanDefinition 解析 - API 内部实现</li><li>BeanDefinition 注册 - <code>BeanDefinitionRegistry</code></li></ul></li></ul></li></ul></li><li><p>Spring Java 注册 BeanDefinition 解析与注册</p><ul><li>核心 API - <code>AnnotatedBeanDefinitionReader</code><ul><li>资源<ul><li>类对象 - <code>java.lang.Class</code></li></ul></li><li>底层<ul><li>条件评估 - <code>ConditionEvaluator</code></li><li>Bean 范围解析 - <code>ScopeMetadataResolver</code></li><li>BeanDefinition 解析 - 内部 API 实现</li><li>BeanDefinition 处理 - <code>AnnotationConfigUtils.processCommonDefinitionAnnotations</code></li><li>BeanDefinition 注册 - <code>BeanDefinitionRegistry</code></li></ul></li></ul></li></ul></li></ul><p><code>Properties</code> 资源加载默认编码是 <code>ISO-8859-1</code></p><p><code>AnnotatedBeanDefinitionReader</code> 使用 <code>ConditionEvaluator</code> 判断 Bean 的元信息，如果其中存在 <code>@Conditional</code> 条件，判断此条件通过才会将 Bean 加入容器</p><h3 id="基于-XML-资源装载-Spring-IoC-容器配置元信息"><a href="#基于-XML-资源装载-Spring-IoC-容器配置元信息" class="headerlink" title="基于 XML 资源装载 Spring IoC 容器配置元信息"></a>基于 XML 资源装载 Spring IoC 容器配置元信息</h3><p>Spring IoC 容器相关 XML 配置</p><table><thead><tr><th>命名空间</th><th>所属模块</th><th>Schema 资源 URL</th></tr></thead><tbody><tr><td>beans</td><td>spring-beans</td><td><a href="https://www.springframework.org/schema/beans/spring-beans.xsd" target="_blank">https://www.springframework.org/schema/beans/spring-beans.xsd</a></td></tr><tr><td>context</td><td>spring-context</td><td><a href="https://www.springframework.org/schema/context/spring-context.xsd" target="_blank">https://www.springframework.org/schema/context/spring-context.xsd</a></td></tr><tr><td>aop</td><td>spring-aop</td><td><a href="https://www.springframework.org/schema/aop/spring-aop.xsd" target="_blank">https://www.springframework.org/schema/aop/spring-aop.xsd</a></td></tr><tr><td>tx</td><td>spring-tx</td><td><a href="https://www.springframework.org/schema/tx/spring-tx.xsd" target="_blank">https://www.springframework.org/schema/tx/spring-tx.xsd</a></td></tr><tr><td>util</td><td>spring-beans</td><td><a href="https://www.springframework.org/schema/util/spring-util.xsd" target="_blank">https://www.springframework.org/schema/util/spring-util.xsd</a></td></tr><tr><td>tool</td><td>spring-beans</td><td><a href="https://www.springframework.org/schema/tool/spring-tool.xsd" target="_blank">https://www.springframework.org/schema/tool/spring-tool.xsd</a></td></tr></tbody></table><h3 id="基于-Java-注解装载-Spring-IoC-容器配置元信息"><a href="#基于-Java-注解装载-Spring-IoC-容器配置元信息" class="headerlink" title="基于 Java 注解装载 Spring IoC 容器配置元信息"></a>基于 Java 注解装载 Spring IoC 容器配置元信息</h3><p>Spring IoC 容器装配注解</p><table><thead><tr><th>Spring 注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td>@ImportResource</td><td>替换 XML 元素 <code>&lt;import&gt;</code></td><td>3.0</td></tr><tr><td>@Import</td><td>导入 Configuration Class</td><td>3.0</td></tr><tr><td>@ComponentScan</td><td>扫描指定 package 下标注 Spring 模式注解的类</td><td>3.1</td></tr></tbody></table><p>Spring IoC 配属属性注</p><table><thead><tr><th>Spring 注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td>@PropertySource</td><td>配置属性抽象 PropertySource 注解</td><td>3.1</td></tr><tr><td>@PropertySources</td><td>@PropertySource 集合注解</td><td>4.0</td></tr></tbody></table><h3 id="基于-Extensible-XML-authoring-扩展-Spring-XML-元素"><a href="#基于-Extensible-XML-authoring-扩展-Spring-XML-元素" class="headerlink" title="基于 Extensible XML authoring 扩展 Spring XML 元素"></a>基于 Extensible XML authoring 扩展 Spring XML 元素</h3><p>Spring XML 扩展</p><ul><li>编写 XML Schema 文件：定义 XML 结构<ul><li>users.xsd</li></ul></li><li>自定义 <code>NamespaceHandler</code> 实现：命名空间绑定<ul><li>spring.handlers</li><li><code>org.geekbang.thinking.in.spring.configuration.metadata.UsersNamespaceHandler</code></li></ul></li><li>自定义 <code>BeanDefinitionParser</code> 实现：XML 元素与 <code>BeanDefinition</code> 解析<ul><li><code>org.geekbang.thinking.in.spring.configuration.metadata.UserBeanDefinitionParser</code></li></ul></li><li>注册 XML 扩展：命名空间与 XML Schema 映射<ul><li>spring.schemas</li><li>users-context.xml</li></ul></li></ul><p>触发时机：<code>BeanDefinitionParserDelegate#parseCustomElement</code></p><ul><li>获取 namespace</li><li>通过 namespace 解析 <code>NamespaceHandler</code></li><li>构造 <code>ParserContext</code></li><li>解析元素，获取 <code>BeanDefinintion</code></li></ul><h3 id="基于-Properties-资源装载外部化配置"><a href="#基于-Properties-资源装载外部化配置" class="headerlink" title="基于 Properties 资源装载外部化配置"></a>基于 Properties 资源装载外部化配置</h3><ul><li>注解驱动<ul><li><code>@org.springframework.context.annotation.PropertySource</code></li><li><code>@org.springframework.context.annotation.PropertySources</code></li></ul></li><li>API 编程<ul><li><code>org.springframework.core.env.PropertySource</code></li><li><code>org.springframework.core.env.PropertySources</code></li></ul></li></ul><h3 id="基于-YAML-资源装载外部化配置"><a href="#基于-YAML-资源装载外部化配置" class="headerlink" title="基于 YAML 资源装载外部化配置"></a>基于 YAML 资源装载外部化配置</h3><p>API 编程</p><ul><li><code>org.springframework.beans.factory.config.YamlProcessor</code><ul><li><code>org.springframework.beans.factory.config.YamlMapFactoryBean</code></li><li><code>org.springframework.beans.factory.config.YamlPropertiesFactoryBean</code></li></ul></li></ul><p>Requires SnakeYAML 1.18 or higher, as of Spring Framework 5.0.6</p><h4 id="通过-PropertySourceFactory-接口，引入-PropertySource"><a href="#通过-PropertySourceFactory-接口，引入-PropertySource" class="headerlink" title="通过 PropertySourceFactory 接口，引入 PropertySource"></a>通过 PropertySourceFactory 接口，引入 PropertySource</h4><p><code>org.springframework.core.io.support.PropertySourceFactory</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@PropertySource</span>(<br>        name = <span class="hljs-string">&quot;yamlPropertySource&quot;</span>,<br>        value = <span class="hljs-string">&quot;classpath:/META-INF/user.yaml&quot;</span>,<br>        <span class="hljs-keyword">factory</span> = YamlPropertySourceFactory.<span class="hljs-keyword">class</span>)<br></code></pre></td></tr></table></figure><h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><h4 id="Spring-內建-XML-Schema-常见有哪些？"><a href="#Spring-內建-XML-Schema-常见有哪些？" class="headerlink" title="Spring 內建 XML Schema 常见有哪些？"></a>Spring 內建 XML Schema 常见有哪些？</h4><table><thead><tr><th>命名空间</th><th>所属模块</th><th>Schema 资源 URL</th></tr></thead><tbody><tr><td>beans</td><td>spring-beans</td><td><a href="https://www.springframework.org/schema/beans/spring-beans.xsd" target="_blank">https://www.springframework.org/schema/beans/spring-beans.xsd</a></td></tr><tr><td>context</td><td>spring-context</td><td><a href="https://www.springframework.org/schema/context/spring-context.xsd" target="_blank">https://www.springframework.org/schema/context/spring-context.xsd</a></td></tr><tr><td>aop</td><td>spring-aop</td><td><a href="https://www.springframework.org/schema/aop/spring-aop.xsd" target="_blank">https://www.springframework.org/schema/aop/spring-aop.xsd</a></td></tr><tr><td>tx</td><td>spring-tx</td><td><a href="https://www.springframework.org/schema/tx/spring-tx.xsd" target="_blank">https://www.springframework.org/schema/tx/spring-tx.xsd</a></td></tr><tr><td>util</td><td>spring-beans</td><td><a href="https://www.springframework.org/schema/util/spring-util.xsd" target="_blank">https://www.springframework.org/schema/util/spring-util.xsd</a></td></tr><tr><td>tool</td><td>spring-beans</td><td><a href="https://www.springframework.org/schema/tool/spring-tool.xsd" target="_blank">https://www.springframework.org/schema/tool/spring-tool.xsd</a></td></tr></tbody></table><h4 id="Spring-配置元信息具体有哪些？"><a href="#Spring-配置元信息具体有哪些？" class="headerlink" title="Spring 配置元信息具体有哪些？"></a>Spring 配置元信息具体有哪些？</h4><ul><li>Bean 配置元信息：通过媒介（如 XML、Proeprties 等），解析 BeanDefinition</li><li>IoC 容器配置元信息：通过媒介（如 XML、Proeprties 等），控制 IoC 容器行为，比如注解驱动、AOP 等</li><li>外部化配置：通过资源抽象（如 Proeprties、YAML 等），控制 PropertySource</li><li>Spring Profile：通过外部化配置，提供条件分支流程</li></ul><h4 id="Extensible-XML-authoring-的缺点？"><a href="#Extensible-XML-authoring-的缺点？" class="headerlink" title="Extensible XML authoring 的缺点？"></a>Extensible XML authoring 的缺点？</h4><ul><li>高复杂度：开发人员需要熟悉 XML Schema，spring.handlers，spring.schemas 以及 Spring API 。</li><li>嵌套元素支持较弱：通常需要使用方法递归或者其嵌套解析的方式处理嵌套（子）元素。</li><li>XML 处理性能较差：Spring XML 基于 DOM Level 3 API 实现，该 API 便于理解，然而性能较差。</li><li>XML 框架移植性差：很难适配高性能和便利性的 XML 框架，如 JAXB。</li></ul><h2 id="第十一章：Spring-资源管理"><a href="#第十一章：Spring-资源管理" class="headerlink" title="第十一章：Spring 资源管理"></a>第十一章：Spring 资源管理</h2><h3 id="引入动机"><a href="#引入动机" class="headerlink" title="引入动机"></a>引入动机</h3><p>为什么 Spring 不使用 Java 标准资源管理，而选择重新发明轮子？</p><ul><li>Java 标准资源管理强大，然而扩展复杂，资源存储方式并不统一</li><li>Spring 要自立门户（重要的话，要讲三遍）</li><li>Spring “抄”、“超” 和 “潮”</li></ul><h3 id="Java-标准资源管理"><a href="#Java-标准资源管理" class="headerlink" title="Java 标准资源管理"></a>Java 标准资源管理</h3><h4 id="Java-标准资源定位"><a href="#Java-标准资源定位" class="headerlink" title="Java 标准资源定位"></a>Java 标准资源定位</h4><table><thead><tr><th>职责</th><th>说明</th></tr></thead><tbody><tr><td>面向资源</td><td>文件系统、artifact（jar、war、ear 文件）以及远程资源（HTTP、FTP 等）</td></tr><tr><td>API 整合</td><td>java.lang.ClassLoader#getResource、java.io.File 或 java.net.URL</td></tr><tr><td>资源定位</td><td>java.net.URL 或 java.net.URI</td></tr><tr><td>面向流式存储</td><td>java.net.URLConnection</td></tr><tr><td>协议扩展</td><td>java.net.URLStreamHandler 或 java.net.URLStreamHandlerFactory</td></tr></tbody></table><h4 id="Java-URL-协议扩展"><a href="#Java-URL-协议扩展" class="headerlink" title="Java URL 协议扩展"></a>Java URL 协议扩展</h4><ul><li>基于 <code>java.net.URLStreamHandlerFactory</code></li><li>基于 <code>java.net.URLStreamHandler</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/F7gVJwfHGQ8ZWo6.png" alt=""></p><h4 id="基于-java-net-URLStreamHandler-扩展协议"><a href="#基于-java-net-URLStreamHandler-扩展协议" class="headerlink" title="基于 java.net.URLStreamHandler 扩展协议"></a>基于 java.net.URLStreamHandler 扩展协议</h4><p>JDK 1.8 內建协议实现</p><table><thead><tr><th>协议</th><th>实现类</th></tr></thead><tbody><tr><td>file</td><td><code>sun.net.www.protocol.file.Handler</code></td></tr><tr><td>ftp</td><td><code>sun.net.www.protocol.ftp.Handler</code></td></tr><tr><td>http</td><td><code>sun.net.www.protocol.http.Handler</code></td></tr><tr><td>https</td><td><code>sun.net.www.protocol.https.Handler</code></td></tr><tr><td>jar</td><td><code>sun.net.www.protocol.jar.Handler</code></td></tr><tr><td>mailto</td><td><code>sun.net.www.protocol.mailto.Handler</code></td></tr><tr><td>netdoc</td><td><code>sun.net.www.protocol.netdoc.Handler</code></td></tr></tbody></table><p>实现类名必须为 <code>Handler</code></p><table><thead><tr><th>实现类命名规则</th><th>说明</th></tr></thead><tbody><tr><td>默认</td><td><code>sun.net.www.protocol.$&#123;protocol&#125;.Handler</code></td></tr><tr><td>自定义</td><td>通过 Java Properties <code>java.protocol.handler.pkgs</code> 指定实现类包名，实现类名必须为 <code>Handler</code>。如果存在多包名指定，通过分隔符 <code>|</code></td></tr></tbody></table><h3 id="Spring-资源接口"><a href="#Spring-资源接口" class="headerlink" title="Spring 资源接口"></a>Spring 资源接口</h3><table><thead><tr><th>类型</th><th>接口</th></tr></thead><tbody><tr><td>输入流</td><td><code>org.springframework.core.io.InputStreamSource</code></td></tr><tr><td>只读资源</td><td><code>org.springframework.core.io.Resource</code></td></tr><tr><td>可写资源</td><td><code>org.springframework.core.io.WritableResource</code></td></tr><tr><td>编码资源</td><td><code>org.springframework.core.io.support.EncodedResource</code></td></tr><tr><td>上下文资源</td><td><code>org.springframework.core.io.ContextResource</code></td></tr></tbody></table><h3 id="Spring-内建-Resource-实现"><a href="#Spring-内建-Resource-实现" class="headerlink" title="Spring 内建 Resource 实现"></a>Spring 内建 Resource 实现</h3><table><thead><tr><th>资源来源</th><th>资源协议</th><th>实现类</th></tr></thead><tbody><tr><td>Bean 定义</td><td>无</td><td><code>org.springframework.beans.factory.support.BeanDefinitionResource</code></td></tr><tr><td>数组</td><td>无</td><td><code>org.springframework.core.io.ByteArrayResource</code></td></tr><tr><td>类路径</td><td><code>classpath:/</code></td><td><code>org.springframework.core.io.ClassPathResource</code></td></tr><tr><td>文件系统</td><td><code>file:/</code></td><td><code>org.springframework.core.io.FileSystemResource</code></td></tr><tr><td>URL</td><td>URL 支持的协议</td><td><code>org.springframework.core.io.UrlResource</code></td></tr><tr><td>ServletContext</td><td>无</td><td><code>org.springframework.web.context.support.ServletContextResource</code></td></tr></tbody></table><h3 id="Spring-Resource-接口扩展"><a href="#Spring-Resource-接口扩展" class="headerlink" title="Spring Resource 接口扩展"></a>Spring Resource 接口扩展</h3><ul><li>可写资源接口<ul><li><code>org.springframework.core.io.WritableResource</code><ul><li><code>org.springframework.core.io.FileSystemResource</code></li><li><code>org.springframework.core.io.FileUrlResource</code>（@since 5.0.2）</li><li><code>org.springframework.core.io.PathResource</code>（@since 4.0 &amp; @Deprecated）</li></ul></li></ul></li><li>编码资源接口<ul><li><code>org.springframework.core.io.support.EncodedResource</code></li></ul></li></ul><h3 id="Spring-资源加载器"><a href="#Spring-资源加载器" class="headerlink" title="Spring 资源加载器"></a>Spring 资源加载器</h3><p>Resource 加载器</p><ul><li><code>org.springframework.core.io.ResourceLoader</code><ul><li><code>org.springframework.core.io.DefaultResourceLoader</code><ul><li><code>org.springframework.core.io.FileSystemResourceLoader</code></li><li><code>org.springframework.core.io.ClassRelativeResourceLoader</code></li><li><code>org.springframework.context.support.AbstractApplicationContext</code></li></ul></li></ul></li></ul><h3 id="Spring-通配路径资源加载器"><a href="#Spring-通配路径资源加载器" class="headerlink" title="Spring 通配路径资源加载器"></a>Spring 通配路径资源加载器</h3><ul><li>通配路径 ResourceLoader<ul><li><code>org.springframework.core.io.support.ResourcePatternResolver</code></li><li><code>org.springframework.core.io.support.PathMatchingResourcePatternResolver</code></li></ul></li><li>路径匹配器<ul><li><code>org.springframework.util.PathMatcher</code><ul><li>Ant 模式匹配实现 - <code>org.springframework.util.AntPathMatcher</code></li></ul></li></ul></li></ul><h3 id="Spring-通配路径资源扩展"><a href="#Spring-通配路径资源扩展" class="headerlink" title="Spring 通配路径资源扩展"></a>Spring 通配路径资源扩展</h3><ol><li>实现 <code>org.springframework.util.PathMatcher</code></li><li>重置 PathMatcher<ul><li><code>PathMatchingResourcePatternResolver#setPathMatcher</code></li></ul></li></ol><h3 id="依赖注入-Spring-Resource"><a href="#依赖注入-Spring-Resource" class="headerlink" title="依赖注入 Spring Resource"></a>依赖注入 Spring Resource</h3><p>基于 <code>@Value</code> 实现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Value(<span class="hljs-meta-string">&quot;classpath:/...&quot;</span>)</span> <br><span class="hljs-keyword">private</span> Resource resource;<br><br><span class="hljs-meta">@Value(<span class="hljs-meta-string">&quot;classpath*:/META-INF/*.properties&quot;</span>)</span><br><span class="hljs-keyword">private</span> Resource[] propertiesResources;<br></code></pre></td></tr></table></figure><h3 id="依赖注入-ResourceLoader"><a href="#依赖注入-ResourceLoader" class="headerlink" title="依赖注入 ResourceLoader"></a>依赖注入 ResourceLoader</h3><ul><li>方法一：实现 <code>ResourceLoaderAware</code> 回调</li><li>方法二：<code>@Autowired</code> 注入 <code>ResourceLoader</code></li><li>方法三：注入 <code>ApplicationContext</code> 作为 <code>ResourceLoader</code></li></ul><p><code>ApplicationContext</code> 接口继承 <code>ResourcePatternResolver</code> 继承 <code>ResourceLoader</code></p><p><code>ResourceLoaderAware</code> 回调在 实例初始化（<code>@PostConstruct</code> 等）之前</p><h3 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h3><h4 id="Spring-配置资源中有哪些常见类型？"><a href="#Spring-配置资源中有哪些常见类型？" class="headerlink" title="Spring 配置资源中有哪些常见类型？"></a>Spring 配置资源中有哪些常见类型？</h4><ul><li>XML 资源</li><li>Properties 资源</li><li>YAML 资源</li></ul><h4 id="请例举不同类型-Spring-配置资源？"><a href="#请例举不同类型-Spring-配置资源？" class="headerlink" title="请例举不同类型 Spring 配置资源？"></a>请例举不同类型 Spring 配置资源？</h4><ul><li>XML 资源<ul><li>普通 Bean Definition XML 配置资源 - <code>*.xml</code></li><li>Spring Schema 资源 - <code>*.xsd</code></li></ul></li><li>Properties 资源<ul><li>普通 Properties 格式资源 - <code>*.properties</code></li><li>Spring Handler 实现类映射文件 - <code>META-INF/spring.handlers</code></li><li>Spring Schema 资源映射文件 - <code>META-INF/spring.schemas</code></li></ul></li><li>YAML 资源<ul><li>普通 YAML 配置资源 - <code>*.yaml</code> 或 <code>*.yml</code></li></ul></li></ul><h4 id="Java-标准资源管理扩展的步骤？"><a href="#Java-标准资源管理扩展的步骤？" class="headerlink" title="Java 标准资源管理扩展的步骤？"></a>Java 标准资源管理扩展的步骤？</h4><ul><li>简易实现<ul><li>实现 <code>URLStreamHandler</code> 并放置在 <code>sun.net.www.protocol.$&#123;protocol&#125;.Handler</code> 包下</li></ul></li><li>自定义实现<ul><li>实现 <code>URLStreamHandler</code></li><li>添加 <code>-Djava.protocol.handler.pkgs</code> 启动参数，指向 <code>URLStreamHandler</code> 实现类的包下</li></ul></li><li>高级实现<ul><li>实现 <code>URLStreamHandlerFactory</code> 并传递到 URL 之中</li></ul></li></ul><h5 id="简易实现实例"><a href="#简易实现实例" class="headerlink" title="简易实现实例"></a>简易实现实例</h5><ol><li><p>扩展 x 协议，新建类 <code>sun.net.www.protocol.x.Handler</code>，类名格式必须符合规范</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">URLStreamHandler</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">URLConnection</span> openConnection(<span class="hljs-type">URL</span> u) <span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">XURLConnection</span>(u);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>新建类 <code>XURLConnection</code> ，实现 <code>java.net.URLConnection</code></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XURLConnection</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">URLConnection</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ClassPathResource</span> resource;<br><br>    <span class="hljs-comment">// URL = x:///META-INF/default.properties</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">XURLConnection</span>(<span class="hljs-type">URL</span> url) &#123;<br>        <span class="hljs-keyword">super</span>(url);<br>        <span class="hljs-keyword">this</span>.resource = <span class="hljs-keyword">new</span> <span class="hljs-type">ClassPathResource</span>(url.getPath());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    public void connect() <span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span> &#123;<br><br>    &#125;<br><br>    public <span class="hljs-type">InputStream</span> getInputStream() <span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span> &#123;<br>        <span class="hljs-keyword">return</span> resource.getInputStream();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试使用</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> HandlerTest &#123;<br><br>    public static void main(String<span class="hljs-literal">[]</span> args) throws IOException &#123;<br>        URL url = <span class="hljs-keyword">new</span> <span class="hljs-constructor">URL(<span class="hljs-string">&quot;x:///META-INF/default.properties&quot;</span>)</span>; <span class="hljs-comment">// 类似于 classpath:/META-INF/default.properties</span><br>        InputStream inputStream = url.<span class="hljs-keyword">open</span><span class="hljs-constructor">Stream()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StreamUtils</span>.</span></span>copy<span class="hljs-constructor">ToString(<span class="hljs-params">inputStream</span>, Charset.<span class="hljs-params">forName</span>(<span class="hljs-string">&quot;UTF-8&quot;</span>)</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h5><ol><li><p>新建类 <code>Handler</code>，继承 <code>sun.net.www.protocol.x.Handle</code>，类名必须为 <code>Handler</code>，包名无限制</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">sun</span>.<span class="hljs-title">net</span>.<span class="hljs-title">www</span>.<span class="hljs-title">protocol</span>.<span class="hljs-title">x</span>.<span class="hljs-title">Handler</span> </span>&#123;<br><br>    <span class="hljs-comment">// -Djava.protocol.handler.pkgs=org.geekbang.thinking.in.spring.resource</span><br>    public static void main(<span class="hljs-type">String</span>[] args) <span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span> &#123;<br>        <span class="hljs-comment">// springx 协议</span><br>        <span class="hljs-type">URL</span> url = <span class="hljs-keyword">new</span> <span class="hljs-type">URL</span>(<span class="hljs-string">&quot;springx:///META-INF/production.properties&quot;</span>); <span class="hljs-comment">// 类似于 classpath:/META-INF/default.properties</span><br>        <span class="hljs-type">InputStream</span> inputStream = url.openStream();<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-type">StreamUtils</span>.copyToString(inputStream, <span class="hljs-type">Charset</span>.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>运行时增加 VM 参数，<code>-Djava.protocol.handler.pkgs=org.geekbang.thinking.in.spring.resource</code></p></li></ol><h5 id="高级实现"><a href="#高级实现" class="headerlink" title="高级实现"></a>高级实现</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> MyURLStreamHandlerFactory implements URLStreamHandlerFactory &#123;<br>    @Override<br>    public URLStreamHandler create<span class="hljs-constructor">URLStreamHandler(String <span class="hljs-params">protocol</span>)</span> &#123;<br>        return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Handler()</span>;<br>    &#125;<br><br>    public static void main(String<span class="hljs-literal">[]</span> args) throws IOException &#123;<br>        <span class="hljs-comment">// URL 设置 URLStreamHandlerFactory，必须在创建 URL 实例之前</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">URL</span>.</span></span>set<span class="hljs-constructor">URLStreamHandlerFactory(<span class="hljs-params">new</span> MyURLStreamHandlerFactory()</span>);<br>        <span class="hljs-comment">// springx 协议</span><br>        URL url = <span class="hljs-keyword">new</span> <span class="hljs-constructor">URL(<span class="hljs-string">&quot;springx:///META-INF/production.properties&quot;</span>)</span>; <span class="hljs-comment">// 类似于 classpath:/META-INF/default.properties</span><br>        <br>        InputStream inputStream = url.<span class="hljs-keyword">open</span><span class="hljs-constructor">Stream()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StreamUtils</span>.</span></span>copy<span class="hljs-constructor">ToString(<span class="hljs-params">inputStream</span>, Charset.<span class="hljs-params">forName</span>(<span class="hljs-string">&quot;UTF-8&quot;</span>)</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://www.cnblogs.com/huangwenjie/p/13946003.html">www.cnblogs.com</a></p></blockquote><h2 id="第十二章：Spring-国际化"><a href="#第十二章：Spring-国际化" class="headerlink" title="第十二章：Spring 国际化"></a>第十二章：Spring 国际化</h2><h3 id="Spring-国际化使用场景"><a href="#Spring-国际化使用场景" class="headerlink" title="Spring 国际化使用场景"></a>Spring 国际化使用场景</h3><ul><li>普通国际化文案</li><li>Bean Validation 校验国际化文案</li><li>Web 站点页面渲染</li><li>Web MVC 错误消息提示</li></ul><h3 id="Spring-国际化接口"><a href="#Spring-国际化接口" class="headerlink" title="Spring 国际化接口"></a>Spring 国际化接口</h3><ul><li>核心接口 - <code>org.springframework.context.MessageSource</code></li><li>主要概念<ul><li>文案模板编码（code）</li><li>文案模板参数（args）</li><li>区域（Locale）</li></ul></li></ul><h3 id="层次性-MessageSource"><a href="#层次性-MessageSource" class="headerlink" title="层次性 MessageSource"></a>层次性 MessageSource</h3><ul><li>Spring 层次性接口回顾<ul><li><code>org.springframework.beans.factory.HierarchicalBeanFactory</code></li><li><code>org.springframework.context.ApplicationContext</code></li><li><code>org.springframework.beans.factory.config.BeanDefinition</code></li></ul></li><li>Spring 层次性国际化接口<ul><li><code>org.springframework.context.HierarchicalMessageSource</code></li></ul></li></ul><h3 id="Java-国际化标准实现"><a href="#Java-国际化标准实现" class="headerlink" title="Java 国际化标准实现"></a>Java 国际化标准实现</h3><p>核心接口</p><ul><li>抽象类实现 - <code>java.util.ResourceBundle</code><ul><li>Properties 资源实现 - <code>java.util.PropertyResourceBundle</code></li><li>例举实现 - <code>java.util.ListResourceBundle</code></li></ul></li></ul><p><code>ResourceBundle</code> 核心特性</p><ul><li>Key-Value 设计<ul><li>键唯一地标识了包中特定于语言环境的对象</li><li>value 就是 文案模板编码（code）</li></ul></li><li>层次性设计</li><li>缓存设计</li><li>字符编码控制 - <code>java.util.ResourceBundle.Control</code>（@since 1.6）</li><li>Control SPI 扩展 - <code>java.util.spi.ResourceBundleControlProvider</code>（@since 1.8）</li></ul><h3 id="Java-文本格式化"><a href="#Java-文本格式化" class="headerlink" title="Java 文本格式化"></a>Java 文本格式化</h3><p>核心接口 - <code>java.text.MessageFormat</code></p><ul><li>基本用法<ul><li>设置消息格式模式 - <code>new MessageFormat(...)</code></li><li>格式化 - <code>format(new Object[]&#123;...&#125;)</code></li></ul></li><li>消息格式模式<ul><li>格式元素：<code>&#123;ArgumentIndex (,FormatType,(FormatStyle))&#125;</code></li><li><code>FormatType</code>：消息格式类型，可选项，每种类型在 <code>number</code>、<code>date</code>、<code>time</code> 和 <code>choice</code> 类型选其一</li><li><code>FormatStyle</code>：消息格式风格，可选项，包括：<code>short</code>、<code>medium</code>、<code>long</code>、<code>full</code>、<code>integer</code>、<code>currency</code>、<code>percent</code></li></ul></li></ul><p>高级特性</p><ul><li>重置消息格式模式</li><li>重置 <code>java.util.Locale</code></li><li>重置 <code>java.text.Format</code></li></ul><h3 id="MessageSource-开箱即用实现"><a href="#MessageSource-开箱即用实现" class="headerlink" title="MessageSource 开箱即用实现"></a>MessageSource 开箱即用实现</h3><ul><li>基于 <code>ResourceBundle</code> + <code>MessageFormat</code> 组合 <code>MessageSource</code> 实现<ul><li><code>org.springframework.context.support.ResourceBundleMessageSource</code></li></ul></li><li>可重载 <code>Properties</code> + <code>MessageFormat</code> 组合 <code>MessageSource</code> 实现<ul><li><code>org.springframework.context.support.ReloadableResourceBundleMessageSource</code></li></ul></li></ul><h3 id="MessageSource-內建依赖"><a href="#MessageSource-內建依赖" class="headerlink" title="MessageSource 內建依赖"></a>MessageSource 內建依赖</h3><p><code>MessageSource</code> 內建 Bean 可能来源</p><ul><li>预注册 Bean 名称为：<code>messageSource</code>，类型为：<code>MessageSource</code></li><li>默认內建实现 - <code>DelegatingMessageSource</code><ul><li>层次性查找 <code>MessageSource</code> 对象</li></ul></li></ul><h3 id="课外资料"><a href="#课外资料" class="headerlink" title="课外资料"></a>课外资料</h3><p>Spring Boot 为什么要新建 MessageSource Bean？</p><ul><li><code>AbstractApplicationContext</code> 的实现决定了 <code>MessageSource</code> 內建实现</li><li>Spring Boot 通过外部化配置简化 <code>MessageSource</code> Bean 构建</li><li>Spring Boot 基于 Bean Validation 校验非常普遍</li></ul><p>SpringBoot 中关于 <code>MessageSource</code> 的自动配置类</p><ul><li><code>org.springframework.context.support.ResourceBundleMessageSource</code></li></ul><h3 id="面试题-3"><a href="#面试题-3" class="headerlink" title="面试题"></a>面试题</h3><h4 id="Spring-国际化接口有哪些？"><a href="#Spring-国际化接口有哪些？" class="headerlink" title="Spring 国际化接口有哪些？"></a>Spring 国际化接口有哪些？</h4><ul><li>核心接口 - <code>MessageSource</code></li><li>层次性接口 - <code>org.springframework.context.HierarchicalMessageSource</code></li></ul><h4 id="Spring-有哪些-MessageSource-內建实现？"><a href="#Spring-有哪些-MessageSource-內建实现？" class="headerlink" title="Spring 有哪些 MessageSource 內建实现？"></a>Spring 有哪些 MessageSource 內建实现？</h4><ul><li><code>org.springframework.context.support.ResourceBundleMessageSource</code></li><li><code>org.springframework.context.support.ReloadableResourceBundleMessageSource</code></li><li><code>org.springframework.context.support.StaticMessageSource</code></li><li><code>org.springframework.context.support.DelegatingMessageSource</code></li></ul><h4 id="如何实现配置自动更新-MessageSource？"><a href="#如何实现配置自动更新-MessageSource？" class="headerlink" title="如何实现配置自动更新 MessageSource？"></a>如何实现配置自动更新 MessageSource？</h4><p>主要技术</p><ul><li>Java NIO 2：<code>java.nio.file.WatchService</code></li><li>Java Concurrency : <code>java.util.concurrent.ExecutorService</code></li><li>Spring：<code>org.springframework.context.support.AbstractMessageSource</code></li></ul><h2 id="第十三章：Spring-校验"><a href="#第十三章：Spring-校验" class="headerlink" title="第十三章：Spring 校验"></a>第十三章：Spring 校验</h2><h3 id="Spring-校验使用场景"><a href="#Spring-校验使用场景" class="headerlink" title="Spring 校验使用场景"></a>Spring 校验使用场景</h3><ul><li>Spring 常规校验（Validator）</li><li>Spring 数据绑定（DataBinder）</li><li>Spring Web 参数绑定（WebDataBinder）</li><li>Spring Web MVC / Spring WebFlux 处理方法参数校验</li></ul><h3 id="Validator-接口设计"><a href="#Validator-接口设计" class="headerlink" title="Validator 接口设计"></a>Validator 接口设计</h3><ul><li><p><code>org.springframework.validation.Validator</code></p></li><li><p>接口职责</p><ul><li>Spring 内部校验器接口，通过编程的方式校验目标对象</li></ul></li><li><p>核心方法</p><ul><li><code>supports(Class)</code>：校验目标类能否校验</li><li><code>validate(Object,Errors)</code>：校验目标对象，并将校验失败的内容输出至 <code>Errors</code> 对象</li></ul></li><li><p>配套组件</p><ul><li>错误收集器：<code>org.springframework.validation.Errors</code></li><li>Validator 工具类：<code>org.springframework.validation.ValidationUtils</code></li></ul></li></ul><h3 id="Errors-接口设计"><a href="#Errors-接口设计" class="headerlink" title="Errors 接口设计"></a>Errors 接口设计</h3><ul><li><code>org.springframework.validation.Errors</code></li><li>接口职责<ul><li>数据绑定和校验错误收集接口，与 Java Bean 和其属性有强关联性</li></ul></li><li>核心方法<ul><li><code>reject</code> 方法（重载）：收集错误文案</li><li><code>rejectValue</code> 方法（重载）：收集对象字段中的错误文案</li></ul></li><li>配套组件<ul><li>Java Bean 错误描述：<code>org.springframework.validation.ObjectError</code></li><li>Java Bean 属性错误描述：<code>org.springframework.validation.FieldError</code></li></ul></li></ul><h3 id="Errors-文案来源"><a href="#Errors-文案来源" class="headerlink" title="Errors 文案来源"></a>Errors 文案来源</h3><p><code>Errors</code> 文案生成步骤</p><ul><li>选择 <code>Errors</code> 实现（如：<code>org.springframework.validation.BeanPropertyBindingResult</code>）</li><li>调用 <code>reject</code> 或 <code>rejectValue</code> 方法</li><li>获取 <code>Errors</code> 对象中 <code>ObjectError</code> 或 <code>FieldError</code></li><li>将 <code>ObjectError</code> 或 <code>FieldError</code> 中的 <code>code</code> 和 <code>args</code>，关联 <code>MessageSource</code> 实现（如：<code>ResourceBundleMessageSource</code>）</li></ul><p><code>Errors</code> 不能直接生成文案，但是可以提供国际化接口 <code>MessageSource</code> 所需要的 <code>code</code> 和 <code>args</code></p><h3 id="自定义-Validator"><a href="#自定义-Validator" class="headerlink" title="自定义 Validator"></a>自定义 Validator</h3><p>实现 <code>org.springframework.validation.Validator</code> 接口</p><ul><li>实现 <code>supports</code> 方法</li><li>实现 <code>validate</code> 方法<ul><li>通过 <code>Errors</code> 对象收集错误<ul><li><code>ObjectError</code>：对象（Bean）错误：</li><li><code>FieldError</code>：对象（Bean）属性（Property）错误</li></ul></li><li>通过 <code>ObjectError</code> 和 <code>FieldError</code> 关联 <code>MessageSource</code> 实现获取最终文案</li></ul></li></ul><h3 id="Validator-的救赎"><a href="#Validator-的救赎" class="headerlink" title="Validator 的救赎"></a>Validator 的救赎</h3><p>Bean Validation 与 Validator 适配</p><ul><li>核心组件 - <code>org.springframework.validation.beanvalidation.LocalValidatorFactoryBean</code></li><li>依赖 Bean Validation - JSR-303 or JSR-349 provider</li><li>Bean 方法参数校验 - <code>org.springframework.validation.beanvalidation.MethodValidationPostProcessor</code></li></ul><p>关联注解：</p><ul><li><code>org.springframework.validation.annotation.Validated</code></li><li><code>javax.validation.Valid</code></li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> SpringBeanValidationDemo &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        // 配置 <span class="hljs-type">XML</span> 配置文件<br>        // 启动 Spring 应用上下文<br>        ConfigurableApplicationContext applicationContext = <span class="hljs-built_in">new</span> ClassPathXmlApplicationContext(&quot;classpath:/META-INF/bean-validation-context.xml&quot;);<br><br>//        <span class="hljs-keyword">Validator</span> <span class="hljs-keyword">validator</span> = applicationContext.getBean(<span class="hljs-keyword">Validator</span>.<span class="hljs-keyword">class</span>);<br>//        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">validator</span> instanceof LocalValidatorFactoryBean);<br><br>        UserProcessor userProcessor = applicationContext.getBean(UserProcessor.<span class="hljs-keyword">class</span>);<br>        userProcessor.process(<span class="hljs-built_in">new</span> <span class="hljs-keyword">User</span>());<br><br>        // 关闭应用上下文<br>        applicationContext.<span class="hljs-keyword">close</span>();<br>    &#125;<br><br>    @Component<br>    @Validated<br>    static <span class="hljs-keyword">class</span> UserProcessor &#123;<br><br>        <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> process(@<span class="hljs-keyword">Valid</span> <span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span>) &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">user</span>);<br>        &#125;<br><br>    &#125;<br><br>    static <span class="hljs-keyword">class</span> <span class="hljs-keyword">User</span> &#123;<br><br>        @<span class="hljs-keyword">NotNull</span><br>        private String <span class="hljs-type">name</span>;<br><br>        <span class="hljs-built_in">public</span> String getName() &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">name</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> setName(String <span class="hljs-type">name</span>) &#123;<br>            this.name = <span class="hljs-type">name</span>;<br>        &#125;<br><br>        @Override<br>        <span class="hljs-built_in">public</span> String toString() &#123;<br>            <span class="hljs-keyword">return</span> &quot;User&#123;&quot; +<br>                    &quot; + name + &#x27;\&#x27;&#x27; +<br>                    &#x27;&#125;&#x27;;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.geekbang.thinking.in.spring.validation&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;validator&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;</span>/&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.validation.beanvalidation.MethodValidationPostProcessor&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="面试题-4"><a href="#面试题-4" class="headerlink" title="面试题"></a>面试题</h3><h4 id="Spring-校验接口是哪个？"><a href="#Spring-校验接口是哪个？" class="headerlink" title="Spring 校验接口是哪个？"></a>Spring 校验接口是哪个？</h4><p><code>org.springframework.validation.Validator</code></p><h4 id="Spring-有哪些校验核心组件？"><a href="#Spring-有哪些校验核心组件？" class="headerlink" title="Spring 有哪些校验核心组件？"></a>Spring 有哪些校验核心组件？</h4><ul><li>检验器：<code>org.springframework.validation.Validator</code></li><li>错误收集器：<code>org.springframework.validation.Errors</code></li><li>Java Bean 错误描述：<code>org.springframework.validation.ObjectError</code></li><li>Java Bean 属性错误描述：<code>org.springframework.validation.FieldError</code></li><li>Bean Validation 适配：<code>org.springframework.validation.beanvalidation.LocalValidatorFactoryBean</code></li></ul><h2 id="第十四章：Spring-数据绑定"><a href="#第十四章：Spring-数据绑定" class="headerlink" title="第十四章：Spring 数据绑定"></a>第十四章：Spring 数据绑定</h2><h3 id="Spring-数据绑定使用场景"><a href="#Spring-数据绑定使用场景" class="headerlink" title="Spring 数据绑定使用场景"></a>Spring 数据绑定使用场景</h3><ul><li>Spring BeanDefinition 到 Bean 实例创建</li><li>Spring 数据绑定（DataBinder）</li><li>Spring Web 参数绑定（WebDataBinder）</li></ul><h3 id="Spring-数据绑定组件"><a href="#Spring-数据绑定组件" class="headerlink" title="Spring 数据绑定组件"></a>Spring 数据绑定组件</h3><ul><li>标准组件<ul><li><code>org.springframework.validation.DataBinder</code></li></ul></li><li>Web 组件<ul><li><code>org.springframework.web.bind.WebDataBinder</code></li><li><code>org.springframework.web.bind.ServletRequestDataBinder</code></li><li><code>org.springframework.web.bind.support.WebRequestDataBinder</code></li><li><code>org.springframework.web.bind.support.WebExchangeDataBinder</code>（since 5.0）</li></ul></li></ul><h4 id="DataBinder-核心属性"><a href="#DataBinder-核心属性" class="headerlink" title="DataBinder 核心属性"></a>DataBinder 核心属性</h4><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>target</td><td>关联目标 Bean</td></tr><tr><td>objectName</td><td>目标 Bean 名称</td></tr><tr><td>bindingResult</td><td>属性绑定结果</td></tr><tr><td>typeConverter</td><td>类型转换器</td></tr><tr><td>conversionService</td><td>类型转换服务</td></tr><tr><td>messageCodesResolver</td><td>校验错误文案 Code 处理器</td></tr><tr><td>validators</td><td>关联的 Bean Validator 实例集合</td></tr></tbody></table><h4 id="DataBinder-绑定方法"><a href="#DataBinder-绑定方法" class="headerlink" title="DataBinder 绑定方法"></a>DataBinder 绑定方法</h4><ul><li><code>bind(PropertyValues)</code>：将 <code>PropertyValues</code> Key-Value 内容映射到关联 Bean（target）中的属性上</li><li>假设 <code>PropertyValues</code> 中包含 “name = 小马哥” 的键值对，同时 Bean 对象 User 中存在 name 属性，当 bind 方法执行时，User 对象中的 name 属性值将被绑定为 “小马哥”</li></ul><h3 id="Spring-数据绑定元数据"><a href="#Spring-数据绑定元数据" class="headerlink" title="Spring 数据绑定元数据"></a>Spring 数据绑定元数据</h3><p><code>DataBinder</code> 元数据 - <code>PropertyValues</code></p><table><thead><tr><th>特征</th><th>说明</th></tr></thead><tbody><tr><td>数据来源</td><td>BeanDefinition，主要来源 XML 资源配置 BeanDefinition</td></tr><tr><td>数据结构</td><td>由一个或多个 PropertyValue 组成</td></tr><tr><td>成员结构</td><td>PropertyValue 包含属性名称，以及属性值（包括原始值、类型转换后的值）</td></tr><tr><td>常见实现</td><td>MutablePropertyValues</td></tr><tr><td>Web 扩展实现</td><td>ServletConfigPropertyValues、ServletRequestParameterPropertyValues</td></tr><tr><td>相关生命周期</td><td>InstantiationAwareBeanPostProcessor#postProcessProperties</td></tr></tbody></table><h3 id="Spring-数据绑定控制参数"><a href="#Spring-数据绑定控制参数" class="headerlink" title="Spring 数据绑定控制参数"></a>Spring 数据绑定控制参数</h3><h4 id="DataBinder-绑定特殊场景分析"><a href="#DataBinder-绑定特殊场景分析" class="headerlink" title="DataBinder 绑定特殊场景分析"></a>DataBinder 绑定特殊场景分析</h4><ul><li>当 <code>PropertyValues</code> 中包含名称 x 的 <code>PropertyValue</code>，目标对象 B 不存在 x 属性，当 bind 方法执行时，会发生什么？<ul><li>默认忽略未知的属性，<code>ignoreUnknownFields</code></li></ul></li><li>当 <code>PropertyValues</code> 中包含名称 x 的 <code>PropertyValue</code>，目标对象 B 中存在 x 属性，当 bind 方法执行时，如何避免 B 属性 x 不被绑定？<ul><li>设置 <code>disallowedFields</code> 属性</li></ul></li><li>当 <code>PropertyValues</code> 中包含名称 x.y 的 <code>PropertyValue</code>，目标对象 B 中存在 x 属性（嵌套 y 属性），当 bind 方法执行时，会发生什么？<ul><li>默认支持嵌套属性，<code>autoGrowNestedPaths</code></li></ul></li></ul><h4 id="DataBinder-绑定控制参数"><a href="#DataBinder-绑定控制参数" class="headerlink" title="DataBinder 绑定控制参数"></a>DataBinder 绑定控制参数</h4><table><thead><tr><th>参数名称</th><th>说明</th></tr></thead><tbody><tr><td>ignoreUnknownFields</td><td>是否忽略未知字段，默认值：true</td></tr><tr><td>ignoreInvalidFields</td><td>是否忽略非法字段，默认值：false</td></tr><tr><td>autoGrowNestedPaths</td><td>是否自动增加嵌套路径，默认值：true</td></tr><tr><td>allowedFields</td><td>绑定字段白名单</td></tr><tr><td>disallowedFields</td><td>绑定字段黑名单</td></tr><tr><td>requiredFields</td><td>必须绑定字段</td></tr></tbody></table><h3 id="BeanWrapper-的使用场景"><a href="#BeanWrapper-的使用场景" class="headerlink" title="BeanWrapper 的使用场景"></a>BeanWrapper 的使用场景</h3><p>BeanWrapper</p><ul><li>Spring 底层 JavaBeans 基础设施的中心化接口</li><li>通常不会直接使用，间接用于 <code>BeanFactory</code> 和 <code>DataBinder</code></li><li>提供标准 JavaBeans 分析和操作，能够单独或批量存储 Java Bean 的属性（properties）</li><li>支持嵌套属性路径（nested path）</li><li>实现类 <code>org.springframework.beans.BeanWrapperImpl</code></li></ul><h3 id="Spring-底层-Java-Beans-替换实现"><a href="#Spring-底层-Java-Beans-替换实现" class="headerlink" title="Spring 底层 Java Beans 替换实现"></a>Spring 底层 Java Beans 替换实现</h3><ul><li>JavaBeans 核心实现 - <code>java.beans.BeanInfo</code><ul><li>属性（Property）<ul><li><code>java.beans.PropertyEditor</code></li></ul></li><li>方法（Method）</li><li>事件（Event）</li><li>表达式（Expression）</li></ul></li><li>Spring 替代实现 - <code>org.springframework.beans.BeanWrapper</code><ul><li>属性（Property）<ul><li><code>java.beans.PropertyEditor</code></li></ul></li><li>嵌套属性路径（nested path）</li></ul></li></ul><h3 id="课外资料-1"><a href="#课外资料-1" class="headerlink" title="课外资料"></a>课外资料</h3><p>标准 JavaBeans 是如何操作属性的？</p><table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>java.beans.Introspector</td><td>JavaBeans 内省 API</td></tr><tr><td>java.beans.BeanInfo</td><td>JavaBeans 元信息 API</td></tr><tr><td>java.beans.BeanDescriptor JavaBeans</td><td>信息描述符</td></tr><tr><td>java.beans.PropertyDescriptor</td><td>JavaBeans 属性描述符</td></tr><tr><td>java.beans.MethodDescriptor</td><td>JavaBeans 方法描述符</td></tr><tr><td>java.beans.EventSetDescriptor</td><td>JavaBeans 事件集合描述符</td></tr></tbody></table><h3 id="DataBinder-数据校验"><a href="#DataBinder-数据校验" class="headerlink" title="DataBinder 数据校验"></a>DataBinder 数据校验</h3><ul><li><code>DataBinder</code> 与 <code>BeanWrapper</code><ul><li><code>bind</code> 方法生成 <code>BeanPropertyBindingResult</code></li><li><code>BeanPropertyBindingResult</code> 关联 <code>BeanWrapper</code></li></ul></li></ul><h3 id="面试题-5"><a href="#面试题-5" class="headerlink" title="面试题"></a>面试题</h3><h4 id="Spring-数据绑定-API-是什么？"><a href="#Spring-数据绑定-API-是什么？" class="headerlink" title="Spring 数据绑定 API 是什么？"></a>Spring 数据绑定 API 是什么？</h4><p><code>org.springframework.validation.DataBinder</code></p><h4 id="BeanWrapper-与-JavaBeans-之间关系是？"><a href="#BeanWrapper-与-JavaBeans-之间关系是？" class="headerlink" title="BeanWrapper 与 JavaBeans 之间关系是？"></a>BeanWrapper 与 JavaBeans 之间关系是？</h4><p>Spring 底层 JavaBeans 基础设施的中心化接口</p><h2 id="第十五章：Spring-类型转换"><a href="#第十五章：Spring-类型转换" class="headerlink" title="第十五章：Spring 类型转换"></a>第十五章：Spring 类型转换</h2><h3 id="Spring-类型转换的实现"><a href="#Spring-类型转换的实现" class="headerlink" title="Spring 类型转换的实现"></a>Spring 类型转换的实现</h3><ul><li>基于 JavaBeans 接口的类型转换实现<ul><li>基于 <code>java.beans.PropertyEditor</code> 接口扩展</li></ul></li><li>Spring 3.0+ 通用类型转换实现<ul><li><code>org.springframework.core.convert.converter.Converter</code></li><li><code>org.springframework.core.convert.converter.ConverterFactory</code></li><li><code>org.springframework.core.convert.ConversionService</code></li></ul></li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><table><thead><tr><th>场景</th><th>基于 JavaBeans 接口的类型转换实现</th><th>Spring 3.0+ 通用类型转换实现</th></tr></thead><tbody><tr><td>数据绑定</td><td>YES</td><td>YES</td></tr><tr><td>BeanWrapper</td><td>YES</td><td>YES</td></tr><tr><td>Bean 属性类型装换</td><td>YES</td><td>YES</td></tr><tr><td>外部化属性类型转换</td><td>NO</td><td>YES</td></tr></tbody></table><h3 id="基于-JavaBeans-接口的类型转换"><a href="#基于-JavaBeans-接口的类型转换" class="headerlink" title="基于 JavaBeans 接口的类型转换"></a>基于 JavaBeans 接口的类型转换</h3><ul><li>核心职责<ul><li>将 String 类型的内容转化为目标类型的对象</li></ul></li><li>扩展原理<ol><li>Spring 框架将文本内容传递到 <code>PropertyEditor</code> 实现的 <code>setAsText(String)</code> 方法</li><li><code>PropertyEditor#setAsText(String)</code> 方法实现将 String 类型转化为目标类型的对象</li><li>将目标类型的对象传入 <code>PropertyEditor#setValue(Object)</code> 方法</li><li><code>PropertyEditor#setValue(Object)</code> 方法实现需要临时存储传入对象</li><li>Spring 框架将通过 <code>PropertyEditor#getValue()</code> 获取类型转换后的对象</li></ol></li></ul><h3 id="Spring-內建-PropertyEditor-扩展"><a href="#Spring-內建-PropertyEditor-扩展" class="headerlink" title="Spring 內建 PropertyEditor 扩展"></a>Spring 內建 PropertyEditor 扩展</h3><p>內建扩展（<code>org.springframework.beans.propertyeditors</code> 包下）</p><table><thead><tr><th>转换场景</th><th>实现类</th></tr></thead><tbody><tr><td>String -&gt; Byte 数组</td><td><code>org.springframework.beans.propertyeditors.ByteArrayPropertyEditor</code></td></tr><tr><td>String -&gt; Char</td><td><code>org.springframework.beans.propertyeditors.CharacterEditor</code></td></tr><tr><td>String -&gt; Char 数组</td><td><code>org.springframework.beans.propertyeditors.CharArrayPropertyEditor</code></td></tr><tr><td>String -&gt; Charset</td><td><code>org.springframework.beans.propertyeditors.CharsetEditor</code></td></tr><tr><td>String -&gt; Class</td><td><code>org.springframework.beans.propertyeditors.ClassEditor</code></td></tr><tr><td>String -&gt; Currency</td><td><code>org.springframework.beans.propertyeditors.CurrencyEditor</code></td></tr></tbody></table><h3 id="自定义-PropertyEditor-扩展"><a href="#自定义-PropertyEditor-扩展" class="headerlink" title="自定义 PropertyEditor 扩展"></a>自定义 PropertyEditor 扩展</h3><ol><li>扩展模式<ul><li>扩展 <code>java.beans.PropertyEditorSupport</code> 类</li></ul></li><li>实现 <code>org.springframework.beans.PropertyEditorRegistrar</code><ul><li>实现 <code>registerCustomEditors(org.springframework.beans.PropertyEditorRegistry)</code> 方法</li><li>将 <code>PropertyEditorRegistrar</code> 实现注册为 Spring Bean</li><li>声明 <code>org.springframework.beans.factory.config.CustomEditorConfigurer</code>，并将自定义 <code>PropertyEditorRegistrar</code> 加入属性 <code>propertyEditorRegistrars</code></li></ul></li><li>向 <code>org.springframework.beans.PropertyEditorRegistry</code> 注册自定义 <code>PropertyEditor</code> 实现<ul><li>通用类型实现 <code>registerCustomEditor(Class&lt;?&gt;, PropertyEditor)</code></li><li>Java Bean 属性类型实现：<code>registerCustomEditor(Class&lt;?&gt;, String, PropertyEditor)</code></li></ul></li></ol><p>注意两个接口的不同：</p><ul><li><code>org.springframework.beans.PropertyEditorRegistrar</code></li><li><code>org.springframework.beans.PropertyEditorRegistry</code></li></ul><p>相关的两个类：</p><ul><li><code>java.beans.PropertyEditor</code></li><li><code>java.beans.PropertyEditorSupport</code></li></ul><h3 id="Spring-PropertyEditor-的设计缺陷"><a href="#Spring-PropertyEditor-的设计缺陷" class="headerlink" title="Spring PropertyEditor 的设计缺陷"></a>Spring PropertyEditor 的设计缺陷</h3><ul><li>违反职责单一原则<ul><li><code>java.beans.PropertyEditor</code> 接口职责太多，除了类型转换，还包括 Java Beans 事件和 Java GUI 交互</li></ul></li><li><code>java.beans.PropertyEditor</code> 实现类型局限<ul><li>来源类型只能为 <code>java.lang.String</code> 类型</li></ul></li><li><code>java.beans.PropertyEditor</code> 实现缺少类型安全<ul><li>除了实现类命名可以表达语义，实现类无法感知目标转换类型</li></ul></li></ul><h3 id="Spring-3-通用类型转换接口"><a href="#Spring-3-通用类型转换接口" class="headerlink" title="Spring 3 通用类型转换接口"></a>Spring 3 通用类型转换接口</h3><ul><li>类型转换接口 - <code>org.springframework.core.convert.converter.Converter&lt;S,T&gt;</code><ul><li>泛型参数 S：来源类型，参数 T：目标类型</li><li>核心方法：T convert(S)</li></ul></li><li>通用类型转换接口 - <code>org.springframework.core.convert.converter.GenericConverter</code><ul><li>核心方法：<code>convert(Object,TypeDescriptor,TypeDescriptor)</code></li><li>配对类型：<code>org.springframework.core.convert.converter.GenericConverter.ConvertiblePair</code></li><li>类型描述：<code>org.springframework.core.convert.TypeDescriptor</code></li></ul></li></ul><h3 id="Spring-內建类型转换器"><a href="#Spring-內建类型转换器" class="headerlink" title="Spring 內建类型转换器"></a>Spring 內建类型转换器</h3><table><thead><tr><th>转换场景</th><th>实现类所在包名（package）</th></tr></thead><tbody><tr><td>日期 / 时间相关</td><td><code>org.springframework.format.datetime</code></td></tr><tr><td>Java 8 日期 / 时间相关</td><td><code>org.springframework.format.datetime.standard</code></td></tr><tr><td>通用实现</td><td><code>org.springframework.core.convert.support</code></td></tr></tbody></table><h3 id="Converter-接口的局限性"><a href="#Converter-接口的局限性" class="headerlink" title="Converter 接口的局限性"></a>Converter 接口的局限性</h3><ul><li>局限一：缺少 Source Type 和 Target Type 前置判断<ul><li>应对：增加 <code>org.springframework.core.convert.converter.ConditionalConverter</code> 实现<ul><li>判断泛型相关的类<ul><li><code>org.springframework.core.convert.TypeDescriptor</code></li><li><code>org.springframework.core.ResolvableType</code></li></ul></li></ul></li></ul></li><li>局限二：仅能转换单一的 Source Type 和 Target Type，不支持复合类型（比如 Collection、Map、数组等）<ul><li>应对：使用 <code>org.springframework.core.convert.converter.GenericConverter</code> 代替</li></ul></li></ul><h3 id="GenericConverter-接口"><a href="#GenericConverter-接口" class="headerlink" title="GenericConverter 接口"></a>GenericConverter 接口</h3><p><code>org.springframework.core.convert.converter.GenericConverter</code></p><table><thead><tr><th>核心要素</th><th>说明</th></tr></thead><tbody><tr><td>使用场景</td><td>用于 “复合” 类型转换场景，比如 Collection、Map、数组等</td></tr><tr><td>转换范围</td><td><code>Set&lt;ConvertiblePair&gt; getConvertibleTypes()</code></td></tr><tr><td>配对类型</td><td><code>org.springframework.core.convert.converter.GenericConverter.ConvertiblePair</code></td></tr><tr><td>转换方法</td><td><code>convert(Object,TypeDescriptor,TypeDescriptor)</code></td></tr><tr><td>类型描述</td><td><code>org.springframework.core.convert.TypeDescriptor</code></td></tr></tbody></table><p><code>GenericConverter</code> 接口处理复合类型，<code>Converter</code> 接口处理简单类型，两者可以相互配合</p><h3 id="优化-GenericConverter-接口"><a href="#优化-GenericConverter-接口" class="headerlink" title="优化 GenericConverter 接口"></a>优化 GenericConverter 接口</h3><ul><li><code>GenericConverter</code> 局限性<ul><li>缺少 Source Type 和 Target Type 前置判断</li><li>单一类型转换实现复杂</li></ul></li><li>GenericConverter 优化接口 - <code>ConditionalGenericConverter</code><ul><li>复合类型转换：<code>org.springframework.core.convert.converter.GenericConverter</code></li><li>类型条件判断：<code>org.springframework.core.convert.converter.ConditionalConverter</code></li></ul></li></ul><h3 id="扩展-Spring-类型转换器"><a href="#扩展-Spring-类型转换器" class="headerlink" title="扩展 Spring 类型转换器"></a>扩展 Spring 类型转换器</h3><ul><li>实现转换器接口<ul><li><code>org.springframework.core.convert.converter.Converter</code></li><li><code>org.springframework.core.convert.converter.ConverterFactory</code></li><li><code>org.springframework.core.convert.converter.GenericConverter</code></li></ul></li><li>注册转换器实现<ul><li>通过 <code>ConversionServiceFactoryBean</code> Spring Bean<ul><li>声明名称为 <code>conversionService</code> 的 <code>ConversionServiceFactoryBean</code></li><li>将自定义 <code>Converter</code> 传入属性 <code>converters</code></li></ul></li><li>通过 <code>org.springframework.core.convert.ConversionService</code> API</li></ul></li></ul><h3 id="统一类型转换服务"><a href="#统一类型转换服务" class="headerlink" title="统一类型转换服务"></a>统一类型转换服务</h3><ul><li><code>org.springframework.core.convert.ConversionService</code></li></ul><table><thead><tr><th>实现类型</th><th>说明</th></tr></thead><tbody><tr><td><code>GenericConversionService</code></td><td>通用 <code>ConversionService</code> 模板实现，不内置转化器实现</td></tr><tr><td><code>DefaultConversionService</code></td><td>基础 <code>ConversionService</code> 实现，内置常用转化器实现</td></tr><tr><td><code>FormattingConversionService</code></td><td>通用 <code>Formatter</code> + <code>GenericConversionService</code> 实现，不内置转化器和 <code>Formatter</code> 实现</td></tr><tr><td><code>DefaultFormattingConversionService</code></td><td><code>DefaultConversionService</code> + 格式化 实现（如：JSR-354 Money &amp; Currency, JSR-310 Date-Time）</td></tr></tbody></table><h3 id="ConversionService-作为依赖"><a href="#ConversionService-作为依赖" class="headerlink" title="ConversionService 作为依赖"></a>ConversionService 作为依赖</h3><ul><li><p>类型转换器底层接口 - <code>org.springframework.beans.TypeConverter</code></p><ul><li>起始版本：Spring 2.0</li><li>核心方法 - <code>convertIfNecessary</code> 重载方法</li><li>抽象实现 - <code>org.springframework.beans.TypeConverterSupport</code></li><li>简单实现 - <code>org.springframework.beans.SimpleTypeConverter</code></li></ul></li><li><p>类型转换器底层抽象实现 - <code>org.springframework.beans.TypeConverterSupport</code></p><ul><li>实现接口 - <code>org.springframework.beans.TypeConverter</code></li><li>扩展实现 - <code>org.springframework.beans.PropertyEditorRegistrySupport</code></li><li>委派实现 - <code>org.springframework.beans.TypeConverterDelegate</code></li></ul></li><li><p>类型转换器底层委派实现 - <code>org.springframework.beans.TypeConverterDelegate</code></p><ul><li>构造来源 - <code>org.springframework.beans.AbstractNestablePropertyAccessor</code> 实现<ul><li><code>org.springframework.beans.BeanWrapperImpl</code></li></ul></li><li>依赖 - <code>java.beans.PropertyEditor</code> 实现<ul><li>默认內建实现 - <code>PropertyEditorRegistrySupport#registerDefaultEditors</code></li></ul></li><li>可选依赖 - <code>org.springframework.core.convert.ConversionService</code> 实现</li></ul></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">整体流程：<br><span class="hljs-regexp">//</span> AbstractApplicationContext -&gt; <span class="hljs-string">&quot;conversionService&quot;</span> ConversionService Bean<br><span class="hljs-regexp">//</span> -&gt; ConfigurableBeanFactory<span class="hljs-comment">#setConversionService(ConversionService)</span><br><span class="hljs-regexp">//</span> -&gt; AbstractAutowireCapableBeanFactory.instantiateBean<br><span class="hljs-regexp">//</span> -&gt; AbstractBeanFactory<span class="hljs-comment">#getConversionService -&gt;</span><br><span class="hljs-regexp">//</span> BeanDefinition -&gt; BeanWrapper -&gt; 属性转换（数据来源：PropertyValues）-&gt;<br><span class="hljs-regexp">//</span> setPropertyValues(PropertyValues) -&gt; TypeConverter<span class="hljs-comment">#convertIfNecessnary</span><br><span class="hljs-regexp">//</span> TypeConverterDelegate<span class="hljs-comment">#convertIfNecessnary  -&gt; PropertyEditor or ConversionService</span><br></code></pre></td></tr></table></figure><h3 id="面试题-6"><a href="#面试题-6" class="headerlink" title="面试题"></a>面试题</h3><h4 id="Spring-类型转换实现有哪些？"><a href="#Spring-类型转换实现有哪些？" class="headerlink" title="Spring 类型转换实现有哪些？"></a>Spring 类型转换实现有哪些？</h4><ol><li>基于 JavaBeans PropertyEditor 接口实现</li><li>Spring 3.0+ 通用类型转换实现</li></ol><h4 id="Spring-类型转换器接口有哪些？"><a href="#Spring-类型转换器接口有哪些？" class="headerlink" title="Spring 类型转换器接口有哪些？"></a>Spring 类型转换器接口有哪些？</h4><ul><li>类型转换接口 - <code>org.springframework.core.convert.converter.Converter</code></li><li>通用类型转换接口 - <code>org.springframework.core.convert.converter.GenericConverter</code></li><li>类型条件接口 - <code>org.springframework.core.convert.converter.ConditionalConverter</code></li><li>综合类型转换接口 -<br><code>org.springframework.core.convert.converter.ConditionalGenericConverter</code></li></ul><h2 id="第十六章：Spring-泛型处理"><a href="#第十六章：Spring-泛型处理" class="headerlink" title="第十六章：Spring 泛型处理"></a>第十六章：Spring 泛型处理</h2><h3 id="Java-泛型基础"><a href="#Java-泛型基础" class="headerlink" title="Java 泛型基础"></a>Java 泛型基础</h3><ul><li><p>泛型类型</p><ul><li>泛型类型是在类型上参数化的泛型类或接口</li></ul></li><li><p>泛型使用场景</p><ul><li>编译时强类型检查</li><li>避免类型强转</li><li>实现通用算法</li></ul></li><li><p>泛型类型擦写</p><ul><li>泛型被引入到 Java 语言中，以便在<strong>编译时</strong>提供更严格的类型检查并支持泛型编程。类型擦除确保不会为参数化类型创建新类；因此，泛型不会产生运行时开销。为了实现泛型，编译器将类型擦除应用于：<ul><li>将泛型类型中的所有类型参数替换为其边界，如果类型参数是无边界的，则将其替换为 <code>Object</code>。因此，生成的字节码只包含普通类、接口和方法。</li><li>必要时插入类型转换以保持类型安全。</li><li>生成桥方法以保留扩展泛型类型中的多态性。</li></ul></li></ul></li></ul><h3 id="Java-5-类型接口"><a href="#Java-5-类型接口" class="headerlink" title="Java 5 类型接口"></a>Java 5 类型接口</h3><h4 id="Java-5-类型接口-java-lang-reflect-Type"><a href="#Java-5-类型接口-java-lang-reflect-Type" class="headerlink" title="Java 5 类型接口 - java.lang.reflect.Type"></a>Java 5 类型接口 - <code>java.lang.reflect.Type</code></h4><table><thead><tr><th>派生类或接口</th><th>说明</th></tr></thead><tbody><tr><td><code>java.lang.Class</code></td><td>Java 类 API，如 <code>java.lang.String</code></td></tr><tr><td><code>java.lang.reflect.GenericArrayType</code></td><td>泛型数组类型</td></tr><tr><td><code>java.lang.reflect.ParameterizedType</code></td><td>泛型参数类型</td></tr><tr><td><code>java.lang.reflect.TypeVariable</code></td><td>泛型类型变量，如 <code>Collection&lt;E&gt;</code> 中的 <code>E</code></td></tr><tr><td><code>java.lang.reflect.WildcardType</code></td><td>泛型通配类型</td></tr></tbody></table><h4 id="Java-泛型反射-API"><a href="#Java-泛型反射-API" class="headerlink" title="Java 泛型反射 API"></a>Java 泛型反射 API</h4><table><thead><tr><th>类型</th><th>API</th></tr></thead><tbody><tr><td>泛型信息（Generics Info）</td><td><code>java.lang.Class#getGenericInfo()</code></td></tr><tr><td>泛型参数（Parameters）</td><td><code>java.lang.reflect.ParameterizedType</code></td></tr><tr><td>泛型父类（Super Classes）</td><td><code>java.lang.Class#getGenericSuperclass()</code></td></tr><tr><td>泛型接口（Interfaces）</td><td><code>java.lang.Class#getGenericInterfaces()</code></td></tr><tr><td>泛型声明（Generics Declaration）</td><td><code>java.lang.reflect.GenericDeclaration</code></td></tr></tbody></table><h3 id="Spring-泛型类型辅助类"><a href="#Spring-泛型类型辅助类" class="headerlink" title="Spring 泛型类型辅助类"></a>Spring 泛型类型辅助类</h3><p>核心 API - <code>org.springframework.core.GenericTypeResolver</code></p><ul><li>版本支持：[2.5.2 ,)</li><li>处理类型相关（Type）相关方法<ul><li><code>resolveReturnType</code><ul><li>返回给定方法的返回类型</li></ul></li><li><code>resolveType</code></li></ul></li><li>处理泛型参数类型（ParameterizedType）相关方法<ul><li><code>resolveReturnTypeArgument</code><ul><li>返回给定方法返回类型的泛型参数类型</li></ul></li><li><code>resolveTypeArgument</code></li><li><code>resolveTypeArguments</code></li></ul></li><li>处理泛型类型变量（TypeVariable）相关方法<ul><li><code>getTypeVariableMap</code></li></ul></li></ul><h3 id="Spring-泛型集合类型辅助类"><a href="#Spring-泛型集合类型辅助类" class="headerlink" title="Spring 泛型集合类型辅助类"></a>Spring 泛型集合类型辅助类</h3><p>核心 API - <code>org.springframework.core.GenericCollectionTypeResolver</code></p><ul><li>版本支持：[2.0 , 4.3]</li><li>替换实现：<code>org.springframework.core.ResolvableType</code></li><li>处理 Collection 相关<ul><li><code>getCollection*Type</code></li></ul></li><li>处理 Map 相关<ul><li><code>getMapKey*Type</code></li><li><code>getMapValue*Type</code></li></ul></li></ul><h3 id="Spring-方法参数封装"><a href="#Spring-方法参数封装" class="headerlink" title="Spring 方法参数封装"></a>Spring 方法参数封装</h3><p>核心 API - <code>org.springframework.core.MethodParameter</code></p><ul><li>起始版本：[2.0 ,)</li><li>元信息<ul><li>关联的方法 - <code>Method</code></li><li>关联的构造器 - <code>Constructor</code></li><li>构造器或方法参数索引 - <code>parameterIndex</code></li><li>构造器或方法参数类型 - <code>parameterType</code></li><li>构造器或方法参数泛型类型 - <code>genericParameterType</code></li><li>构造器或方法参数参数名称 - <code>parameterName</code></li><li>所在的类 - <code>containingClass</code></li></ul></li></ul><p><code>Method</code> 和 <code>Constructor</code> 二选一</p><p><code>MethodParameter</code> 可以表示方法参数、构造器参数、返回类型</p><h3 id="Spring-4-0-泛型优化实现-ResolvableType"><a href="#Spring-4-0-泛型优化实现-ResolvableType" class="headerlink" title="Spring 4.0 泛型优化实现 - ResolvableType"></a>Spring 4.0 泛型优化实现 - ResolvableType</h3><p>核心 API - <code>org.springframework.core.ResolvableType</code></p><ul><li>起始版本：[4.0 ,)</li><li>扮演角色：<code>GenericTypeResolver</code> 和 <code>GenericCollectionTypeResolver</code> 替代者</li><li>工厂方法：<code>for*</code> 方法</li><li>转换方法：<code>as*</code> 方法</li><li>处理方法：<code>resolve*</code> 方法</li></ul><h3 id="ResolvableType-的局限性"><a href="#ResolvableType-的局限性" class="headerlink" title="ResolvableType 的局限性"></a>ResolvableType 的局限性</h3><ul><li>局限一：<code>ResolvableType</code> 无法处理泛型擦写</li><li>局限二：<code>ResolvableType</code> 无法处理非具体化的 <code>ParameterizedType</code></li></ul><h3 id="面试题-7"><a href="#面试题-7" class="headerlink" title="面试题"></a>面试题</h3><h4 id="Java-泛型擦写发生在编译时还是运行时？"><a href="#Java-泛型擦写发生在编译时还是运行时？" class="headerlink" title="Java 泛型擦写发生在编译时还是运行时？"></a>Java 泛型擦写发生在编译时还是运行时？</h4><p>运行时</p><h4 id="请介绍-Java-5-Type-类型的派生类或接口？"><a href="#请介绍-Java-5-Type-类型的派生类或接口？" class="headerlink" title="请介绍 Java 5 Type 类型的派生类或接口？"></a>请介绍 Java 5 Type 类型的派生类或接口？</h4><ul><li><code>java.lang.Class</code></li><li><code>java.lang.reflect.GenericArrayType</code></li><li><code>java.lang.reflect.ParameterizedType</code></li><li><code>java.lang.reflect.TypeVariable</code></li><li><code>java.lang.reflect.WildcardType</code></li></ul><h4 id="请说明-ResolvableType-的设计优势？"><a href="#请说明-ResolvableType-的设计优势？" class="headerlink" title="请说明 ResolvableType 的设计优势？"></a>请说明 ResolvableType 的设计优势？</h4><ul><li>简化 Java 5 Type API 开发，屏蔽复杂 API 的运用，如 <code>ParameterizedType</code></li><li>不变性设计（Immutability）</li><li>Fluent API 设计（Builder 模式），链式（流式）编程</li></ul><h2 id="第十七章：Spring-事件"><a href="#第十七章：Spring-事件" class="headerlink" title="第十七章：Spring 事件"></a>第十七章：Spring 事件</h2><h3 id="Java-事件-监听器编程模型"><a href="#Java-事件-监听器编程模型" class="headerlink" title="Java 事件 / 监听器编程模型"></a>Java 事件 / 监听器编程模型</h3><ul><li>设计模式 - 观察者模式扩展<ul><li>可观者对象（消息发送者）- <code>java.util.Observable</code></li><li>观察者 - <code>java.util.Observer</code></li></ul></li><li>标准化接口<ul><li>事件对象 - <code>java.util.EventObject</code></li><li>事件监听器 - <code>java.util.EventListener</code></li></ul></li></ul><h3 id="面向接口的事件-监听器设计模式"><a href="#面向接口的事件-监听器设计模式" class="headerlink" title="面向接口的事件 / 监听器设计模式"></a>面向接口的事件 / 监听器设计模式</h3><p>事件 / 监听器场景举例</p><table><thead><tr><th>Java 技术规范</th><th>事件接口</th><th>监听器接口</th></tr></thead><tbody><tr><td>JavaBeans</td><td><code>java.beans.PropertyChangeEvent</code></td><td><code>java.beans.PropertyChangeListener</code></td></tr><tr><td>Java AWT</td><td><code>java.awt.event.MouseEvent</code></td><td><code>java.awt.event.MouseListener</code></td></tr><tr><td>Java Swing</td><td><code>javax.swing.event.MenuEvent</code></td><td><code>javax.swing.event.MenuListener</code></td></tr><tr><td>Java Preference</td><td><code>java.util.prefs.PreferenceChangeEvent</code></td><td><code>java.util.prefs.PreferenceChangeListener</code></td></tr></tbody></table><h3 id="面向注解的事件-监听器设计模式"><a href="#面向注解的事件-监听器设计模式" class="headerlink" title="面向注解的事件 / 监听器设计模式"></a>面向注解的事件 / 监听器设计模式</h3><p>事件 / 监听器注解场景举例</p><table><thead><tr><th>Java 技术规范</th><th>事件注解</th><th>监听器注解</th></tr></thead><tbody><tr><td>Servlet 3.0+</td><td></td><td><code>@javax.servlet.annotation.WebListener</code></td></tr><tr><td>JPA 1.0+</td><td><code>@javax.persistence.PostPersist</code></td><td></td></tr><tr><td>Java Common</td><td><code>@PostConstruct</code></td><td></td></tr><tr><td>EJB 3.0+</td><td><code>@javax.ejb.PrePassivate</code></td><td></td></tr><tr><td>JSF 2.0+</td><td><code>@javax.faces.event.ListenerFor</code></td><td></td></tr></tbody></table><h3 id="Spring-标准事件-ApplicationEvent"><a href="#Spring-标准事件-ApplicationEvent" class="headerlink" title="Spring 标准事件 - ApplicationEvent"></a>Spring 标准事件 - ApplicationEvent</h3><ul><li><code>org.springframework.context.ApplicationEvent</code></li><li>Java 标准事件 <code>java.util.EventObject</code> 扩展<ul><li>扩展特性：事件发生时间戳</li></ul></li><li>Spring 应用上下文 <code>ApplicationEvent</code> 扩展 - <code>ApplicationContextEvent</code><ul><li><code>org.springframework.context.event.ApplicationContextEvent</code></li><li>Spring 应用上下文（ApplicationContext）作为事件源</li><li>具体实现：<ul><li><code>org.springframework.context.event.ContextClosedEvent</code></li><li><code>org.springframework.context.event.ContextRefreshedEvent</code></li><li><code>org.springframework.context.event.ContextStartedEvent</code></li><li><code>org.springframework.context.event.ContextStoppedEvent</code></li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/hr6dKQi4GCZHD9f.png" alt=""></p><h3 id="基于接口的-Spring-事件监听器"><a href="#基于接口的-Spring-事件监听器" class="headerlink" title="基于接口的 Spring 事件监听器"></a>基于接口的 Spring 事件监听器</h3><p>Java 标准事件监听器 <code>java.util.EventListener</code> 扩展</p><ul><li>扩展接口 - <code>org.springframework.context.ApplicationListener</code></li><li>设计特点：单一类型事件处理</li><li>处理方法：<code>onApplicationEvent(ApplicationEvent)</code></li><li>事件类型：<code>org.springframework.context.ApplicationEvent</code></li></ul><h3 id="基于注解的-Spring-事件监听器"><a href="#基于注解的-Spring-事件监听器" class="headerlink" title="基于注解的 Spring 事件监听器"></a>基于注解的 Spring 事件监听器</h3><p>Spring 注解 - <code>@org.springframework.context.event.EventListener</code></p><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>设计特点</td><td>支持多 <code>ApplicationEvent</code> 类型，无需接口约束</td></tr><tr><td>注解目标</td><td>方法</td></tr><tr><td>是否支持异步执行</td><td>支持</td></tr><tr><td>是否支持泛型类型事件</td><td>支持</td></tr><tr><td>是指支持顺序控制</td><td>支持，配合 <code>@Order</code> 注解控制</td></tr></tbody></table><h3 id="注册-Spring-ApplicationListener"><a href="#注册-Spring-ApplicationListener" class="headerlink" title="注册 Spring ApplicationListener"></a>注册 Spring ApplicationListener</h3><ul><li>基于 Spring 接口：向 Spring 应用上下文注册事件<ul><li><code>ApplicationListener</code> 作为 Spring Bean 注册</li><li>通过 <code>ConfigurableApplicationContext#addApplicationListener</code> API 注册</li></ul></li><li>基于 Spring 注解：<code>@org.springframework.context.event.EventListener</code></li></ul><h3 id="Spring-事件发布器"><a href="#Spring-事件发布器" class="headerlink" title="Spring 事件发布器"></a>Spring 事件发布器</h3><ul><li>方法一：通过 <code>ApplicationEventPublisher</code> 发布 Spring 事件<ul><li>获取 ApplicationEventPublisher<ul><li>依赖注入</li></ul></li></ul></li><li>方法二：通过 <code>ApplicationEventMulticaster</code> 发布 Spring 事件<ul><li>获取 <code>ApplicationEventMulticaster</code><ul><li>依赖注入</li><li>依赖查找</li></ul></li></ul></li></ul><h3 id="Spring-层次性上下文事件传播"><a href="#Spring-层次性上下文事件传播" class="headerlink" title="Spring 层次性上下文事件传播"></a>Spring 层次性上下文事件传播</h3><ul><li>发生说明<ul><li>当 Spring 应用出现多层次 Spring 应用上下文（ApplicationContext）时，如 Spring WebMVC、Spring Boot 或 Spring Cloud 场景下，由子 <code>ApplicationContext</code> 发起 Spring 事件可能会传递到其 Parent <code>ApplicationContext</code>（直到 Root）的过程</li></ul></li><li>如何避免<ul><li>定位 Spring 事件源（ApplicationContext）进行过滤处理</li></ul></li></ul><h3 id="Spring-内建事件"><a href="#Spring-内建事件" class="headerlink" title="Spring 内建事件"></a>Spring 内建事件</h3><p><code>ApplicationContextEvent</code> 派生事件</p><ul><li><code>ContextRefreshedEvent</code> ：Spring 应用上下文就绪事件</li><li><code>ContextStartedEvent</code> ：Spring 应用上下文启动事件</li><li><code>ContextStoppedEvent</code> ：Spring 应用上下文停止事件</li><li><code>ContextClosedEvent</code> ：Spring 应用上下文关闭事件</li></ul><h3 id="Spring-4-2-Payload-事件"><a href="#Spring-4-2-Payload-事件" class="headerlink" title="Spring 4.2 Payload 事件"></a>Spring 4.2 Payload 事件</h3><p>Spring Payload 事件 - <code>org.springframework.context.PayloadApplicationEvent</code></p><ul><li><p>使用场景：简化 Spring 事件发送，关注事件源主体</p></li><li><p>发送方法</p><ul><li><code>ApplicationEventPublisher#publishEvent(java.lang.Object)</code></li></ul></li></ul><h3 id="自定义-Spring-事件"><a href="#自定义-Spring-事件" class="headerlink" title="自定义 Spring 事件"></a>自定义 Spring 事件</h3><ol><li>扩展 <code>org.springframework.context.ApplicationEvent</code></li><li>实现 <code>org.springframework.context.ApplicationListener</code></li><li>将 <code>org.springframework.context.ApplicationListener</code> 注册到容器内</li></ol><h3 id="依赖注入-ApplicationEventPublisher"><a href="#依赖注入-ApplicationEventPublisher" class="headerlink" title="依赖注入 ApplicationEventPublisher"></a>依赖注入 ApplicationEventPublisher</h3><ul><li>通过 <code>ApplicationEventPublisherAware</code> 回调接口</li><li>通过 <code>@Autowired ApplicationEventPublisher</code></li></ul><h3 id="依赖查找-ApplicationEventMulticaster"><a href="#依赖查找-ApplicationEventMulticaster" class="headerlink" title="依赖查找 ApplicationEventMulticaster"></a>依赖查找 ApplicationEventMulticaster</h3><ul><li>查找条件<ul><li>Bean 名称：<code>applicationEventMulticaster</code></li><li>Bean 类型：<code>org.springframework.context.event.ApplicationEventMulticaster</code></li></ul></li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">AbstractApplicationContext</span><span class="hljs-selector-id">#earlyApplicationEvents</span> 在 <span class="hljs-selector-tag">prepareRefresh</span>() 中从 <span class="hljs-selector-tag">null</span> 被赋值，在 <span class="hljs-selector-tag">registerListeners</span>() 的最后，重新被赋值为 <span class="hljs-selector-tag">null</span>，并进行了早期事件的发布，<br>因为可能存在一个 <span class="hljs-selector-tag">Bean</span> 同时实现 <span class="hljs-selector-tag">BeanPostProcessor</span> 和 <span class="hljs-selector-tag">ApplicationEventPublisherAware</span>，并在 <span class="hljs-selector-tag">ApplicationEventPublisherAware</span><span class="hljs-selector-id">#setApplicationEventPublisher</span> 方法中发送事件<br>因为实现了 <span class="hljs-selector-tag">BeanPostProcessor</span>，所以这个 <span class="hljs-selector-tag">Bean</span> 在 <span class="hljs-selector-tag">registerBeanPostProcessors</span>(beanFactory); 这个方法中初始化，而此时 <span class="hljs-selector-tag">initApplicationEventMulticaster</span>(); 还没有执行，所以 <span class="hljs-selector-tag">AbstractApplicationContext</span><span class="hljs-selector-id">#applicationEventMulticaster</span> 为空，无法发布事件，所以先将事件保存在 <span class="hljs-selector-tag">AbstractApplicationContext</span><span class="hljs-selector-id">#earlyApplicationEvents</span> 中<br></code></pre></td></tr></table></figure><h3 id="ApplicationEventPublisher-底层实现"><a href="#ApplicationEventPublisher-底层实现" class="headerlink" title="ApplicationEventPublisher 底层实现"></a>ApplicationEventPublisher 底层实现</h3><ul><li>接口：<code>org.springframework.context.event.ApplicationEventMulticaster</code><ul><li>抽象类：<code>org.springframework.context.event.AbstractApplicationEventMulticaster</code><ul><li>实现类：<code>org.springframework.context.event.SimpleApplicationEventMulticaster</code></li></ul></li></ul></li></ul><h3 id="同步和异步-Spring-事件广播"><a href="#同步和异步-Spring-事件广播" class="headerlink" title="同步和异步 Spring 事件广播"></a>同步和异步 Spring 事件广播</h3><ul><li>基于实现类 - <code>org.springframework.context.event.SimpleApplicationEventMulticaster</code><ul><li>模式切换：<code>setTaskExecutor(java.util.concurrent.Executor)</code> 方法<ul><li>默认模式：同步</li><li>异步模式：如 <code>java.util.concurrent.ThreadPoolExecutor</code></li></ul></li><li>设计缺陷：不是基于接口契约编程，实现依赖于类本身</li></ul></li><li>基于注解 - <code>@org.springframework.context.event.EventListener</code><ul><li>模式切换<ul><li>默认模式：同步</li><li>异步模式：标注 <code>@org.springframework.scheduling.annotation.Async</code></li></ul></li><li>实现限制：无法直接实现同步 / 异步动态切换</li></ul></li></ul><p>区别：</p><ul><li>使用 <code>SimpleApplicationEventMulticaster#setTaskExecutor</code> 的影响是全局的，使用 <code>@Async</code> 是局部的</li><li>使用 <code>SimpleApplicationEventMulticaster#setTaskExecutor</code> 需要手动关闭线程池，使用 <code>@Async</code> 不需要</li></ul><h3 id="Spring-4-1-事件异常处理"><a href="#Spring-4-1-事件异常处理" class="headerlink" title="Spring 4.1 事件异常处理"></a>Spring 4.1 事件异常处理</h3><ul><li>Spring 3.0 错误处理接口 - <code>org.springframework.util.ErrorHandler</code></li><li>使用场景<ul><li>Spring 事件（Events）</li><li><code>SimpleApplicationEventMulticaster</code> Spring 4.1 开始支持</li><li>Spring 本地调度（Scheduling）<ul><li><code>org.springframework.scheduling.concurrent.ConcurrentTaskScheduler</code></li><li><code>org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler</code></li></ul></li></ul></li></ul><h3 id="Spring-事件-监听器实现原理"><a href="#Spring-事件-监听器实现原理" class="headerlink" title="Spring 事件 / 监听器实现原理"></a>Spring 事件 / 监听器实现原理</h3><ul><li>核心类 - <code>org.springframework.context.event.SimpleApplicationEventMulticaster</code><ul><li>设计模式：观察者模式扩展<ul><li>被观察者 - <code>org.springframework.context.ApplicationListener</code><ul><li>API 添加</li><li>依赖查找</li></ul></li><li>通知对象 - <code>org.springframework.context.ApplicationEvent</code></li></ul></li><li>执行模式：同步 / 异步</li><li>异常处理：<code>org.springframework.util.ErrorHandler</code></li><li>泛型处理：<code>org.springframework.core.ResolvableType</code></li></ul></li></ul><h3 id="课外资料-2"><a href="#课外资料-2" class="headerlink" title="课外资料"></a>课外资料</h3><h4 id="Spring-Boot-事件"><a href="#Spring-Boot-事件" class="headerlink" title="Spring Boot 事件"></a>Spring Boot 事件</h4><table><thead><tr><th>事件类型</th><th>发生时机</th></tr></thead><tbody><tr><td>ApplicationStartingEvent</td><td>当 Spring Boot 应用已启动时</td></tr><tr><td>ApplicationStartedEvent</td><td>当 Spring Boot 应用已启动时</td></tr><tr><td>ApplicationEnvironmentPreparedEvent</td><td>当 Spring Boot Environment 实例已准备时</td></tr><tr><td>ApplicationPreparedEvent</td><td>当 Spring Boot 应用预备时</td></tr><tr><td>ApplicationReadyEvent</td><td>当 Spring Boot 应用完全可用时</td></tr><tr><td>ApplicationFailedEvent</td><td>当 Spring Boot 应用启动失败时</td></tr></tbody></table><h4 id="Spring-Cloud-事件"><a href="#Spring-Cloud-事件" class="headerlink" title="Spring Cloud 事件"></a>Spring Cloud 事件</h4><table><thead><tr><th>事件类型</th><th>发生时机</th></tr></thead><tbody><tr><td>EnvironmentChangeEvent</td><td>当 Environment 示例配置属性发生变化时</td></tr><tr><td>HeartbeatEvent</td><td>当 Discoveryclient 客户端发送心跳时</td></tr><tr><td>InstancePreRegisteredEvent</td><td>当服务实例注册前</td></tr><tr><td>InstanceRegisteredEvent</td><td>当服务实例注册后</td></tr><tr><td>RefreshEvent</td><td>当 RefreshEndpoint 被调用时</td></tr><tr><td>RefreshScopeRefreshedEvent</td><td>当 Refresh Scope Bean 刷新后</td></tr></tbody></table><h3 id="面试题-8"><a href="#面试题-8" class="headerlink" title="面试题"></a>面试题</h3><h4 id="Spring-事件核心接口-组件？"><a href="#Spring-事件核心接口-组件？" class="headerlink" title="Spring 事件核心接口 / 组件？"></a>Spring 事件核心接口 / 组件？</h4><ul><li>Spring 事件 - <code>org.springframework.context.ApplicationEvent</code></li><li>Spring 事件监听器 - <code>org.springframework.context.ApplicationListener</code></li><li>Spring 事件发布器 - <code>org.springframework.context.ApplicationEventPublisher</code></li><li>Spring 事件广播器 - <code>org.springframework.context.event.ApplicationEventMulticaster</code></li></ul><h4 id="Spring-同步和异步事件处理的使用场景？"><a href="#Spring-同步和异步事件处理的使用场景？" class="headerlink" title="Spring 同步和异步事件处理的使用场景？"></a>Spring 同步和异步事件处理的使用场景？</h4><ul><li>Spring 同步事件 - 绝大多数 Spring 使用场景，如 <code>ContextRefreshedEvent</code></li><li>Spring 异步事件 - 主要 <code>@EventListener</code> 与 <code>@Async</code> 配合，实现异步处理，不阻塞主线程，比如长时间的数据计算任务等。不要轻易调整 <code>SimpleApplicationEventMulticaster</code> 中关联的 <code>taskExecutor</code> 对象，除非使用者非常了解 Spring 事件机制，否则容易出现异常行为。</li></ul><h2 id="第十八章：Spring-注解"><a href="#第十八章：Spring-注解" class="headerlink" title="第十八章：Spring 注解"></a>第十八章：Spring 注解</h2><h3 id="Spring-注解驱动编程发展历程"><a href="#Spring-注解驱动编程发展历程" class="headerlink" title="Spring 注解驱动编程发展历程"></a>Spring 注解驱动编程发展历程</h3><ul><li>注解驱动启蒙时代：Spring Framework 1.x<ul><li><code>@Transactional</code></li><li><code>@ManagedResource</code></li></ul></li><li>注解驱动过渡时代：Spring Framework 2.x<ul><li><code>@Component</code></li><li><code>@Repository</code></li><li><code>@Service</code></li><li><code>@Controller</code></li></ul></li><li>注解驱动黄金时代：Spring Framework 3.x<ul><li><code>@Bean</code></li><li><code>@Profile</code></li><li><code>@Import</code></li><li><code>@ImportResource</code></li><li><code>@ComponentScan</code></li><li><code>@Lazy</code></li><li><code>@PropertySource</code></li></ul></li><li>注解驱动完善时代：Spring Framework 4.x<ul><li><code>@Conditional</code></li></ul></li><li>注解驱动当下时代：Spring Framework 5.x<ul><li><code>@Indexed</code></li></ul></li></ul><h3 id="Spring-核心注解场景分类"><a href="#Spring-核心注解场景分类" class="headerlink" title="Spring 核心注解场景分类"></a>Spring 核心注解场景分类</h3><h4 id="Spring-模式注解-1"><a href="#Spring-模式注解-1" class="headerlink" title="Spring 模式注解"></a>Spring 模式注解</h4><table><thead><tr><th>Spring 注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td>@Repository</td><td>数据仓储模式注解</td><td>2.0</td></tr><tr><td>@Component</td><td>通用组件模式注解</td><td>2.5</td></tr><tr><td>@Service</td><td>服务模式注解</td><td>2.5</td></tr><tr><td>@Controller</td><td>Web 控制器模式注解</td><td>2.5</td></tr><tr><td>@Configuration</td><td>配置类模式注解</td><td>3.0</td></tr></tbody></table><h4 id="装配注解"><a href="#装配注解" class="headerlink" title="装配注解"></a>装配注解</h4><table><thead><tr><th>Spring 注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td>@lmportResource</td><td>替换 XML 元素 <code>&lt;import&gt;</code></td><td>2.5</td></tr><tr><td>@lmport</td><td>导入 Configuration 类</td><td>2.5</td></tr><tr><td>@ComponentScan</td><td>扫描指定 package 下标注 Spring 模式注解的类</td><td>3.1</td></tr></tbody></table><h4 id="依赖注入注解"><a href="#依赖注入注解" class="headerlink" title="依赖注入注解"></a>依赖注入注解</h4><table><thead><tr><th>Spring 注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td>@Autowired</td><td>Bean 依赖注入，支持多种依赖查找方式</td><td>2.5</td></tr><tr><td>@Qualifier</td><td>细粒度的 @Autowired 依赖查找</td><td>2.5</td></tr></tbody></table><h3 id="Spring-注解编程模型"><a href="#Spring-注解编程模型" class="headerlink" title="Spring 注解编程模型"></a>Spring 注解编程模型</h3><ul><li>编程模型</li><li>元注解（Meta-Annotations）</li><li>Spring 模式注解（Stereotype Annotations）</li><li>Spring 组合注解（Composed Annotations）</li><li>Spring 注解属性别名和覆盖（Attribute Aliases and Overrides）</li></ul><p><a href="https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model">Wiki</a></p><h4 id="Spring-元注解（Meta-Annotations）"><a href="#Spring-元注解（Meta-Annotations）" class="headerlink" title="Spring 元注解（Meta-Annotations）"></a>Spring 元注解（Meta-Annotations）</h4><ul><li><code>java.lang.annotation.Documented</code></li><li><code>java.lang.annotation.Inherited</code></li><li><code>java.lang.annotation.Repeatable</code></li></ul><h4 id="Spring-模式注解（Stereotype-An-notations）"><a href="#Spring-模式注解（Stereotype-An-notations）" class="headerlink" title="Spring 模式注解（Stereotype An notations）"></a>Spring 模式注解（Stereotype An notations）</h4><ul><li><p>理解 <code>@Component</code> “派生性”</p><ul><li>元标注 <code>@Component</code> 的注解在 XML 元素 <code>&lt;context:component-scan&gt;</code> 或注解 <code>@ComponentScan</code> 扫描中 “派生” 了 <code>@Component</code> 的特性，并且从 Spring Framework 4.0 开始支持多层次 ” 派生性 “。</li></ul></li><li><p>举例说明</p><ul><li><code>@Repository</code></li><li><code>@Service</code></li><li><code>@Controller</code></li><li><code>@Configuration</code></li><li><code>@SpringBootConfiguration</code> （Spring Boot）</li></ul></li><li><p><code>@Component</code> “派生性” 原理</p><ul><li>核心组件 - <code>org.springframework.context.annotation.ClassPathBeanDefinitionScanner</code><ul><li><code>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider</code></li></ul></li><li>资源处理 - <code>org.springframework.core.io.support.ResourcePatternResolver</code></li><li>资源 - 类元信息<ul><li><code>org.springframework.core.type.classreading.MetadataReaderFactory</code></li></ul></li><li>类元信息 - <code>org.springframework.core.type.ClassMetadata</code><ul><li>ASM 实现 - <code>org.springframework.core.type.classreading.ClassMetadataReadingVisitor</code></li><li>反射实现 - <code>org.springframework.core.type.StandardAnnotationMetadata</code></li></ul></li><li>注解元信息 - <code>org.springframework.core.type.AnnotationMetadata</code><ul><li>ASM 实现 - <code>org.springframework.core.type.classreading.AnnotationMetadataReadingVisitor</code></li><li>反射实现 - <code>org.springframework.core.type.StandardAnnotationMetadata</code></li></ul></li></ul></li><li><p><code>org.springframework.context.annotation.ComponentScanAnnotationParser</code></p></li></ul><h4 id="Spring-组合注解（Composed-Annotations）"><a href="#Spring-组合注解（Composed-Annotations）" class="headerlink" title="Spring 组合注解（Composed Annotations）"></a>Spring 组合注解（Composed Annotations）</h4><ul><li>基本定义<ul><li>Spring 组合注解（Composed Annotations）中的元注解允许是 Spring 模式注解（Stereotype Annotation）与 其他 Spring 功能性注解的任意组合。</li></ul></li></ul><p>相关类：</p><ul><li><code>org.springframework.context.annotation.ConfigurationClassParser</code></li><li><code>org.springframework.core.annotation.AnnotationAttributes</code></li></ul><h4 id="Spring-注解属性别名（Attribute-Aliases）"><a href="#Spring-注解属性别名（Attribute-Aliases）" class="headerlink" title="Spring 注解属性别名（Attribute Aliases）"></a>Spring 注解属性别名（Attribute Aliases）</h4><ul><li>显性别名：一个注解类中两个属性通过 <code>@AliasFor</code> 互相声明别名<ul><li><code>org.springframework.context.annotation.ComponentScan</code> 的 <code>value</code> 和 <code>basePackages</code></li></ul></li><li>隐形别名：通过在注解属性上 <code>@AliasFor</code> 元注解的属性<ul><li><code>org.springframework.boot.autoconfigure.SpringBootApplication</code> 的 <code>exclude</code> 、<code>excludeName</code></li></ul></li><li>传递隐式别名：给定一个批注中的两个或更多属性，它们通过 <code>@AliasFor</code> 声明为元注解中的属性的显式替代，如果这些属性有效地替代了元注解中的同一属性，则它们是可传递的隐式别名。</li></ul><h4 id="Spring-注解属性覆盖（Attribute-Overrides）"><a href="#Spring-注解属性覆盖（Attribute-Overrides）" class="headerlink" title="Spring 注解属性覆盖（Attribute Overrides）"></a>Spring 注解属性覆盖（Attribute Overrides）</h4><ul><li>隐式覆盖：注解中存在和元注解中名称相同的属性</li><li>显式覆盖：不同名称属性，使用 <code>@AliasFor</code> 声明为元注解属性的别名</li><li>传递显式覆盖：</li></ul><h3 id="Spring-Enable-模块驱动"><a href="#Spring-Enable-模块驱动" class="headerlink" title="Spring @Enable 模块驱动"></a>Spring @Enable 模块驱动</h3><ul><li><p>@Enable 模块驱动</p><ul><li>@Enable 模块驱动是以 <code>@Enable</code> 为前缀的注解驱动编程模型。所谓 “模块” 是指具备相同领域的功能组件集合，组合所形成一个独立的单元。比如 WebMVC 模块、AspectJ 代理模块、Caching （缓存）模块、JMX （Java 管理扩展）模块、Async （异步处理）模块等。</li></ul></li><li><p>举例说明</p><ul><li><code>@EnableWebMvc</code></li><li><code>@EnableTransactionManagement</code></li><li><code>@EnableCaching</code></li><li><code>@EnableMBeanExport</code></li><li><code>@EnableAsync</code></li></ul></li><li><p>@Enable 模块驱动编程模式</p><ul><li>驱动注解：@EnableXXX</li><li>导入注解：<code>@lmport</code> 具体实现</li><li>具体实现<ul><li>基于 Configuration Class</li><li>基于 <code>ImportSelector</code> 接口实现</li><li>基于 <code>ImportBeanDefinitionRegistrar</code> 接口实现</li></ul></li></ul></li></ul><h3 id="Spring-条件注解"><a href="#Spring-条件注解" class="headerlink" title="Spring 条件注解"></a>Spring 条件注解</h3><ul><li><p>基于配置条件注解 - <code>@org.springframework.context.annotation.Profile</code></p><ul><li>关联对象 - <code>org.springframework.core.env.Environment</code> 中的 Profiles</li><li>实现变化：从 Spring 4.0 开始，<code>@Profile</code> 基于 <code>@Conditional</code> 实现</li></ul></li><li><p>基于编程条件注解 - <code>@org.springframework.context.annotation.Conditional</code></p><ul><li>关联对象 - <code>org.springframework.context.annotation.Condition</code> 具体实现</li></ul></li><li><p><code>@Conditional</code> 实现原理</p><ul><li>上下文对象 - <code>org.springframework.context.annotation.ConditionContext</code></li><li>条件判断 - <code>org.springframework.context.annotation.ConditionEvaluator</code></li><li>配置阶段 - <code>org.springframework.context.annotation.ConfigurationCondition.ConfigurationPhase</code></li><li>判断入口 - <code>org.springframework.context.annotation.ConfigurationClassPostProcessor</code><ul><li><code>org.springframework.context.annotation.ConfigurationClassParser</code></li></ul></li></ul></li></ul><p><code>@Conditional</code> 属性可传入多个 <code>Condition</code> 类作为条件，这些条件按照 Order 排序，如果一个条件通过，就返回 true</p><h3 id="课外资料-3"><a href="#课外资料-3" class="headerlink" title="课外资料"></a>课外资料</h3><ul><li>Spring Boot 注解</li></ul><table><thead><tr><th>注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td><code>@SpringBootConfiguration</code></td><td>Spring Boot 配置类</td><td>1.4.0</td></tr><tr><td><code>@SpringBootApplication</code></td><td>Spring Boot 应用引导注解</td><td>1.2.0</td></tr><tr><td><code>@EnableAutoConfiguration</code></td><td>Spring Boot 激活自动装配</td><td>1.0.0</td></tr></tbody></table><ul><li>Spring Cloud 注解</li></ul><table><thead><tr><th>注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td><code>@SpringCloudApplication</code></td><td>Spring Cloud 应用引导注解</td><td>1.0.0</td></tr><tr><td><code>@EnableDiscoveryClient</code></td><td>Spring Cloud 激活服务发现客户端注解</td><td>1.0.0</td></tr><tr><td><code>@EnableCircuitBreaker</code></td><td>Spring Cloud 激活熔断注解</td><td>1.0.0</td></tr></tbody></table><h3 id="面试题-9"><a href="#面试题-9" class="headerlink" title="面试题"></a>面试题</h3><h4 id="Spring-模式注解有哪些？"><a href="#Spring-模式注解有哪些？" class="headerlink" title="Spring 模式注解有哪些？"></a>Spring 模式注解有哪些？</h4><ul><li><code>@org.springframework.stereotype.Component</code></li><li><code>@org.springframework.stereotype.Repository</code></li><li><code>@org.springframework.stereotype.Service</code></li><li><code>@org.springframework.stereotype.Controller</code></li><li><code>@org.springframework.context.annotation.Configuration</code></li></ul><h4 id="EventListener-的工作原理？"><a href="#EventListener-的工作原理？" class="headerlink" title="@EventListener 的工作原理？"></a>@EventListener 的工作原理？</h4><p>源码导读 - <code>org.springframework.context.event.EventListenerMethodProcessor</code></p><h4 id="PropertySource-的工作原理？"><a href="#PropertySource-的工作原理？" class="headerlink" title="@PropertySource 的工作原理？"></a>@PropertySource 的工作原理？</h4><blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://www.cnblogs.com/huangwenjie/p/13946011.html">www.cnblogs.com</a></p></blockquote><h2 id="第十九章：Spring-Environment-抽象"><a href="#第十九章：Spring-Environment-抽象" class="headerlink" title="第十九章：Spring Environment 抽象"></a>第十九章：Spring Environment 抽象</h2><h3 id="理解-Spring-Environment-抽象"><a href="#理解-Spring-Environment-抽象" class="headerlink" title="理解 Spring Environment 抽象"></a>理解 Spring Environment 抽象</h3><ul><li><p>统一的 Spring 配置属性管理</p><ul><li><code>PropertySource</code></li><li>Spring Framework 3.1 开始引入 <code>Environment</code> 抽象，它统一 Spring 配置属性的存储，包括占位符处理和类型转换，不仅完整地替换 <code>PropertyPlaceholderConfigurer</code>，而且还支持更丰富的配置属性源（PropertySource）</li><li><code>PropertyPlaceholderConfigurer</code> 在 Spring 5.2 已过期</li></ul></li><li><p>条件化 Spring Bean 装配管理</p><ul><li>Profile</li><li>通过 Environment Profiles 信息，帮助 Spring 容器提供条件化地装配 Bean</li></ul></li><li><p>Environment 接口功能分析</p><ul><li>继承了 <code>org.springframework.core.env.PropertyResolver</code> 接口，此接口提供属性管理和解析占位符的能力</li><li><code>org.springframework.core.env.Environment</code> 接口提供管理 Profiles 的能力</li></ul></li><li><p>Spring 5.2 以后，<code>PropertySourcesPlaceholderConfigurer</code> 取代 <code>PropertyPlaceholderConfigurer</code> ，两者功能类似，都继承自 <code>PlaceholderConfigurerSupport</code> 优势在于 <code>Environment</code> 和 <code>PropertySource</code></p></li></ul><h3 id="Spring-Environment-接口使用场景"><a href="#Spring-Environment-接口使用场景" class="headerlink" title="Spring Environment 接口使用场景"></a>Spring Environment 接口使用场景</h3><ul><li>用于属性占位符处理</li><li>用于转换 Spring 配置属性类型</li><li>用于存储 Spring 配置属性源（PropertySource）</li><li>用于 Profiles 状态的维护</li></ul><h3 id="Environment-占位符处理"><a href="#Environment-占位符处理" class="headerlink" title="Environment 占位符处理"></a>Environment 占位符处理</h3><ul><li><p>Spring 3.1 前占位符处理</p><ul><li>组件：<code>org.springframework.beans.factory.config.PropertyPlaceholderConfigurer</code></li><li>接口：<code>org.springframework.util.StringValueResolver</code></li></ul></li><li><p>Spring 3.1+ 占位符处理</p><ul><li>组件：<code>org.springframework.context.support.PropertySourcesPlaceholderConfigurer</code></li><li>实现类：<code>org.springframework.beans.factory.config.EmbeddedValueResolver</code><ul><li>实现了 <code>StringValueResolver</code> 接口</li></ul></li></ul></li><li><p><code>PropertyPlaceholderConfigurer</code> 和 <code>PropertySourcesPlaceholderConfigurer</code> 都实现了<code>BeanFactoryPostProcessor</code>，两者对占位符的处理都位于 <code>BeanFactoryPostProcessor#postProcessBeanFactory</code> 方法中</p></li></ul><h3 id="理解条件配置-Spring-Profiles"><a href="#理解条件配置-Spring-Profiles" class="headerlink" title="理解条件配置 Spring Profiles"></a>理解条件配置 Spring Profiles</h3><ul><li><p>Spring 3.1 条件配置</p><ul><li>API: <code>org.springframework.core.env.ConfigurableEnvironment</code><ul><li>修改：<code>addActiveProfile(String</code>)、<code>setActiveProfiles(String...)</code> 和 <code>setDefaultProfiles(String...)</code></li><li>获取：<code>getActiveProfiles()</code> 和 <code>getDefaultProfiles()</code></li><li>匹配：<code>acceptsProfiles(String...)</code> 和 <code>acceptsProfiles(Profiles)</code></li></ul></li></ul></li><li><p>注解：<code>@org.springframework.context.annotation.Profile</code></p></li><li><p>属性值常量：<code>org.springframework.core.env.AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME</code></p><ul><li>即 <code>spring.profiles.active</code>，可以通过设置此属性，设置 active Profiles</li></ul></li></ul><h3 id="Spring-4-重构-Profile"><a href="#Spring-4-重构-Profile" class="headerlink" title="Spring 4 重构 @Profile"></a>Spring 4 重构 @Profile</h3><ul><li>基于 Spring 4 接口实现<ul><li><code>@org.springframework.context.annotation.Conditional</code></li><li><code>org.springframework.context.annotation.Condition</code><ul><li><code>org.springframework.context.annotation.ProfileCondition</code></li></ul></li></ul></li></ul><h3 id="依赖注入-Environment"><a href="#依赖注入-Environment" class="headerlink" title="依赖注入 Environment"></a>依赖注入 Environment</h3><ul><li><p>直接依赖注入</p><ul><li>通过 <code>EnvironmentAware</code> 接口回调</li><li>通过 <code>@Autowired</code> 注入 <code>Environment</code></li></ul></li><li><p>间接依赖注入</p><ul><li>通过 <code>ApplicationContextAware</code> 接口回调</li><li>通过 <code>@Autowired</code> 注入 <code>ApplicationContext</code></li></ul></li><li><p><code>ApplicationContext</code> 和 <code>Environment</code> 是一一对应的</p></li><li><p>在 <code>AbstractApplicationContext#prepareBeanFactory</code> 中，以单例形式，将 <code>Environment</code> 注入了 <code>BeanFactory</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (!beanFactory.contains<span class="hljs-constructor">LocalBean(ENVIRONMENT_BEAN_NAME)</span>) &#123;<br>beanFactory.register<span class="hljs-constructor">Singleton(ENVIRONMENT_BEAN_NAME, <span class="hljs-params">getEnvironment</span>()</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="依赖查找-Environment"><a href="#依赖查找-Environment" class="headerlink" title="依赖查找 Environment"></a>依赖查找 Environment</h3><ul><li><p>直接依赖查找</p><ul><li>通过 <code>org.springframework.context.ConfigurableApplicationContext#ENVIRONMENT_BEAN_NAME</code></li></ul></li><li><p>间接依赖查找</p><ul><li>通过 <code>org.springframework.context.ConfigurableApplicationContext#getEnvironment</code></li></ul></li></ul><h3 id="依赖注入-Value"><a href="#依赖注入-Value" class="headerlink" title="依赖注入 @Value"></a>依赖注入 @Value</h3><ul><li><p>通过注入 <code>@Value</code></p><ul><li><p>实现 - <code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor</code></p></li><li><p><code>@Value</code> 注解的解析在 <code>populateBean</code> 阶段</p></li><li><p>解析的生命周期在 <code>InstantiationAwareBeanPostProcessor#postProcessProperties</code></p></li><li><p><code>AutowiredAnnotationBeanPostProcessor</code> 实现 <code>InstantiationAwareBeanPostProcessor</code></p></li><li><p>解析方法位于 <code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement#inject</code></p><ul><li><code>org.springframework.beans.factory.support.DefaultListableBeanFactory#doResolveDependency</code></li></ul></li></ul></li></ul><h3 id="Spring-类型转换在-Environment-中的运用"><a href="#Spring-类型转换在-Environment-中的运用" class="headerlink" title="Spring 类型转换在 Environment 中的运用"></a>Spring 类型转换在 Environment 中的运用</h3><ul><li><p><code>Environment</code> 底层实现</p><ul><li>底层实现 - <code>org.springframework.core.env.PropertySourcesPropertyResolver</code><ul><li>核心方法 - <code>convertValueIfNecessary(Object, Class)</code></li></ul></li><li>底层服务 - <code>org.springframework.core.convert.ConversionService</code><ul><li>默认实现 - <code>org.springframework.core.convert.support.DefaultConversionService</code></li></ul></li></ul></li><li><p><code>Environment#getProperty</code> ，从这个方法开始分析</p></li><li><p><code>AbstractEnvironment#getProperty</code> 使用 <code>PropertySourcesPropertyResolver</code>，<code>PropertySourcesPropertyResolver</code> 使用 <code>ConversionService</code></p></li></ul><h3 id="Spring-类型转换在-Value-中的运用"><a href="#Spring-类型转换在-Value-中的运用" class="headerlink" title="Spring 类型转换在 @Value 中的运用"></a>Spring 类型转换在 @Value 中的运用</h3><ul><li><code>@Value</code> 底层实现<ul><li>底层实现 - <code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor</code><ul><li><code>org.springframework.beans.factory.support.DefaultListableBeanFactory#doResolveDependency</code></li></ul></li><li>底层服务 - <code>org.springframework.beans.TypeConverter</code><ul><li>默认实现 - <code>org.springframework.beans.TypeConverterDelegate</code><ul><li><code>java.beans.PropertyEditor</code></li><li><code>org.springframework.core.convert.ConversionService</code></li></ul></li></ul></li></ul></li></ul><h3 id="Spring-配置属性源-PropertySource"><a href="#Spring-配置属性源-PropertySource" class="headerlink" title="Spring 配置属性源 PropertySource"></a>Spring 配置属性源 PropertySource</h3><ul><li>API<ul><li>单配置属性源 - <code>org.springframework.core.env.PropertySource</code></li><li>多配置属性源 - <code>org.springframework.core.env.PropertySources</code></li></ul></li><li>注解<ul><li>单配置属性源 - <code>@org.springframework.context.annotation.PropertySource</code></li><li>多配置属性源 - <code>@org.springframework.context.annotation.PropertySources</code></li></ul></li><li>关联<ul><li>存储对象 - <code>org.springframework.core.env.MutablePropertySources</code></li><li>关联方法 - <code>org.springframework.core.env.ConfigurableEnvironment#getPropertySources</code></li></ul></li></ul><h3 id="Spring-内建的配置属性源"><a href="#Spring-内建的配置属性源" class="headerlink" title="Spring 内建的配置属性源"></a>Spring 内建的配置属性源</h3><ul><li>內建 <code>PropertySource</code></li></ul><table><thead><tr><th>PropertySource 类型</th><th>说明</th></tr></thead><tbody><tr><td><code>org.springframework.core.env.CommandLinePropertySource</code></td><td>命令行配置属性源</td></tr><tr><td><code>org.springframework.jndi.JndiPropertySource</code></td><td>JDNI 配置属性源</td></tr><tr><td><code>org.springframework.core.env.PropertiesPropertySource</code></td><td>Properties 配置属性源</td></tr><tr><td><code>org.springframework.web.context.support.ServletConfigPropertySource</code></td><td>Servlet 配置属性源</td></tr><tr><td><code>org.springframework.web.context.support.ServletContextPropertySource</code></td><td>ServletContext 配置属性源</td></tr><tr><td><code>org.springframework.core.env.SystemEnvironmentPropertySource</code></td><td>环境变量配置属性源</td></tr></tbody></table><h3 id="基于注解扩展-Spring-配置属性源"><a href="#基于注解扩展-Spring-配置属性源" class="headerlink" title="基于注解扩展 Spring 配置属性源"></a>基于注解扩展 Spring 配置属性源</h3><ul><li><p><code>@org.springframework.context.annotation.PropertySource</code> 实现原理</p><ul><li>入口 - <code>org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass</code><ul><li><code>org.springframework.context.annotation.ConfigurationClassParser#processPropertySource</code></li></ul></li><li>4.3 新增语义<ul><li>配置属性字符编码 - <code>encoding</code></li><li><code>org.springframework.core.io.support.PropertySourceFactory</code></li></ul></li><li>适配对象 - <code>org.springframework.core.env.CompositePropertySource</code></li></ul></li><li><p><code>PropertySource</code> 之前只支持 properties 文件，从 Spring 4.3 开始支持其他格式文件</p><ul><li><code>org.springframework.context.annotation.PropertySource#factory</code><ul><li><code>org.springframework.core.io.support.EncodedResource</code></li></ul></li></ul></li></ul><h3 id="基于-API-扩展-Spring-配置属性源"><a href="#基于-API-扩展-Spring-配置属性源" class="headerlink" title="基于 API 扩展 Spring 配置属性源"></a>基于 API 扩展 Spring 配置属性源</h3><ul><li><p>Spring 应用上下文启动前装配 <code>PropertySource</code></p></li><li><p>Spring 应用上下文启动后装配 <code>PropertySource</code></p></li><li><p>修改 <code>PropertySource</code> 里的属性值，是否影响 Bean 里的注入属性值，需要考虑到 Bean 的初始化时机</p></li><li><p><code>PropertySource</code> 存在顺序，总是取先匹配到的</p></li></ul><h3 id="课外资料-4"><a href="#课外资料-4" class="headerlink" title="课外资料"></a>课外资料</h3><ul><li>Spring 4.1 测试配置属性源 - <code>@TestPropertySource</code></li></ul><h3 id="面试题-10"><a href="#面试题-10" class="headerlink" title="面试题"></a>面试题</h3><h4 id="简单介绍-Spring-Environment-接口？"><a href="#简单介绍-Spring-Environment-接口？" class="headerlink" title="简单介绍 Spring Environment 接口？"></a>简单介绍 Spring Environment 接口？</h4><ul><li><p>核心接口 - <code>org.springframework.core.env.Environment</code></p></li><li><p>父接口 - <code>org.springframework.core.env.PropertyResolver</code></p></li><li><p>可配置接口 - <code>org.springframework.core.env.ConfigurableEnvironment</code></p></li><li><p>职责：</p><ul><li>管理 Spring 配置属性源</li><li>管理 Profiles</li></ul></li></ul><h4 id="如何控制-PropertySource-的优先级？"><a href="#如何控制-PropertySource-的优先级？" class="headerlink" title="如何控制 PropertySource 的优先级？"></a>如何控制 PropertySource 的优先级？</h4><ul><li><code>org.springframework.core.env.ConfigurableEnvironment#getPropertySources</code><ul><li><code>org.springframework.core.env.MutablePropertySources</code><ul><li><code>MutablePropertySources</code> 中存在控制 PropertySource 顺序的方法</li></ul></li></ul></li></ul><h4 id="Environment-完整的生命周期是怎样的？"><a href="#Environment-完整的生命周期是怎样的？" class="headerlink" title="Environment 完整的生命周期是怎样的？"></a>Environment 完整的生命周期是怎样的？</h4><h2 id="第二十章：Spring-应用上下文生命周期"><a href="#第二十章：Spring-应用上下文生命周期" class="headerlink" title="第二十章：Spring 应用上下文生命周期"></a>第二十章：Spring 应用上下文生命周期</h2><h3 id="ApplicationContext-接口继承关系"><a href="#ApplicationContext-接口继承关系" class="headerlink" title="ApplicationContext 接口继承关系"></a>ApplicationContext 接口继承关系</h3><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/ofJSxp52KHYl4wT.png" alt=""></p><h3 id="Spring-应用上下文生命周期"><a href="#Spring-应用上下文生命周期" class="headerlink" title="Spring 应用上下文生命周期"></a>Spring 应用上下文生命周期</h3><ul><li><p><code>AbstractApplicationContext#refresh</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>public void refresh<span class="hljs-literal">()</span> throws BeansException, IllegalStateException &#123;<br>    synchronized (this.startupShutdownMonitor) &#123;<br>        <span class="hljs-comment">// Prepare this context for refreshing.</span><br>        prepare<span class="hljs-constructor">Refresh()</span>;<br><br>        <span class="hljs-comment">// Tell the subclass to refresh the internal bean factory.</span><br>        ConfigurableListableBeanFactory beanFactory = obtain<span class="hljs-constructor">FreshBeanFactory()</span>;<br><br>        <span class="hljs-comment">// Prepare the bean factory for use in this context.</span><br>        prepare<span class="hljs-constructor">BeanFactory(<span class="hljs-params">beanFactory</span>)</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// Allows post-processing of the bean factory in context subclasses.</span><br>            post<span class="hljs-constructor">ProcessBeanFactory(<span class="hljs-params">beanFactory</span>)</span>;<br><br>            <span class="hljs-comment">// Invoke factory processors registered as beans in the context.</span><br>            invoke<span class="hljs-constructor">BeanFactoryPostProcessors(<span class="hljs-params">beanFactory</span>)</span>;<br><br>            <span class="hljs-comment">// Register bean processors that intercept bean creation.</span><br>            register<span class="hljs-constructor">BeanPostProcessors(<span class="hljs-params">beanFactory</span>)</span>;<br><br>            <span class="hljs-comment">// Initialize message source for this context.</span><br>            init<span class="hljs-constructor">MessageSource()</span>;<br><br>            <span class="hljs-comment">// Initialize event multicaster for this context.</span><br>            init<span class="hljs-constructor">ApplicationEventMulticaster()</span>;<br><br>            <span class="hljs-comment">// Initialize other special beans in specific context subclasses.</span><br>            on<span class="hljs-constructor">Refresh()</span>;<br><br>            <span class="hljs-comment">// Check for listener beans and register them.</span><br>            register<span class="hljs-constructor">Listeners()</span>;<br><br>            <span class="hljs-comment">// Instantiate all remaining (non-lazy-init) singletons.</span><br>            finish<span class="hljs-constructor">BeanFactoryInitialization(<span class="hljs-params">beanFactory</span>)</span>;<br><br>            <span class="hljs-comment">// Last step: publish corresponding event.</span><br>            finish<span class="hljs-constructor">Refresh()</span>;<br>        &#125;<br><br>        catch (BeansException ex) &#123;<br>            <span class="hljs-keyword">if</span> (logger.is<span class="hljs-constructor">WarnEnabled()</span>) &#123;<br>                logger.warn(<span class="hljs-string">&quot;Exception encountered during context initialization - &quot;</span> +<br>                        <span class="hljs-string">&quot;cancelling refresh attempt: &quot;</span> + ex);<br>            &#125;<br><br>            <span class="hljs-comment">// Destroy already created singletons to avoid dangling resources.</span><br>            destroy<span class="hljs-constructor">Beans()</span>;<br><br>            <span class="hljs-comment">// Reset &#x27;active&#x27; flag.</span><br>            cancel<span class="hljs-constructor">Refresh(<span class="hljs-params">ex</span>)</span>;<br><br>            <span class="hljs-comment">// Propagate exception to caller.</span><br>            throw ex;<br>        &#125;<br><br>        finally &#123;<br>            <span class="hljs-comment">// Reset common introspection caches in Spring&#x27;s core, since we</span><br>            <span class="hljs-comment">// might not ever need metadata for singleton beans anymore...</span><br>            reset<span class="hljs-constructor">CommonCaches()</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Spring-应用上下文启动准备阶段"><a href="#Spring-应用上下文启动准备阶段" class="headerlink" title="Spring 应用上下文启动准备阶段"></a>Spring 应用上下文启动准备阶段</h3><ul><li><code>AbstractApplicationContext#prepareRefresh()</code> 方法<ul><li>启动时间 - <code>startupDate</code></li><li>状态标识 - <code>closed(false)</code>、<code>active(true)</code></li><li>初始化 <code>PropertySources</code> - <code>initPropertySources()</code><ul><li>默认为空方法，子类可继承</li><li>Web 应用上下文继承这个方法，并将 Web 参数初始化为 <code>PropertySource</code></li></ul></li><li>检验 <code>Environment</code> 中必须属性<ul><li><code>AbstractPropertyResolver#requiredProperties</code>，默认为空，可设置</li></ul></li><li>初始化事件监听器集合<ul><li><code>earlyApplicationListeners</code></li><li><code>applicationListeners</code></li></ul></li><li>初始化早期 Spring 事件集合<ul><li><code>earlyApplicationEvents</code></li></ul></li></ul></li></ul><h3 id="BeanFactory-创建阶段"><a href="#BeanFactory-创建阶段" class="headerlink" title="BeanFactory 创建阶段"></a>BeanFactory 创建阶段</h3><ul><li><code>AbstractApplicationContext#obtainFreshBeanFactory</code> 方法<ul><li>抽象方法</li><li>子类实现，<code>AbstractRefreshableApplicationContext#refreshBeanFactory</code><ul><li>刷新 Spring 应用上下文底层 <code>BeanFactory</code> - <code>refreshBeanFactory()</code><ul><li>销毁或关闭 <code>BeanFactory</code> ，如果已存在的话</li><li>创建 <code>BeanFactory</code> - <code>createBeanFactory()</code><ul><li><code>DefaultListableBeanFactory</code></li></ul></li><li>设置 BeanFactory Id</li><li>自定义 <code>BeanFactory</code> 属性 - <code>customizeBeanFactory(beanFactory)</code></li><li>设置 “是否允许 BeanDefinition 重复定义” - <code>customizeBeanFactory(DefaultListableBeanFactory)</code><ul><li><code>AbstractRefreshableApplicationContext#allowBeanDefinitionOverriding</code></li><li>默认为 true</li><li>设置 “是否允许循环引用（依赖）” - <code>customizeBeanFactory(DefaultListableBeanFactory)</code><ul><li><code>AbstractRefreshableApplicationContext#allowCircularReferences</code></li><li>默认为 true</li></ul></li></ul></li><li>加载 <code>BeanDefinition</code> - <code>loadBeanDefinitions(DefaultListableBeanFactory)</code> 方法<ul><li>抽象方法</li></ul></li><li>关联新建 <code>BeanFactory</code> 到 Spring 应用上下文</li></ul></li></ul></li></ul></li><li>返回 Spring 应用上下文底层 <code>BeanFactory</code> - <code>getBeanFactory()</code><ul><li>抽象方法</li></ul></li></ul><h3 id="BeanFactory-准备阶段"><a href="#BeanFactory-准备阶段" class="headerlink" title="BeanFactory 准备阶段"></a>BeanFactory 准备阶段</h3><ul><li><code>AbstractApplicationContext#prepareBeanFactory(ConfigurableListableBeanFactory)</code> 方法<ul><li>关联 <code>ClassLoader</code></li><li>设置 Bean 表达式处理器<ul><li>与 SpEL 表达式相关</li><li><code>org.springframework.context.expression.StandardBeanExpressionResolver</code></li></ul></li><li>添加 <code>PropertyEditorRegistrar</code> 实现 - <code>ResourceEditorRegistrar</code><ul><li><code>org.springframework.beans.support.ResourceEditorRegistrar</code></li></ul></li><li>添加 <code>Aware</code> 回调接口 <code>BeanPostProcessor</code> 实现 - <code>ApplicationContextAwareProcessor</code><ul><li><code>EnvironmentAware</code></li><li><code>EmbeddedValueResolverAware</code></li><li><code>ResourceLoaderAware</code></li><li><code>ApplicationEventPublisherAware</code></li><li><code>MessageSourceAware</code></li><li><code>ApplicationContextAware</code></li></ul></li><li>忽略 <code>Aware</code> 回调接口作为依赖注入接口</li><li>注册 ResolvableDependency 对象 - <code>BeanFactory</code>、<code>ResourceLoader</code>、<code>ApplicationEventPublisher</code> 以及 <code>Applicationcontext</code><ul><li><code>BeanFactory</code> 是 <code>ApplicationContext</code> 关联的 <code>BeanFactory</code></li><li><code>ResourceLoader</code>、<code>ApplicationEventPublisher</code> 以及 <code>Applicationcontext</code> 都是 <code>ApplicationContext</code></li></ul></li><li>添加 <code>BeanPostProcessor</code> - <code>ApplicationListenerDetector</code><ul><li>在 <code>BeanPostProcessor#postProcessAfterInitialization</code> 阶段，将单例的 <code>ApplicationListener</code> 加入 <code>ApplicationContext</code></li></ul></li><li>如果包含 beanName 是 <code>loadTimeWeaver</code> 的 bean，注册 <code>BeanPostProcessor</code> - <code>LoadTimeWeaverAwareProcessor</code> 对象，并设置容器的临时 <code>ClassLoader</code>， <code>AbstractBeanFactory#tempClassLoader</code><ul><li>与 AOP 相关</li></ul></li><li>注册单例对象 - <code>Environment</code>、Java System Properties 以及 OS 环境变量<ul><li><code>environment</code> - <code>ApplicationContext#environment</code></li><li><code>systemProperties</code> - <code>(Map) System.getProperties()</code></li><li><code>systemEnvironment</code> - <code>(Map) System.getenv()</code></li></ul></li></ul></li></ul><h3 id="BeanFactory-后置处理阶段"><a href="#BeanFactory-后置处理阶段" class="headerlink" title="BeanFactory 后置处理阶段"></a>BeanFactory 后置处理阶段</h3><ul><li><code>AbstractApplicationContext#postProcessBeanFactory(ConfigurableListableBeanFactory)</code> 方法<ul><li>由子类覆盖该方法</li></ul></li><li><code>org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory)</code> 方法<ul><li>判断 <code>BeanFactory</code> 是不是 <code>BeanDefinitionRegistry</code> 的实例<ul><li><code>DefaultListableBeanFactory</code> 实现 <code>BeanDefinitionRegistry</code></li><li>如果是，调用 <code>BeanFactoryPostProcessor</code> 或 <code>BeanDefinitionRegistryPostProcessor</code> 后置处理方法<ul><li><code>BeanDefinitionRegistryPostProcessor</code> 继承 <code>BeanFactoryPostProcessor</code></li><li><code>BeanFactoryPostProcessor#postProcessBeanFactory</code></li><li><code>BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry</code></li></ul></li><li>如果不是，只调用 <code>BeanFactoryPostProcessor</code> 后置处理方法 <code>BeanFactoryPostProcessor#postProcessBeanFactory</code></li></ul></li><li>如果包含 beanName 是 <code>loadTimeWeaver</code> 的 bean，注册 <code>BeanPostProcessor</code> - <code>LoadTimeWeaverAwareProcessor</code> 对象，并设置容器的临时 <code>ClassLoader</code>， <code>AbstractBeanFactory#tempClassLoader</code><ul><li>与 AOP 相关</li></ul></li></ul></li></ul><p>执行顺序：</p><ol><li>对 <code>BeanDefinitionRegistryPostProcessor</code> 进行处理<ol><li>执行 <code>BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry</code><ol><li>按照添加顺序执行， <code>AbstractApplicationContext#beanFactoryPostProcessors</code> 中的 <code>BeanDefinitionRegistryPostProcessor</code></li><li>按照 Order 顺序执行，<code>BeanFactory</code> 中实现了 <code>PriorityOrdered</code> 的 <code>BeanDefinitionRegistryPostProcessor</code> Bean</li><li>按照 Order 顺序执行，<code>BeanFactory</code> 中实现了 <code>Ordered</code> 的 <code>BeanDefinitionRegistryPostProcessor</code> Bean</li><li>按照 Order 顺序执行，其他 <code>BeanFactory</code> 中的 <code>BeanDefinitionRegistryPostProcessor</code> Bean</li></ol></li><li>执行 <code>BeanFactoryPostProcessor#postProcessBeanFactory</code><ol><li><code>AbstractApplicationContext#beanFactoryPostProcessors</code> 中的普通 <code>BeanFactoryPostProcessor</code></li><li><code>BeanFactory</code> 中 <code>BeanDefinitionRegistryPostProcessor</code></li></ol></li></ol></li><li>对 <code>BeanFactoryPostProcessor</code> 继续处理，<code>BeanFactoryPostProcessor#postProcessBeanFactory</code><ol><li>按照 Order 顺序执行，实现 <code>PriorityOrdered</code> 接口的 <code>BeanFactoryPostProcessor</code></li><li>按照 Order 顺序执行，实现 <code>Ordered</code> 接口的 <code>BeanFactoryPostProcessor</code></li><li>其他常规 <code>BeanFactoryPostProcessor</code></li></ol></li></ol><h3 id="BeanFactory-注册-BeanPostProcessor-阶段"><a href="#BeanFactory-注册-BeanPostProcessor-阶段" class="headerlink" title="BeanFactory 注册 BeanPostProcessor 阶段"></a>BeanFactory 注册 BeanPostProcessor 阶段</h3><ul><li><code>AbstractApplicationContext#registerBeanPostProcessors(ConfigurableListableBeanFactory)</code> 方 法<ul><li>注册 <code>PriorityOrdered</code> 类型的 <code>BeanPostProcessor</code> Beans</li><li>注册 <code>Ordered</code> 类型的 <code>BeanPostProcessor</code> Beans</li><li>注册普通 <code>BeanPostProcessor</code> Beans</li><li>注册 <code>MergedBeanDefinitionPostProcessor</code> Beans<ul><li><code>MergedBeanDefinitionPostProcessor</code> 继承 <code>BeanPostProcessor</code>，生命周期在 MergedBeanDefinition 后</li></ul></li><li>重新注册 <code>ApplicationListenerDetector</code> 对象<ul><li>为了将 <code>ApplicationListenerDetector</code> 的顺序放到最后</li></ul></li></ul></li></ul><h3 id="初始化內建-Bean-MessageSource"><a href="#初始化內建-Bean-MessageSource" class="headerlink" title="初始化內建 Bean: MessageSource"></a>初始化內建 Bean: MessageSource</h3><ul><li><code>AbstractApplicationContext#initMessageSource</code> 方法<ul><li>如果 <code>BeanFactory</code> 中存在 beanName 为 <code>messageSource</code> 的 <code>MessageSource</code> ，则使用，否则注册 <code>DelegatingMessageSource</code></li><li>回顾章节 - 第十二章 Spring 国际化 - <code>MessageSource</code> 内建依赖</li></ul></li></ul><h3 id="初始化內建-Bean-Spring-事件广播器"><a href="#初始化內建-Bean-Spring-事件广播器" class="headerlink" title="初始化內建 Bean: Spring 事件广播器"></a>初始化內建 Bean: Spring 事件广播器</h3><ul><li><code>AbstractApplicationContext#initApplicationEventMulticaster</code> 方法<ul><li>如果 <code>BeanFactory</code> 中存在 beanName 为 <code>applicationEventMulticaster</code> 的 <code>ApplicationEventMulticaster</code> ，则使用，否则注册 <code>SimpleApplicationEventMulticaster</code></li><li>回顾章节 - 第十七章 Spring 事件 - <code>ApplicationEventPublisher</code> 底层实现</li></ul></li></ul><h3 id="Spring-应用上下文刷新阶段"><a href="#Spring-应用上下文刷新阶段" class="headerlink" title="Spring 应用上下文刷新阶段"></a>Spring 应用上下文刷新阶段</h3><ul><li><code>AbstractApplicationContext#onRefresh</code> 方法<ul><li>空方法，由子类覆盖该方法<ul><li><code>org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#onRefresh</code></li><li><code>org.springframework.web.context.support.GenericWebApplicationContext#onRefresh</code></li><li><code>org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext#onRefresh</code></li><li><code>org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext#onRefresh</code></li><li><code>org.springframework.web.context.support.StaticWebApplicationContext#onRefresh</code></li></ul></li></ul></li></ul><h3 id="Spring-事件监听器注册阶段"><a href="#Spring-事件监听器注册阶段" class="headerlink" title="Spring 事件监听器注册阶段"></a>Spring 事件监听器注册阶段</h3><ul><li><code>AbstractApplicationContext#registerListeners</code> 方法<ul><li>将 <code>ApplicationListener</code> 添加到 <code>AbstractApplicationContext#applicationEventMulticaster</code><ul><li>添加当前应用上下文所关联的 <code>ApplicationListener</code> 对象（集合）</li><li>添加 <code>BeanFactory</code> 所注册 <code>ApplicationListener</code> Beans</li></ul></li><li>广播早期 Spring 事件<ul><li><code>AbstractApplicationContext#earlyApplicationEvents</code></li></ul></li></ul></li></ul><h3 id="BeanFactory-初始化完成阶段"><a href="#BeanFactory-初始化完成阶段" class="headerlink" title="BeanFactory 初始化完成阶段"></a>BeanFactory 初始化完成阶段</h3><ul><li><p><code>AbstractApplicationContext#finishBeanFactoryInitialization(ConfigurableListableBeanFactory)</code> 方法</p><ul><li><p><code>BeanFactory</code> 关联 <code>ConversionService</code> Bean，如果存在</p><ul><li>beanName 为 <code>conversionService</code> 的 <code>ConversionService</code></li></ul></li><li><p>添加 <code>StringValueResolver</code> 对象</p><ul><li><p>如果 <code>AbstractBeanFactory#embeddedValueResolvers</code> 为空，添加一个</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (!beanFactory.has<span class="hljs-constructor">EmbeddedValueResolver()</span>) &#123;<br>beanFactory.add<span class="hljs-constructor">EmbeddedValueResolver(<span class="hljs-params">strVal</span> -&gt; <span class="hljs-params">getEnvironment</span>()</span>.resolve<span class="hljs-constructor">Placeholders(<span class="hljs-params">strVal</span>)</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>依赖查找 <code>LoadTimeWeaverAware</code> Bean</p></li><li><p><code>BeanFactory</code> 临时 <code>ClassLoader</code> 置为 <code>null</code></p></li><li><p><code>BeanFactory</code> 冻结配置</p><ul><li><code>DefaultListableBeanFactory#configurationFrozen</code></li><li><code>DefaultListableBeanFactory#frozenBeanDefinitionNames</code></li></ul></li><li><p><code>BeanFactory</code> 初始化非延迟单例 Beans</p><ol><li>初始化非延迟单例 Bean</li><li>触发单例 Bean 中的 <code>SmartInitializingSingleton</code> 的生命周期， <code>SmartInitializingSingleton#afterSingletonsInstantiated</code></li></ol></li></ul></li></ul><h3 id="Spring-应用上下文刷新完成阶段"><a href="#Spring-应用上下文刷新完成阶段" class="headerlink" title="Spring 应用上下文刷新完成阶段"></a>Spring 应用上下文刷新完成阶段</h3><ul><li><code>AbstractApplicationContext#finishRefresh</code> 方法<ul><li>清除 <code>ResourceLoader</code> 缓存 - <code>clearResourceCaches()</code> @since 5.0</li><li>初始化 <code>LifecycleProcessor</code> 对象 - <code>initLifecycleProcessor()</code><ul><li>如果不存在 beanName 为 <code>lifecycleProcessor</code> 的 <code>LifecycleProcessor</code>，则使用 <code>DefaultLifecycleProcessor</code></li></ul></li><li>调用 <code>LifecycleProcessor#onRefresh()</code> 方法</li><li>发布 Spring 应用上下文已刷新事件 - <code>ContextRefreshedEvent</code></li><li>向 <code>MBeanServer</code> 托管 Live Beans</li></ul></li></ul><h3 id="Spring-应用上下文启动阶段"><a href="#Spring-应用上下文启动阶段" class="headerlink" title="Spring 应用上下文启动阶段"></a>Spring 应用上下文启动阶段</h3><ul><li><code>AbstractApplicationContext#start()</code> 方法<ul><li>启动 <code>LifecycleProcessor</code><ul><li>依赖查找 <code>Lifecycle</code> Beans</li><li>启动 <code>Lifecycle</code> Beans</li></ul></li></ul></li><li>发布 Spring 应用上下文已启动事件 - <code>ContextStartedEvent</code></li></ul><h3 id="Spring-应用上下文停止阶段"><a href="#Spring-应用上下文停止阶段" class="headerlink" title="Spring 应用上下文停止阶段"></a>Spring 应用上下文停止阶段</h3><ul><li><code>AbstractApplicationContext#stop()</code> 方法<ul><li>停止 <code>LifecycleProcessor</code></li><li>依赖查找 <code>Lifecycle</code> Beans</li><li>停止 <code>Lifecycle</code> Beans</li></ul></li><li>发布 Spring 应用上下文已停止事件 - <code>ContextStoppedEvent</code></li></ul><h3 id="Spring-应用上下文关闭阶段"><a href="#Spring-应用上下文关闭阶段" class="headerlink" title="Spring 应用上下文关闭阶段"></a>Spring 应用上下文关闭阶段</h3><ul><li><code>AbstractApplicationContext#close()</code> 方法</li><li>状态标识：<code>active(false)</code>、<code>closed(true)</code></li><li>Live Beans JMX 撤销托管<ul><li><code>LiveBeansView#unregisterApplicationContext(ConfigurableApplicationContext)</code></li></ul></li><li>发布 Spring 应用上下文已关闭事件 - <code>ContextCLosedEvent</code></li><li>关闭 <code>LifecycleProcessor</code><ul><li>依赖查找 <code>Lifecycle</code> Beans</li><li>停止 <code>Lifecycle</code> Beans</li></ul></li><li>销毁 Spring Beans</li><li>关闭 <code>BeanFactory</code></li><li>回调 <code>onClose()</code></li><li>注册 Shutdown Hook 线程（如果曾注册）</li></ul><h3 id="面试题-11"><a href="#面试题-11" class="headerlink" title="面试题"></a>面试题</h3><h4 id="Spring-应用上下文生命周期有哪些阶段"><a href="#Spring-应用上下文生命周期有哪些阶段" class="headerlink" title="Spring 应用上下文生命周期有哪些阶段?"></a>Spring 应用上下文生命周期有哪些阶段?</h4><ul><li>刷新阶段 - <code>ConfigurableApplicationContext#refresh()</code></li><li>启动阶段 - <code>ConfigurableApplicationContext#start()</code></li><li>停止阶段 - <code>ConfigurableApplicationContext#stop()</code></li><li>关闭阶段 - <code>ConfigurableApplicationContext#close()</code></li></ul><h4 id="Environment-完整的生命周期是怎样的？-1"><a href="#Environment-完整的生命周期是怎样的？-1" class="headerlink" title="Environment 完整的生命周期是怎样的？"></a>Environment 完整的生命周期是怎样的？</h4><h4 id="Spring-应用上下文生命周期执行动作"><a href="#Spring-应用上下文生命周期执行动作" class="headerlink" title="Spring 应用上下文生命周期执行动作?"></a>Spring 应用上下文生命周期执行动作?</h4><h2 id="课程加餐内容讨论"><a href="#课程加餐内容讨论" class="headerlink" title="课程加餐内容讨论"></a>课程加餐内容讨论</h2><h3 id="为什么说-ObjectFactory-提供的是延迟依赖查找？"><a href="#为什么说-ObjectFactory-提供的是延迟依赖查找？" class="headerlink" title="为什么说 ObjectFactory 提供的是延迟依赖查找？"></a>为什么说 ObjectFactory 提供的是延迟依赖查找？</h3><ul><li>原因<ul><li><code>ObjectFactory</code> （或 <code>ObjectProvider</code> ）可关联某一类型 Bean</li><li><code>ObjectFactory</code> 和 <code>ObjectProvider</code> 对象在被依赖注入和依赖查询时并未实时查找关联类型的 Bean</li><li><code>ObjectFactory</code> （或 <code>ObjectProvider</code> ）调用 <code>getObject()</code> 方法时，目标 Bean 才被依赖查找</li></ul></li><li>总结<ul><li><code>ObjectFactory</code> （或 <code>ObjectProvider</code> ）相当于某一类型 Bean 依赖查找代理对象</li></ul></li></ul><h3 id="依赖查找-注入-的-Bean-会被缓存吗？"><a href="#依赖查找-注入-的-Bean-会被缓存吗？" class="headerlink" title="依赖查找 (注入) 的 Bean 会被缓存吗？"></a>依赖查找 (注入) 的 Bean 会被缓存吗？</h3><ul><li>单例 Bean (Singleton) - 会<ul><li>缓存位置：<code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#singletonObjects</code> 属性</li></ul></li><li>原型 Bean (Prototype) - 不会<ul><li>当依赖查询或依赖注入时，根据 <code>BeanDefinition</code> 每次创建</li></ul></li><li>其他 Scope Bean<ul><li>request : 每个 ServletRequest 内部缓存，生命周期维持在每次 HTTP 请求</li><li>session : 每个 HttpSession 内部缓存，生命周期维持在每个用户 HTTP 会话</li><li>application : 当前 Servlet 应用内部缓存</li></ul></li></ul><h4 id="Bean-的处理流程是怎样的"><a href="#Bean-的处理流程是怎样的" class="headerlink" title="@Bean 的处理流程是怎样的?"></a>@Bean 的处理流程是怎样的?</h4><ul><li>解析范围 - Configuration Class 中的 <code>@Bean</code> 方法</li><li>方法类型 - 静态 <code>@Bean</code> 方法和实例 <code>@Bean</code> 方法</li></ul><h4 id="BeanFactory-是如何处理循环依赖的？"><a href="#BeanFactory-是如何处理循环依赖的？" class="headerlink" title="BeanFactory 是如何处理循环依赖的？"></a>BeanFactory 是如何处理循环依赖的？</h4><ul><li>循环依赖开关（方法）- <code>AbstractAutowireCapableBeanFactory#setAllowCircularReferences</code></li><li>单例工程（属性）- <code>DefaultSingletonBeanRegistry#singletonFactories</code></li><li>获取早期未处理 Bean （方法）- <code>AbstractAutowireCapableBeanFactory#getEarlyBeanReference</code></li><li>早期未处理 Bean （属性）- <code>DefaultSingletonBeanRegistry#earlySingletonObjects</code></li></ul><h4 id="MyBatis-与-Spring-Framework-是如何集成的？"><a href="#MyBatis-与-Spring-Framework-是如何集成的？" class="headerlink" title="MyBatis 与 Spring Framework 是如何集成的？"></a>MyBatis 与 Spring Framework 是如何集成的？</h4>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Framework</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DispatcherServlet解析</title>
    <link href="/2020/06/11/spring/SpringMVC%E7%9A%84DispatcherServlet%E6%BA%90%E7%A0%81Part1/"/>
    <url>/2020/06/11/spring/SpringMVC%E7%9A%84DispatcherServlet%E6%BA%90%E7%A0%81Part1/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC-的-DispatcherServlet-源码-Part1"><a href="#SpringMVC-的-DispatcherServlet-源码-Part1" class="headerlink" title="SpringMVC 的 DispatcherServlet 源码 Part1"></a><code>SpringMVC</code> 的 <code>DispatcherServlet</code> 源码 Part1</h1><h3 id="1-流程图概览"><a href="#1-流程图概览" class="headerlink" title="1.流程图概览"></a>1.流程图概览</h3><p><img src="http://image-ericshen.test.upcdn.net/uPic/iTt4Zp_image-20210403173707547" alt="流程图"></p><h3 id="2-时序图"><a href="#2-时序图" class="headerlink" title="2.时序图"></a>2.时序图</h3><p><img src="http://image-ericshen.test.upcdn.net/uPic/q4vvHq_image-20210403173700405" alt="时序图"></p><h3 id="3-继承层次"><a href="#3-继承层次" class="headerlink" title="3.继承层次"></a>3.继承层次</h3><ul><li>Hierarchy</li></ul><p><img src="http://image-ericshen.test.upcdn.net/uPic/nHMSpm_8df8cd74-31ae-4706-bdb9-bdf379e82ac7-2750511-20210403173600649" alt="image"></p><h3 id="4-源码剖析"><a href="#4-源码剖析" class="headerlink" title="4. 源码剖析"></a>4. 源码剖析</h3><ul><li>开门见山</li></ul><h4 id="4-1-doGet-doPost-源码"><a href="#4-1-doGet-doPost-源码" class="headerlink" title="4.1 doGet(),doPost()源码"></a>4.1 <code>doGet(),doPost()</code>源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br><br>processRequest(request, response);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="hljs-function"><span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br><br>processRequest(request, response);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>此处重写了<code>doGet()</code>与<code>doPost()</code>方法,交由<code>processRequest()</code>处理</li></ul><h4 id="4-2-processRequest-源码"><a href="#4-2-processRequest-源码" class="headerlink" title="4.2 processRequest()源码"></a>4.2 <code>processRequest()</code>源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>    <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();<br>    Throwable failureCause = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 获取先前请求的LocaleContext</span><br>    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();<br>    <span class="hljs-comment">// 获取当前请求的LocaleContext，其中保存了当前请求的Locale信息</span><br>    LocaleContext localeContext = buildLocaleContext(request);<br><br>    <span class="hljs-comment">// 获取先前请求的Attributes信息</span><br>    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();<br>    <span class="hljs-comment">// 获取当前请求的Attributes信息，其中保存了当前请求的各个属性数据</span><br>    ServletRequestAttributes requestAttributes = <br>        buildRequestAttributes(request, response, previousAttributes);<br><br>    <span class="hljs-comment">// 获取当前请求的WebAsyncManager，这只有在当前请求是请求的异步任务时才会真正用到</span><br>    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);<br>    <span class="hljs-comment">// 注册异步任务的拦截器，如果请求的是异步任务，这个拦截器可以拦截异步任务的前置，后置和异常等情况</span><br>    asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <br>        <span class="hljs-keyword">new</span> RequestBindingInterceptor());<br><br>    <span class="hljs-comment">// 将当前请求的Locale，Attributes信息初始化到对应的ThreadLocal对象中，用于后续使用</span><br>    initContextHolders(request, localeContext, requestAttributes);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 对当前请求进行分发</span><br>        doService(request, response);<br>    &#125; <span class="hljs-keyword">catch</span> (ServletException | IOException ex) &#123;<br>        failureCause = ex;<br>        <span class="hljs-keyword">throw</span> ex;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        failureCause = ex;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">&quot;Request processing failed&quot;</span>, ex);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 在请求完成之后，判断当前请求的Locale和Attributes信息是否需要继承，如果需要继承，</span><br>        <span class="hljs-comment">// 则会将Locale信息设置到inheritableLocaleContextHolder中，而将Attributes</span><br>        <span class="hljs-comment">// 信息设置到inheritableRequestAttributesHolder中；否则就会移除对应的信息，</span><br>        <span class="hljs-comment">// 而只为当前请求的ContextHolder设置相应的属性</span><br>        resetContextHolders(request, previousLocaleContext, previousAttributes);<br>        <span class="hljs-keyword">if</span> (requestAttributes != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 调用已注册的在当前请求被销毁时的回调函数，并且更新Session中当前请求所更新的属性</span><br>            requestAttributes.requestCompleted();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>            <span class="hljs-keyword">if</span> (failureCause != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">this</span>.logger.debug(<span class="hljs-string">&quot;Could not complete request&quot;</span>, failureCause);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;<br>                    logger.debug(<span class="hljs-string">&quot;Leaving response open for concurrent processing&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">this</span>.logger.debug(<span class="hljs-string">&quot;Successfully completed request&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 发布请求已经完成的事件，以便对该事件进行监听的程序进行相应的处理</span><br>        publishRequestHandledEvent(request, response, startTime, failureCause);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>processRequest()</code>方法主要是对<code>Locale</code>和<code>Attributes</code>信息进行了处理，然后就通过<code>doService</code>()方法对请求再次进行了分发</li></ul><h4 id="4-3-doSevice-源码"><a href="#4-3-doSevice-源码" class="headerlink" title="4.3 doSevice()源码"></a>4.3 <code>doSevice()</code>源码</h4>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doService</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>        String resumed = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult() <br>            ? <span class="hljs-string">&quot; resumed&quot;</span> : <span class="hljs-string">&quot;&quot;</span>;<br>        logger.debug(<span class="hljs-string">&quot;DispatcherServlet with name &#x27;&quot;</span> + getServletName() + <span class="hljs-string">&quot;&#x27;&quot;</span> + resumed <br>            + <span class="hljs-string">&quot; processing &quot;</span> + request.getMethod() + <span class="hljs-string">&quot; request for [&quot;</span> <br>            + getRequestUri(request) + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 这里主要是判断当前请求是否为include请求，如果是include请求，那么就会将当前请求中的</span><br>    <span class="hljs-comment">// 数据都放入一个快照中，在当前请求完成之后，会从该块中中取出数据，然后将其重新加载到</span><br>    <span class="hljs-comment">// 当前request中，以便request进行后续的处理。这里默认情况下是会对所有的属性进行处理的，</span><br>    <span class="hljs-comment">// 因为cleanupAfterInclude默认值为true，如果将其设置为false，那么就只会对Spring框架</span><br>    <span class="hljs-comment">// 相关的属性进行处理</span><br>    Map&lt;String, Object&gt; attributesSnapshot = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;<br>        attributesSnapshot = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        Enumeration&lt;?&gt; attrNames = request.getAttributeNames();<br>        <span class="hljs-keyword">while</span> (attrNames.hasMoreElements()) &#123;<br>            String attrName = (String) attrNames.nextElement();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cleanupAfterInclude <br>                || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123;<br>                attributesSnapshot.put(attrName, request.getAttribute(attrName));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 这里分别将ApplicationContext，LoacleResolver，ThemeResolver和ThemeSource等</span><br>    <span class="hljs-comment">// bean添加到当前request中</span><br>    request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());<br>    request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="hljs-keyword">this</span>.localeResolver);<br>    request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="hljs-keyword">this</span>.themeResolver);<br>    request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());<br><br>    <span class="hljs-comment">// 这里FlashMapManager主要的作用在于当请求如果是重定向的请求，那么可以将一些属性保存在FlashMap</span><br>    <span class="hljs-comment">// 中，然后通过FlashMapManager进行管理，从而在重定向之后能够获取到重定向之前所保存的请求</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.flashMapManager != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 在当前请求中获取FlashMap数据，如果不是重定向之后的请求，那么这里获取到的就是空值</span><br>        FlashMap inputFlashMap = <br>            <span class="hljs-keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);<br>        <span class="hljs-keyword">if</span> (inputFlashMap != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 将获取到的FlashMap数据保存在request中</span><br>            request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, <br>                Collections.unmodifiableMap(inputFlashMap));<br>        &#125;<br>        <span class="hljs-comment">// 设置默认的FlashMap和FlashMapManager</span><br>        request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="hljs-keyword">new</span> FlashMap());<br>        request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="hljs-keyword">this</span>.flashMapManager);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 这里才是真正的对请求进行分发处理的位置</span><br>        doDispatch(request, response);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 判断当前请求不是一个异步任务的请求，但是是一个include请求，那么就会重新加载</span><br>        <span class="hljs-comment">// 请求之前保存的快照数据</span><br>        <span class="hljs-keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;<br>            <span class="hljs-keyword">if</span> (attributesSnapshot != <span class="hljs-keyword">null</span>) &#123;<br>                restoreAttributesAfterInclude(request, attributesSnapshot);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>doSevice()</code>最终的处理在<code>doDispatch(request, response);</code></li></ul><h4 id="4-4-doDispatch-源码"><a href="#4-4-doDispatch-源码" class="headerlink" title="4.4 doDispatch()源码"></a>4.4 <code>doDispatch()</code>源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doDispatch</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    HttpServletRequest processedRequest = request;<br>    HandlerExecutionChain mappedHandler = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">boolean</span> multipartRequestParsed = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-comment">// 获取当前的异步任务管理器</span><br>    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        ModelAndView mv = <span class="hljs-keyword">null</span>;<br>        Exception dispatchException = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 这里判断当前请求是否为一个文件请求，这里的判断方式就是要求当前请求满足两点：①请求</span><br>            <span class="hljs-comment">// 方式是POST；②判断contentType是否以multipart/开头。如果满足这两点，那么就认为当前</span><br>            <span class="hljs-comment">// 请求是一个文件请求，此时会将当前请求的request对象封装为一个</span><br>            <span class="hljs-comment">// MultipartHttpServletRequest对象，这也是我们在定义文件请求的Controller时</span><br>            <span class="hljs-comment">// 能够将request参数写为MultipartHttpServletRequest的原因。这里如果不是文件请求，</span><br>            <span class="hljs-comment">// 那么会将request直接返回。</span><br>            processedRequest = checkMultipart(request);<br>            <span class="hljs-comment">// 这里判断原始request与转换后的request是否为同一个request，如果不是同一个，则说明</span><br>            <span class="hljs-comment">// 其是一个文件请求</span><br>            multipartRequestParsed = (processedRequest != request);<br>            <span class="hljs-comment">// 这里getHandler()方法就是通过遍历当前Spring容器中所有定义的HandlerMapping对象，</span><br>            <span class="hljs-comment">// 通过调用它们的getHandler()方法，看当前的HandlerMapping能否将当前request映射</span><br>            <span class="hljs-comment">// 到某个handler，也就是某个Controller方法上，如果能够映射到，则说明该handler能够</span><br>            <span class="hljs-comment">// 处理当前请求</span><br>            mappedHandler = getHandler(processedRequest);<br>            <span class="hljs-keyword">if</span> (mappedHandler == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// 如果每个HandlerMapping都无法找到与当前request匹配的handler，那么就认为</span><br>                <span class="hljs-comment">// 无法处理当前请求，此时一般会返回给页面404状态码</span><br>                noHandlerFound(processedRequest, response);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 通过找到的handler，然后在当前Spring容器中找到能够支持将当前request请求适配到</span><br>            <span class="hljs-comment">// 找到的handler上的HandlerAdapter。这里需要找到这样的适配器的原因是，我们的handler</span><br>            <span class="hljs-comment">// 一般都是Controller的某个方法，其是一个Java方法，而当前request则是一种符合http</span><br>            <span class="hljs-comment">// 协议的请求，这里是无法直接将request直接应用到handler上的，因而需要使用一个适配器，</span><br>            <span class="hljs-comment">// 也就是这里的HandlerAdapter。由于前面获取handler的时候，不同的HandlerMapping</span><br>            <span class="hljs-comment">// 所产生的handler是不一样的，比如ReqeustMappingHandlerMapping产生的handler是一个</span><br>            <span class="hljs-comment">// HandlerMethod对象，因而这里在判断某个HandlerAdapter是否能够用于适配当前handler的</span><br>            <span class="hljs-comment">// 时候是通过其supports()方法进行的，比如RequestMappingHandlerAdapter就是判断</span><br>            <span class="hljs-comment">// 当前的handler是否为HandlerMethod类型，从而判断其是否能够用于适配当前handler。</span><br>            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());<br>            String method = request.getMethod();<br>            <span class="hljs-keyword">boolean</span> isGet = <span class="hljs-string">&quot;GET&quot;</span>.equals(method);<br>            <span class="hljs-comment">// 这里判断请求方式是否为GET或HEAD请求，如果是这两种请求的一种，那么就会判断</span><br>            <span class="hljs-comment">// 当前请求的资源是否超过了其lastModified时间，如果没超过，则直接返回，</span><br>            <span class="hljs-comment">// 并且告知浏览器可以直接使用缓存来处理当前请求</span><br>            <span class="hljs-keyword">if</span> (isGet || <span class="hljs-string">&quot;HEAD&quot;</span>.equals(method)) &#123;<br>                <span class="hljs-keyword">long</span> lastModified = ha.getLastModified(request, <br>                    mappedHandler.getHandler());<br>                <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                    logger.debug(<span class="hljs-string">&quot;Last-Modified value for [&quot;</span> + getRequestUri(request) <br>                        + <span class="hljs-string">&quot;] is: &quot;</span> + lastModified);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> ServletWebRequest(request, response)<br>                    .checkNotModified(lastModified) &amp;&amp; isGet) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 这里在真正处理请求之前会获取容器中所有的拦截器，也就是HandlerInterceptor对象，</span><br>            <span class="hljs-comment">// 然后依次调用其preHandle()方法，如果某个preHandle()方法返回了false，那么就说明</span><br>            <span class="hljs-comment">// 当前请求无法通过拦截器的过滤，因而就会直接出发其afterCompletion()方法，只有在</span><br>            <span class="hljs-comment">// 所有的preHandle()方法都返回true时才会认为当前请求是能够使用目标handler进行处理的</span><br>            <span class="hljs-keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 在当前请求通过了所有拦截器的预处理之后，这里就直接调用HandlerAdapter.handle()</span><br>            <span class="hljs-comment">// 方法来处理当前请求，并且将处理结果封装为一个ModelAndView对象。该对象中主要有两个</span><br>            <span class="hljs-comment">// 属性：view和model，这里的view存储了后续需要展示的逻辑视图名或视图对象，而model</span><br>            <span class="hljs-comment">// 中则保存了用于渲染视图所需要的属性</span><br>            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());<br><br>            <span class="hljs-comment">// 如果当前是一个异步任务，那么就会释放当前线程，等待异步任务处理完成之后才将</span><br>            <span class="hljs-comment">// 任务的处理结果返回到页面</span><br>            <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 如果返回的ModelAndView对象中没有指定视图名或视图对象，那么就会根据当前请求的url</span><br>            <span class="hljs-comment">// 来生成一个视图名</span><br>            applyDefaultViewName(processedRequest, mv);<br>            <span class="hljs-comment">// 在请求处理完成之后，依次调用拦截器的postHandle()方法，对请求进行后置处理</span><br>            mappedHandler.applyPostHandle(processedRequest, response, mv);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            dispatchException = ex;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable err) &#123;<br>            <span class="hljs-comment">// 将处理请求过程中产生的异常封装到dispatchException中</span><br>            dispatchException = <span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">&quot;Handler dispatch failed&quot;</span>, <br>                err);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 这里主要是请求处理之后生成的视图进行渲染，也包括出现异常之后对异常的处理。</span><br>        <span class="hljs-comment">// 渲染完之后会依次调用拦截器的afterCompletion()方法来对请求进行最终处理</span><br>        processDispatchResult(processedRequest, response, mappedHandler, mv, <br>            dispatchException);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        <span class="hljs-comment">// 如果在上述过程中任意位置抛出异常，包括渲染视图时抛出异常，那么都会触发拦截器的</span><br>        <span class="hljs-comment">// afterCompletion()方法的调用</span><br>        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable err) &#123;<br>        triggerAfterCompletion(processedRequest, response, mappedHandler,<br>            <span class="hljs-keyword">new</span> NestedServletException(<span class="hljs-string">&quot;Handler processing failed&quot;</span>, err));<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 如果当前异步任务已经开始，则触发异步任务拦截器的afterConcurrentHandlingStarted()方法</span><br>        <span class="hljs-keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;<br>            <span class="hljs-keyword">if</span> (mappedHandler != <span class="hljs-keyword">null</span>) &#123;<br>                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, <br>                    response);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果当前是一个文件请求，则清理当前request中的文件数据</span><br>            <span class="hljs-keyword">if</span> (multipartRequestParsed) &#123;<br>                cleanupMultipart(processedRequest);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 <code>doDispatch()</code> 方法是进行请求分发和处理的主干部分，其主要分为如下几个步骤：</p><ul><li>判断当前是否为文件请求，如果是，则将 <code>request</code> 对象类型转换为 <code>MultipartHttpServletRequest</code>；</li><li>在 <code>HandlerMapping</code> 中查找能够处理当前 <code>request</code> 的 HandlerMapping，并且获取能够处理当前请求的 <code>handler</code>；</li><li>根据获取到的 <code>handler</code>，查找当前容器中支持将当前 <code>request</code> 适配到该 <code>handler</code> 的 <code>HandlerAdapter</code>；</li><li>应用容器中所有拦截器的 <code>preHandle()</code> 方法，只有在所有的 <code>preHandle()</code> 方法都通过之后才会将当前请求交由具体的 <code>handler</code> 进行处理；</li><li>调用 <code>HandlerAdapter.handle()</code> 方法将 <code>request</code> 适配给获取到的 <code>handler</code> 进行处理；</li><li>应用容器中所有拦截器的 postHandle() 方法，以对当前请求进行后置处理；</li><li>根据处理后得到的 <code>ModelAndView</code> 对象对视图进行渲染；</li><li>应用容器中所有拦截器的 <code>afterCompletion()</code> 方法，以对当前请求进行完成处理。</li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Framework</tag>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gitlab持续集成CI CD(Gitlab Runner篇)</title>
    <link href="/2019/10/16/cicd/Gitlab%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90CI%20CD(Gitlab%20Runner%E7%AF%87)/"/>
    <url>/2019/10/16/cicd/Gitlab%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90CI%20CD(Gitlab%20Runner%E7%AF%87)/</url>
    
    <content type="html"><![CDATA[<h1 id="1-GitLab-Runner-简介"><a href="#1-GitLab-Runner-简介" class="headerlink" title="1. GitLab Runner 简介"></a>1. GitLab Runner 简介</h1><p>一般来说，构建任务都会占用很多的系统资源 (譬如编译代码)，而 GitLab CI 又是 GitLab 的一部分，如果由 GitLab CI 来运行构建任务的话，在执行构建任务的时候，GitLab 的性能会大幅下降。</p><p>GitLab CI 最大的作用是管理各个项目的构建状态，因此，运行构建任务这种浪费资源的事情就交给 GitLab Runner 来做！</p><p>因为 GitLab Runner 可以安装到不同的机器上，所以在构建任务运行期间并不会影响到 GitLab 的性能。</p><blockquote><p>本文主要内容：基于Docker按照<code>gitlab-runner</code>，并集成<code>maven/jdk/docker/docker-compose</code></p></blockquote><span id="more"></span><h1 id="2-基于-Docker-安装-GitLab-Runner"><a href="#2-基于-Docker-安装-GitLab-Runner" class="headerlink" title="2. 基于 Docker 安装 GitLab Runner"></a>2. 基于 Docker 安装 GitLab Runner</h1><blockquote><p>环境</p></blockquote><ul><li>Ubuntu: 18.04.3 LTS</li><li>Docker: 19.03.3, build a872fc2f86</li><li>Docker-compose: 1.24.0, build 0aa59064</li><li>Harbor: v1.9.0 （可用nexus或者registry替代）</li><li>Gilab中文社区版: twang2218/gitlab-ce-zh:11.1.4</li></ul><h2 id="2-1-准备工作"><a href="#2-1-准备工作" class="headerlink" title="2.1 准备工作"></a>2.1 准备工作</h2><ul><li>创建工作目录 </li></ul><p><code>mkdir -p /usr/local/docker/runner</code></p><ul><li>创建构建目录 </li></ul><p><code>mkdir -p /usr/local/docker/runner/environment</code></p><ul><li><p>下载 <a href="https://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase8-2177648.html"><code>jdk-8u152-linux-x64.tar.gz</code> </a></p></li><li><p>下载  <a href="https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.6.1/apache-maven-3.6.1-bin.tar.gz"><code>apache-maven-3.6.1-bin.tar.gz</code></a></p></li><li><p><code>cp jdk-8u152-linux-x64.tar.gz /usr/local/docker/runner/environment</code></p></li><li><p><code>cp apache-maven-3.6.1-bin.tar.gz /usr/local/docker/runner/environment</code></p><blockquote><p>可选：若有nexus伺服</p><p>配置<code>maven</code>的<code>setting.xml</code>文件至<code>/usr/local/docker/runner/environment</code>目录下</p></blockquote></li></ul><h2 id="2-2-daemon-json"><a href="#2-2-daemon-json" class="headerlink" title="2.2 daemon.json"></a>2.2 daemon.json</h2><p>在 <code>/usr/local/docker/runner/environment</code> 目录下创建 daemon.json，用于配置镜像加速器和仓库地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo tee /usr/<span class="hljs-built_in">local</span>/docker/runner/environment/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span><br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>  <span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span> <span class="hljs-comment">#docker-cn加速器</span><br>  ],<br>  <span class="hljs-string">&quot;insecure-registries&quot;</span>: [<br>    <span class="hljs-string">&quot;192.168.10.133:5000&quot;</span>   <span class="hljs-comment">#harbor仓库地址</span><br>  ]<br>&#125;<br>EOF<br></code></pre></td></tr></table></figure><blockquote><p>推荐配置阿里云镜像加速器，可参考<a href="http://ericshen.tech/2019/04/15/Ubuntu安装Dokcer-CE/">Linux安装Dokcer CE 3.5</a>)</p></blockquote><h2 id="2-3-Dockerfile"><a href="#2-3-Dockerfile" class="headerlink" title="2.3 Dockerfile"></a>2.3 Dockerfile</h2><p>在<code>/usr/local/docker/runner/environment</code> 目录下创建 <code>Dockerfile</code></p><p><code>vim /usr/local/docker/runner/environment/Dockerfile</code></p><p><strong>内容如下</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> gitlab/gitlab-runner<br><span class="hljs-keyword">MAINTAINER</span> EricShen &lt;ahsbt@<span class="hljs-number">126</span>.com&gt;<br><br><span class="hljs-comment"># 修改软件源</span><br><span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse&#x27;</span> &gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse&#x27;</span> &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse&#x27;</span> &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="bash">    <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse&#x27;</span> &gt;&gt; /etc/apt/sources.list &amp;&amp; \</span><br><span class="bash">    apt-get update -y &amp;&amp; \</span><br><span class="bash">    apt-get clean</span><br><br><span class="hljs-comment"># 通过官方脚本安装 Docker</span><br><span class="hljs-keyword">RUN</span><span class="bash"> curl -fsSL get.docker.com -o get-docker.sh &amp;&amp; \</span><br><span class="bash">    sh get-docker.sh --mirror Aliyun</span><br><span class="hljs-keyword">COPY</span><span class="bash"> daemon.json /etc/docker/daemon.json</span><br><br><span class="hljs-comment"># 安装 Docker Compose</span><br><span class="hljs-keyword">WORKDIR</span><span class="bash"> /usr/<span class="hljs-built_in">local</span>/bin</span><br><span class="hljs-keyword">RUN</span><span class="bash"> wget https://raw.githubusercontent.com/topsale/resources/master/docker/docker-compose</span><br><span class="hljs-keyword">RUN</span><span class="bash"> chmod +x docker-compose</span><br><br><span class="hljs-comment"># 安装 Java</span><br><span class="hljs-keyword">RUN</span><span class="bash"> mkdir -p /usr/<span class="hljs-built_in">local</span>/java</span><br><span class="hljs-keyword">WORKDIR</span><span class="bash"> /usr/<span class="hljs-built_in">local</span>/java</span><br><span class="hljs-keyword">COPY</span><span class="bash"> jdk-8u152-linux-x64.tar.gz /usr/<span class="hljs-built_in">local</span>/java</span><br><span class="hljs-keyword">RUN</span><span class="bash"> tar -zxvf jdk-8u152-linux-x64.tar.gz &amp;&amp; \</span><br><span class="bash">    rm -fr jdk-8u152-linux-x64.tar.gz</span><br><br><span class="hljs-comment"># 安装 Maven</span><br><span class="hljs-keyword">RUN</span><span class="bash"> mkdir -p /usr/<span class="hljs-built_in">local</span>/maven</span><br><span class="hljs-keyword">WORKDIR</span><span class="bash"> /usr/<span class="hljs-built_in">local</span>/maven</span><br><span class="hljs-comment"># 若未下载maven，此处可下载</span><br><span class="hljs-comment"># RUN wget https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.6.1/apache-maven-3.6.1-bin.tar.gz</span><br><span class="hljs-keyword">COPY</span><span class="bash"> apache-maven-3.6.1-bin.tar.gz /usr/<span class="hljs-built_in">local</span>/maven</span><br><span class="hljs-keyword">RUN</span><span class="bash"> tar -zxvf apache-maven-3.6.1-bin.tar.gz &amp;&amp; \</span><br><span class="bash">    rm -fr apache-maven-3.6.1-bin.tar.gz</span><br><span class="hljs-comment"># 可选：配置maven的setting.xml</span><br><span class="hljs-comment"># COPY settings.xml /usr/local/maven/apache-maven-3.6.1/conf/settings.xml</span><br><br><span class="hljs-comment"># 配置环境变量</span><br><span class="hljs-keyword">ENV</span> JAVA_HOME /usr/local/java/jdk1.<span class="hljs-number">8.0</span>_152<br><span class="hljs-keyword">ENV</span> MAVEN_HOME /usr/local/maven/apache-maven-<span class="hljs-number">3.6</span>.<span class="hljs-number">1</span><br><span class="hljs-keyword">ENV</span> PATH $PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin<br><br><span class="hljs-keyword">WORKDIR</span><span class="bash"> /</span><br></code></pre></td></tr></table></figure><h2 id="2-4-docker-compose-yml"><a href="#2-4-docker-compose-yml" class="headerlink" title="2.4 docker-compose.yml"></a>2.4 docker-compose.yml</h2><p>在 <code>/usr/local/docker/runner</code> 目录下创建 <code>docker-compose.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.1&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">gitlab-runner:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">environment</span> <span class="hljs-comment">#指定构建路径</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">gitlab-runner</span><br>    <span class="hljs-attr">privileged:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./config:/etc/gitlab-runner</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/var/run/docker.sock:/var/run/docker.sock</span><br></code></pre></td></tr></table></figure><h2 id="2-5-构建镜像"><a href="#2-5-构建镜像" class="headerlink" title="2.5 构建镜像"></a>2.5 构建镜像</h2><blockquote><p>确认所需文件</p></blockquote><p><code>ls /usr/local/docker/runner</code> 有</p><ul><li><code>docker-compose.yml</code>文件</li></ul><p><code>ls /usr/local/docker/runner/environment</code>有</p><ul><li><p><code>apache-maven-3.6.1-bin.tar.gz</code></p></li><li><p><code>daemon.json</code>  </p></li><li><p><code>Dockerfile</code>  </p></li><li><p><code>jdk-8u152-linux-x64.tar.gz</code>  </p></li><li><p><code>setting.xml</code></p></li></ul><p><strong>构建镜像</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/docker/runner<br>docker-compose build<br></code></pre></td></tr></table></figure><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">...</span>省略<span class="hljs-string">...</span><br>Successfully build xxxxxxx<br>Successfully tagged runner_gitlab-runner <span class="hljs-comment"># 构建成功</span><br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> images #查看镜像<br><span class="hljs-attribute">REPOSITORY</span>                               TAG                 IMAGE ID            CREATED             SIZE<br><span class="hljs-attribute">runner_gitlab</span>-runner                     latest              <span class="hljs-number">74</span>b<span class="hljs-number">8379</span>cca<span class="hljs-number">15</span>        <span class="hljs-number">41</span> hours ago        <span class="hljs-number">1</span>.<span class="hljs-number">37</span>GB<br></code></pre></td></tr></table></figure><h1 id="3-注册-Runner"><a href="#3-注册-Runner" class="headerlink" title="3. 注册 Runner"></a>3. 注册 Runner</h1><p>首先获取<code>Gitlab上项目路径=&gt;设置=&gt;CI/CD=&gt;Runner=&gt;Setup a specific Runner manually</code>下<code>Gitlab</code>地址和<code>token</code></p><ul><li>Gitlab中文社区版</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/vFhE859ZPDTlSc6.png" alt="Gitlab中文社区版"></p><ul><li>英文原版Gitlab社区版</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/YgnpH2NKRLmi8ac.png" alt="英文原版Gitlab社区版"></p><p>然后到服务器中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 执行</span><br>docker <span class="hljs-built_in">exec</span> -it gitlab-runner gitlab-runner register <br><br><span class="hljs-comment"># 输入 GitLab 地址</span><br>Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/):<br>http://192.192.1.12/<br><br><span class="hljs-comment"># 输入 GitLab Token</span><br>Please enter the gitlab-ci token <span class="hljs-keyword">for</span> this runner:<br>PgC_sRjg3qZgrU4WGvjY<br><br><span class="hljs-comment"># 输入 Runner 的描述</span><br>Please enter the gitlab-ci description <span class="hljs-keyword">for</span> this runner:<br><span class="hljs-comment"># 可以为空</span><br><br><span class="hljs-comment"># 设置 Tag，可以用于指定在构建规定的 tag 时触发 ci</span><br>Please enter the gitlab-ci tags <span class="hljs-keyword">for</span> this runner (comma separated):<br>deploy<br><br>Registering runner... succeeded                     runner=PgC_sRjg<br><span class="hljs-comment"># 选择 runner 执行器，这里我们选择的是 shell</span><br>Please enter the executor: virtualbox, docker+machine, parallels, shell, ssh, docker-ssh+machine, kubernetes, docker, docker-ssh:<br>shell<br><br>Runner registered successfully. Feel free to start it, but <span class="hljs-keyword">if</span> it<span class="hljs-string">&#x27;s running already the config should be automatically reloaded!</span><br></code></pre></td></tr></table></figure><h1 id="4-使用-Runner"><a href="#4-使用-Runner" class="headerlink" title="4. 使用 Runner"></a>4. 使用 Runner</h1><blockquote><p>进入你想要进行CI/CD的项目中（FYI: 通过<a href="https://start.spring.io/">Spring Initializr</a>快速构架一个基于maven构建的Spring Boot项目）</p></blockquote><ul><li>编写<code>Dockerfile</code></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">8</span>-jre  <span class="hljs-comment">#基于openjdk构建镜像</span><br><span class="hljs-keyword">MAINTAINER</span> EricShen &lt;ahsbt@<span class="hljs-number">126</span>.com&gt;<br><br><span class="hljs-keyword">ENV</span> APP_VERSION <span class="hljs-number">1.0</span>.<span class="hljs-number">0</span>-SNAPSHOT<br><span class="hljs-keyword">ENV</span> DOCKERIZE_VERSION v0.<span class="hljs-number">6.1</span><br><span class="hljs-keyword">RUN</span><span class="bash"> wget https://github.com/jwilder/dockerize/releases/download/<span class="hljs-variable">$DOCKERIZE_VERSION</span>/dockerize-linux-amd64-<span class="hljs-variable">$DOCKERIZE_VERSION</span>.tar.gz \</span><br><span class="bash">    &amp;&amp; tar -C /usr/<span class="hljs-built_in">local</span>/bin -xzvf dockerize-linux-amd64-<span class="hljs-variable">$DOCKERIZE_VERSION</span>.tar.gz \</span><br><span class="bash">    &amp;&amp; rm dockerize-linux-amd64-<span class="hljs-variable">$DOCKERIZE_VERSION</span>.tar.gz</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> mkdir /app</span><br><br><span class="hljs-keyword">COPY</span><span class="bash"> <span class="hljs-built_in">test</span>-<span class="hljs-variable">$APP_VERSION</span>.jar /app/app.jar</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="bash"> [<span class="hljs-string">&quot;dockerize&quot;</span>, <span class="hljs-string">&quot;-timeout&quot;</span>, <span class="hljs-string">&quot;5m&quot;</span>, <span class="hljs-string">&quot;-wait&quot;</span>, <span class="hljs-string">&quot;tcp://192.192.1.12:3306&quot;</span>, <span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-Djava.security.egd=file:/dev/./urandom&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;/app/app.jar&quot;</span>]</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br></code></pre></td></tr></table></figure><ul><li>编写<code>docker-compose.yml</code></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.1&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">test_java:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-number">192.192</span><span class="hljs-number">.1</span><span class="hljs-number">.12</span><span class="hljs-string">:9090/test/test:v1.0.0</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">test_container</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8080</span><span class="hljs-string">:8080</span><br></code></pre></td></tr></table></figure><ul><li>编写<code>.gitlab-ci.yml</code>文件，添加到项目根路径下</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">stages:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">build</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">push</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">run</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">clean</span><br><br><span class="hljs-comment">#构建</span><br><span class="hljs-attr">build:</span><br>  <span class="hljs-attr">stage:</span> <span class="hljs-string">build</span><br>  <span class="hljs-attr">script:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">/usr/local/maven/apache-maven-3.6.1/bin/mvn</span> <span class="hljs-string">clean</span> <span class="hljs-string">package</span> <span class="hljs-comment"># mvn 打jar包</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">cp</span> <span class="hljs-string">target/test-1.0.0-SNAPSHOT.jar</span> <span class="hljs-string">docker</span> <br>    <span class="hljs-bullet">-</span> <span class="hljs-string">cd</span> <span class="hljs-string">docker</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span> <span class="hljs-string">build</span> <span class="hljs-string">-t</span> <span class="hljs-number">192.192</span><span class="hljs-number">.1</span><span class="hljs-number">.12</span><span class="hljs-string">:9090/test/test:v1.0.0</span> <span class="hljs-string">.</span> <span class="hljs-comment">#构建镜像</span><br><br><span class="hljs-comment">#推送</span><br><span class="hljs-attr">push:</span><br>  <span class="hljs-attr">stage:</span> <span class="hljs-string">push</span><br>  <span class="hljs-attr">script:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span> <span class="hljs-string">login</span> <span class="hljs-number">192.192</span><span class="hljs-number">.1</span><span class="hljs-number">.12</span><span class="hljs-string">:9090</span> <span class="hljs-string">-u</span> <span class="hljs-string">admin</span> <span class="hljs-string">-p</span> <span class="hljs-string">Harbor12345</span> <span class="hljs-comment"># 登陆Harbor仓库</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span> <span class="hljs-string">push</span> <span class="hljs-number">192.192</span><span class="hljs-number">.1</span><span class="hljs-number">.12</span><span class="hljs-string">:9090/test/test:v1.0.0</span> <span class="hljs-comment"># 推送镜像至Harbor</span><br><br><span class="hljs-comment">#运行</span><br><span class="hljs-attr">run:</span><br>  <span class="hljs-attr">stage:</span> <span class="hljs-string">run</span><br>  <span class="hljs-attr">script:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">cd</span> <span class="hljs-string">docker</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">docker-compose</span> <span class="hljs-string">down</span> <span class="hljs-comment"># 关闭容器</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">docker-compose</span> <span class="hljs-string">up</span> <span class="hljs-string">-d</span> <span class="hljs-comment"># 启动容器</span><br><br><span class="hljs-comment">#清理</span><br><span class="hljs-attr">clean:</span><br>  <span class="hljs-attr">stage:</span> <span class="hljs-string">clean</span><br>  <span class="hljs-attr">script:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span> <span class="hljs-string">image</span> <span class="hljs-string">prune</span> <span class="hljs-string">-f</span> <span class="hljs-comment"># 清理虚悬镜像</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/1hJDtilvoK89Qzu.png" alt="img"></p><h1 id="5-测试集成效果"><a href="#5-测试集成效果" class="headerlink" title="5. 测试集成效果"></a>5. 测试集成效果</h1><p>所有操作完成后 <code>push</code> 代码到服务器，<code>Gitlab</code>会自动进行构建，在<code>CI/CD</code>的<code>Pipeline</code>中查看构建的结果：</p><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/8mq5QSo4YNl2h6F.png" alt="image.png"></p><ul><li>点击进入查看每条<code>Pipeline</code>的详情，由下图可见<code>Pipeline</code>有4个<code>Stages</code>，<code>build=&gt;push=&gt;run=&gt;clean</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/WsRMSiQz1kqp7X6.png" alt="image.png"></p><ul><li>此时可以看到构建完成，通过访问8080端口即可查看项目已经成功启动</li></ul><h1 id="6-其它命令"><a href="#6-其它命令" class="headerlink" title="6. 其它命令"></a>6. 其它命令</h1><ul><li><p>删除注册信息<br><code>docker exec -it gitlab-runner gitlab-runner --name &quot;名称&quot;</code></p></li><li><p>删除所有注册信息</p><p><code>docker exec -it gitlab-runner gitlab-runner  unregister --all-runners</code></p></li><li><p>查看注册列表<br><code>docker exec -it gitlab-runner gitlab-runner list</code></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>PaaS</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gitlab</tag>
      
      <tag>docker</tag>
      
      <tag>gitlab-runner</tag>
      
      <tag>CI/CD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis Sentinel 集群部署</title>
    <link href="/2019/09/25/Redis-Sentinel-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
    <url>/2019/09/25/Redis-Sentinel-%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Redis 集群可以在一组 redis 节点之间实现高可用性和 sharding。在集群中会有 1 个 master 和多个 slave 节点。当 master 节点失效时，应选举出一个 slave 节点作为新的 master。然而 Redis 本身(包括它的很多客户端)没有实现自动故障发现并进行主备切换的能力，需要外部的监控方案来实现自动故障恢复。</p><p>Redis Sentinel 是官方推荐的高可用性解决方案。它是 Redis 集群的监控管理工具，可以提供节点监控、通知、自动故障恢复和客户端配置发现服务。</p><span id="more"></span><p><img src="https://i.loli.net/2019/10/15/4XWpR7vizfPs51Q.png" alt="image.png"></p><h2 id="Redis-Sentinel-核心配置"><a href="#Redis-Sentinel-核心配置" class="headerlink" title="Redis Sentinel 核心配置"></a>Redis Sentinel 核心配置</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># Example sentinel.conf</span><br><br><span class="hljs-comment"># *** IMPORTANT ***</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># By default Sentinel will not be reachable from interfaces different than</span><br><span class="hljs-comment"># localhost, either use the &#x27;bind&#x27; directive to bind to a list of network</span><br><span class="hljs-comment"># interfaces, or disable protected mode with &quot;protected-mode no&quot; by</span><br><span class="hljs-comment"># adding it to this configuration file.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Before doing that MAKE SURE the instance is protected from the outside</span><br><span class="hljs-comment"># world via firewalling or other means.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># For example you may use one of the following:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># bind 127.0.0.1 192.168.1.1</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># protected-mode no</span><br><br><span class="hljs-comment"># port &lt;sentinel-port&gt;</span><br><span class="hljs-comment"># The port that this sentinel instance will run on</span><br><span class="hljs-attr">port</span> <span class="hljs-string">26379</span><br><br><span class="hljs-comment"># sentinel announce-ip &lt;ip&gt;</span><br><span class="hljs-comment"># sentinel announce-port &lt;port&gt;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The above two configuration directives are useful in environments where,</span><br><span class="hljs-comment"># because of NAT, Sentinel is reachable from outside via a non-local address.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># When announce-ip is provided, the Sentinel will claim the specified IP address</span><br><span class="hljs-comment"># in HELLO messages used to gossip its presence, instead of auto-detecting the</span><br><span class="hljs-comment"># local address as it usually does.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Similarly when announce-port is provided and is valid and non-zero, Sentinel</span><br><span class="hljs-comment"># will announce the specified TCP port.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The two options don&#x27;t need to be used together, if only announce-ip is</span><br><span class="hljs-comment"># provided, the Sentinel will announce the specified IP and the server port</span><br><span class="hljs-comment"># as specified by the &quot;port&quot; option. If only announce-port is provided, the</span><br><span class="hljs-comment"># Sentinel will announce the auto-detected local IP and the specified port.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Example:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># sentinel announce-ip 1.2.3.4</span><br><br><span class="hljs-comment"># dir &lt;working-directory&gt;</span><br><span class="hljs-comment"># Every long running process should have a well-defined working directory.</span><br><span class="hljs-comment"># For Redis Sentinel to chdir to /tmp at startup is the simplest thing</span><br><span class="hljs-comment"># for the process to don&#x27;t interfere with administrative tasks such as</span><br><span class="hljs-comment"># unmounting filesystems.</span><br><span class="hljs-attr">dir</span> <span class="hljs-string">/tmp</span><br><br><span class="hljs-comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Tells Sentinel to monitor this master, and to consider it in O_DOWN</span><br><span class="hljs-comment"># (Objectively Down) state only if at least &lt;quorum&gt; sentinels agree.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Note that whatever is the ODOWN quorum, a Sentinel will require to</span><br><span class="hljs-comment"># be elected by the majority of the known Sentinels in order to</span><br><span class="hljs-comment"># start a failover, so no failover can be performed in minority.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Slaves are auto-discovered, so you don&#x27;t need to specify slaves in</span><br><span class="hljs-comment"># any way. Sentinel itself will rewrite this configuration file adding</span><br><span class="hljs-comment"># the slaves using additional configuration options.</span><br><span class="hljs-comment"># Also note that the configuration file is rewritten when a</span><br><span class="hljs-comment"># slave is promoted to master.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># <span class="hljs-doctag">Note:</span> master name should not include special characters or spaces.</span><br><span class="hljs-comment"># The valid charset is A-z 0-9 and the three characters &quot;.-_&quot;.</span><br><span class="hljs-attr">sentinel</span> <span class="hljs-string">monitor mymaster 127.0.0.1 6379 2</span><br><br><span class="hljs-comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Set the password to use to authenticate with the master and slaves.</span><br><span class="hljs-comment"># Useful if there is a password set in the Redis instances to monitor.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Note that the master password is also used for slaves, so it is not</span><br><span class="hljs-comment"># possible to set a different password in masters and slaves instances</span><br><span class="hljs-comment"># if you want to be able to monitor these instances with Sentinel.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># However you can have Redis instances without the authentication enabled</span><br><span class="hljs-comment"># mixed with Redis instances requiring the authentication (as long as the</span><br><span class="hljs-comment"># password set is the same for all the instances requiring the password) as</span><br><span class="hljs-comment"># the AUTH command will have no effect in Redis instances with authentication</span><br><span class="hljs-comment"># switched off.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Example:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><br><span class="hljs-comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Number of milliseconds the master (or any attached slave or sentinel) should</span><br><span class="hljs-comment"># be unreachable (as in, not acceptable reply to PING, continuously, for the</span><br><span class="hljs-comment"># specified period) in order to consider it in S_DOWN state (Subjectively</span><br><span class="hljs-comment"># Down).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Default is 30 seconds.</span><br><span class="hljs-attr">sentinel</span> <span class="hljs-string">down-after-milliseconds mymaster 30000</span><br><br><span class="hljs-comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># How many slaves we can reconfigure to point to the new slave simultaneously</span><br><span class="hljs-comment"># during the failover. Use a low number if you use the slaves to serve query</span><br><span class="hljs-comment"># to avoid that all the slaves will be unreachable at about the same</span><br><span class="hljs-comment"># time while performing the synchronization with the master.</span><br><span class="hljs-attr">sentinel</span> <span class="hljs-string">parallel-syncs mymaster 1</span><br><br><span class="hljs-comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Specifies the failover timeout in milliseconds. It is used in many ways:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># - The time needed to re-start a failover after a previous failover was</span><br><span class="hljs-comment">#   already tried against the same master by a given Sentinel, is two</span><br><span class="hljs-comment">#   times the failover timeout.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># - The time needed for a slave replicating to a wrong master according</span><br><span class="hljs-comment">#   to a Sentinel current configuration, to be forced to replicate</span><br><span class="hljs-comment">#   with the right master, is exactly the failover timeout (counting since</span><br><span class="hljs-comment">#   the moment a Sentinel detected the misconfiguration).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># - The time needed to cancel a failover that is already in progress but</span><br><span class="hljs-comment">#   did not produced any configuration change (SLAVEOF NO ONE yet not</span><br><span class="hljs-comment">#   acknowledged by the promoted slave).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># - The maximum time a failover in progress waits for all the slaves to be</span><br><span class="hljs-comment">#   reconfigured as slaves of the new master. However even after this time</span><br><span class="hljs-comment">#   the slaves will be reconfigured by the Sentinels anyway, but not with</span><br><span class="hljs-comment">#   the exact parallel-syncs progression as specified.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Default is 3 minutes.</span><br><span class="hljs-attr">sentinel</span> <span class="hljs-string">failover-timeout mymaster 180000</span><br><br><span class="hljs-comment"># SCRIPTS EXECUTION</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># sentinel notification-script and sentinel reconfig-script are used in order</span><br><span class="hljs-comment"># to configure scripts that are called to notify the system administrator</span><br><span class="hljs-comment"># or to reconfigure clients after a failover. The scripts are executed</span><br><span class="hljs-comment"># with the following rules for error handling:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If script exits with &quot;1&quot; the execution is retried later (up to a maximum</span><br><span class="hljs-comment"># number of times currently set to 10).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If script exits with &quot;2&quot; (or an higher value) the script execution is</span><br><span class="hljs-comment"># not retried.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If script terminates because it receives a signal the behavior is the same</span><br><span class="hljs-comment"># as exit code 1.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># A script has a maximum running time of 60 seconds. After this limit is</span><br><span class="hljs-comment"># reached the script is terminated with a SIGKILL and the execution retried.</span><br><br><span class="hljs-comment"># NOTIFICATION SCRIPT</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span><br><span class="hljs-comment"># </span><br><span class="hljs-comment"># Call the specified notification script for any sentinel event that is</span><br><span class="hljs-comment"># generated in the WARNING level (for instance -sdown, -odown, and so forth).</span><br><span class="hljs-comment"># This script should notify the system administrator via email, SMS, or any</span><br><span class="hljs-comment"># other messaging system, that there is something wrong with the monitored</span><br><span class="hljs-comment"># Redis systems.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The script is called with just two arguments: the first is the event type</span><br><span class="hljs-comment"># and the second the event description.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># The script must exist and be executable in order for sentinel to start if</span><br><span class="hljs-comment"># this option is provided.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Example:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># sentinel notification-script mymaster /var/redis/notify.sh</span><br><br><span class="hljs-comment"># CLIENTS RECONFIGURATION SCRIPT</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># When the master changed because of a failover a script can be called in</span><br><span class="hljs-comment"># order to perform application-specific tasks to notify the clients that the</span><br><span class="hljs-comment"># configuration has changed and the master is at a different address.</span><br><span class="hljs-comment"># </span><br><span class="hljs-comment"># The following arguments are passed to the script:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># &lt;state&gt; is currently always &quot;failover&quot;</span><br><span class="hljs-comment"># &lt;role&gt; is either &quot;leader&quot; or &quot;observer&quot;</span><br><span class="hljs-comment"># </span><br><span class="hljs-comment"># The arguments from-ip, from-port, to-ip, to-port are used to communicate</span><br><span class="hljs-comment"># the old address of the master and the new address of the elected slave</span><br><span class="hljs-comment"># (now a master).</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This script should be resistant to multiple invocations.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Example:</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br><br><span class="hljs-comment"># SECURITY</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># By default SENTINEL SET will not be able to change the notification-script</span><br><span class="hljs-comment"># and client-reconfig-script at runtime. This avoids a trivial security issue</span><br><span class="hljs-comment"># where clients can set the script to anything and trigger a failover in order</span><br><span class="hljs-comment"># to get the program executed.</span><br><br><span class="hljs-attr">sentinel</span> <span class="hljs-string">deny-scripts-reconfig yes</span><br></code></pre></td></tr></table></figure><h2 id="搭建-Redis-集群"><a href="#搭建-Redis-集群" class="headerlink" title="搭建 Redis 集群"></a>搭建 Redis 集群</h2><ul><li><p>搭建一主两从环境，docker-compose.yml 配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.1&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">sentinel1:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">redis-sentinel-1</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">26379</span><span class="hljs-string">:26379</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">redis-sentinel</span> <span class="hljs-string">/usr/local/etc/redis/sentinel.conf</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./sentinel1.conf:/usr/local/etc/redis/sentinel.conf</span><br><br>  <span class="hljs-attr">sentinel2:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">redis-sentinel-2</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">26380</span><span class="hljs-string">:26379</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">redis-sentinel</span> <span class="hljs-string">/usr/local/etc/redis/sentinel.conf</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./sentinel2.conf:/usr/local/etc/redis/sentinel.conf</span><br><br>  <span class="hljs-attr">sentinel3:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">redis</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">redis-sentinel-3</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">26381</span><span class="hljs-string">:26379</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">redis-sentinel</span> <span class="hljs-string">/usr/local/etc/redis/sentinel.conf</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./sentinel3.conf:/usr/local/etc/redis/sentinel.conf</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="搭建-Sentinel-集群"><a href="#搭建-Sentinel-集群" class="headerlink" title="搭建 Sentinel 集群"></a>搭建 Sentinel 集群</h2><ul><li><p>我们至少需要创建三个 Sentinel 服务，docker-compose.yml 配置如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs awk">version: <span class="hljs-string">&#x27;3.1&#x27;</span><br>services:<br>  sentinel1:<br>    image: redis<br>    container_name: redis-sentinel-<span class="hljs-number">1</span><br>    ports:<br>      - <span class="hljs-number">26379</span>:<span class="hljs-number">26379</span><br>    command: redis-sentinel <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/etc/</span>redis/sentinel.conf<br>    volumes:<br>      - .<span class="hljs-regexp">/sentinel1.conf:/u</span>sr<span class="hljs-regexp">/local/</span>etc<span class="hljs-regexp">/redis/</span>sentinel.conf<br><br>  sentinel2:<br>    image: redis<br>    container_name: redis-sentinel-<span class="hljs-number">2</span><br>    ports:<br>      - <span class="hljs-number">26380</span>:<span class="hljs-number">26379</span><br>    command: redis-sentinel <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/etc/</span>redis/sentinel.conf<br>    volumes:<br>      - .<span class="hljs-regexp">/sentinel2.conf:/u</span>sr<span class="hljs-regexp">/local/</span>etc<span class="hljs-regexp">/redis/</span>sentinel.conf<br><br>  sentinel3:<br>    image: redis<br>    container_name: redis-sentinel-<span class="hljs-number">3</span><br>    ports:<br>      - <span class="hljs-number">26381</span>:<span class="hljs-number">26379</span><br>    command: redis-sentinel <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/etc/</span>redis/sentinel.conf<br>    volumes:<br>      - .<span class="hljs-regexp">/sentinel3.conf:/u</span>sr<span class="hljs-regexp">/local/</span>etc<span class="hljs-regexp">/redis/</span>sentinel.conf<br></code></pre></td></tr></table></figure></li></ul><h3 id="修改-Sentinel-配置文件"><a href="#修改-Sentinel-配置文件" class="headerlink" title="修改 Sentinel 配置文件"></a>修改 Sentinel 配置文件</h3><ul><li><p>需要三份 sentinel.conf 配置文件，分别为 <code>sentinel1.conf</code>，<code>sentinel2.conf</code>，<code>sentinel3.conf</code>，配置文件内容相同</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs smali">port 26379<br>dir /tmp<br><span class="hljs-comment"># 自定义集群名，其中 127.0.0.1 为 redis-master 的 ip，6379 为 redis-master 的端口，2 为最小投票数（因为有 3 台 Sentinel 所以可以设置成 2）</span><br>sentinel<span class="hljs-built_in"> monitor </span>mymaster 127.0.0.1 6379 2<br>sentinel down-after-milliseconds mymaster 30000<br>sentinel parallel-syncs mymaster 1<br>sentinel failover-timeout mymaster 180000<br>sentinel deny-scripts-reconfig yes<br></code></pre></td></tr></table></figure></li></ul><h3 id="查看集群是否生效"><a href="#查看集群是否生效" class="headerlink" title="查看集群是否生效"></a>查看集群是否生效</h3><ul><li><p>进入 Sentinel 容器，使用 Sentinel API 查看监控情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it redis-sentinel-1 /bin/bash<br>redis-cli -p 26379<br>sentinel master mymaster<br>sentinel slaves mymaster<br></code></pre></td></tr></table></figure></li><li><p>输出如下</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">26379</span>&gt; sentinel master mymaster<br> <span class="hljs-attribute">1</span>) <span class="hljs-string">&quot;name&quot;</span><br> <span class="hljs-attribute">2</span>) <span class="hljs-string">&quot;mymaster&quot;</span><br> <span class="hljs-attribute">3</span>) <span class="hljs-string">&quot;ip&quot;</span><br> <span class="hljs-attribute">4</span>) <span class="hljs-string">&quot;127.0.0.1&quot;</span><br> <span class="hljs-attribute">5</span>) <span class="hljs-string">&quot;port&quot;</span><br> <span class="hljs-attribute">6</span>) <span class="hljs-string">&quot;6379&quot;</span><br> <span class="hljs-attribute">7</span>) <span class="hljs-string">&quot;runid&quot;</span><br> <span class="hljs-attribute">8</span>) <span class="hljs-string">&quot;&quot;</span><br> <span class="hljs-attribute">9</span>) <span class="hljs-string">&quot;flags&quot;</span><br><span class="hljs-attribute">10</span>) <span class="hljs-string">&quot;s_down,master,disconnected&quot;</span><br><span class="hljs-attribute">11</span>) <span class="hljs-string">&quot;link-pending-commands&quot;</span><br><span class="hljs-attribute">12</span>) <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-attribute">13</span>) <span class="hljs-string">&quot;link-refcount&quot;</span><br><span class="hljs-attribute">14</span>) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-attribute">15</span>) <span class="hljs-string">&quot;last-ping-sent&quot;</span><br><span class="hljs-attribute">16</span>) <span class="hljs-string">&quot;11379728&quot;</span><br><span class="hljs-attribute">17</span>) <span class="hljs-string">&quot;last-ok-ping-reply&quot;</span><br><span class="hljs-attribute">18</span>) <span class="hljs-string">&quot;11379728&quot;</span><br><span class="hljs-attribute">19</span>) <span class="hljs-string">&quot;last-ping-reply&quot;</span><br><span class="hljs-attribute">20</span>) <span class="hljs-string">&quot;11379728&quot;</span><br><span class="hljs-attribute">21</span>) <span class="hljs-string">&quot;s-down-time&quot;</span><br><span class="hljs-attribute">22</span>) <span class="hljs-string">&quot;11349688&quot;</span><br><span class="hljs-attribute">23</span>) <span class="hljs-string">&quot;down-after-milliseconds&quot;</span><br><span class="hljs-attribute">24</span>) <span class="hljs-string">&quot;30000&quot;</span><br><span class="hljs-attribute">25</span>) <span class="hljs-string">&quot;info-refresh&quot;</span><br><span class="hljs-attribute">26</span>) <span class="hljs-string">&quot;1571133490553&quot;</span><br><span class="hljs-attribute">27</span>) <span class="hljs-string">&quot;role-reported&quot;</span><br><span class="hljs-attribute">28</span>) <span class="hljs-string">&quot;master&quot;</span><br><span class="hljs-attribute">29</span>) <span class="hljs-string">&quot;role-reported-time&quot;</span><br><span class="hljs-attribute">30</span>) <span class="hljs-string">&quot;11379728&quot;</span><br><span class="hljs-attribute">31</span>) <span class="hljs-string">&quot;config-epoch&quot;</span><br><span class="hljs-attribute">32</span>) <span class="hljs-string">&quot;0&quot;</span><br><span class="hljs-attribute">33</span>) <span class="hljs-string">&quot;num-slaves&quot;</span><br><span class="hljs-attribute">34</span>) <span class="hljs-string">&quot;0&quot;</span><br><span class="hljs-attribute">35</span>) <span class="hljs-string">&quot;num-other-sentinels&quot;</span><br><span class="hljs-attribute">36</span>) <span class="hljs-string">&quot;0&quot;</span><br><span class="hljs-attribute">37</span>) <span class="hljs-string">&quot;quorum&quot;</span><br><span class="hljs-attribute">38</span>) <span class="hljs-string">&quot;2&quot;</span><br><span class="hljs-attribute">39</span>) <span class="hljs-string">&quot;failover-timeout&quot;</span><br><span class="hljs-attribute">40</span>) <span class="hljs-string">&quot;180000&quot;</span><br><span class="hljs-attribute">41</span>) <span class="hljs-string">&quot;parallel-syncs&quot;</span><br><span class="hljs-attribute">42</span>) <span class="hljs-string">&quot;1&quot;</span><br><span class="hljs-attribute">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">26379</span>&gt;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>PaaS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>docker</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决Linux下Harbor开机启动失败</title>
    <link href="/2019/09/14/cicd/%E8%A7%A3%E5%86%B3Linux%E4%B8%8BHarbor%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5/"/>
    <url>/2019/09/14/cicd/%E8%A7%A3%E5%86%B3Linux%E4%B8%8BHarbor%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5/</url>
    
    <content type="html"><![CDATA[<p>Harbor 是一个用于存储和分发 Docker 镜像的企业级 Registry 服务器，通过添加一些企业必需的功能特性，例如安全、标识和管理等，扩展了开源 Docker Distribution。作为一个企业级私有 Registry 服务器，Harbor 提供了更好的性能和安全。提升用户使用 Registry 构建和运行环境传输镜像的效率。Harbor 支持安装在多个 Registry 节点的镜像资源复制，镜像全部保存在私有 Registry 中， 确保数据和知识产权在公司内部网络中管控。另外，Harbor 也提供了高级的安全特性，诸如用户管理，访问控制和活动审计等。</p><span id="more"></span><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>安装参见官方文档：<a href="https://github.com/goharbor/harbor/blob/master/docs/installation_guide.md">Harbor - Installation and Configuration Guide</a>，  </p><p>修改 <code>harbor.yml</code> 时，需要注意的有：</p><ol><li>使用 https 时，要自己生成证书，然后在 <code>harbor.yml</code> 里配置好证书的路径。<ul><li>客户端也需要安装你生成的这个证书，否则会报错。（所以证书要做好备份）</li><li>详见 <a href="https://docs.docker.com/registry/insecure/">Docker - Use self-signed certificates</a></li></ul></li><li><code>data_volume</code> 可以指定为 <code>/data/harbor</code>，然后要定期备份这个文件夹。（或者直接在新机器上装个 harbor，用 harbor 自带的仓库复制功能做定期备份。）</li><li>企业的话，可能还需要配置 ldap 集成验证。</li></ol><p>然后赋权<code>sudo chomod +x ./install.sh</code></p><p>执行 <code>sudo ./install.sh</code> 安装 harbor（貌似必须用 sudo，因为生成出来的配置文件的 owner 都是 root，而且权限设得很严格。）  </p><p>安装完成后会自动启动 harbor.</p><h1 id="自动启动"><a href="#自动启动" class="headerlink" title="自动启动"></a>自动启动</h1><p>查看 harbor 目录下的自动生成的 <code>docker-compose.yml</code> 会发现，所有的 <code>containers</code> 都配置了 <code>restart: always</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;2.3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">log:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">goharbor/harbor-log:v1.9.0</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">harbor-log</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br><br><span class="hljs-string">·····省略·······</span><br><br>  <span class="hljs-attr">proxy:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">goharbor/nginx-photon:v1.9.0</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">cap_drop:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ALL</span><br>    <span class="hljs-attr">cap_add:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">CHOWN</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">SETGID</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">SETUID</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">NET_BIND_SERVICE</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./common/config/nginx:/etc/nginx:z</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">harbor</span><br>    <span class="hljs-attr">dns_search:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">9090</span><span class="hljs-string">:8080</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">registry</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">core</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">portal</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">log</span><br>    <span class="hljs-attr">logging:</span><br>      <span class="hljs-attr">driver:</span> <span class="hljs-string">&quot;syslog&quot;</span><br>      <span class="hljs-attr">options:</span><br>        <span class="hljs-attr">syslog-address:</span> <span class="hljs-string">&quot;tcp://127.0.0.1:1514&quot;</span><br>        <span class="hljs-attr">tag:</span> <span class="hljs-string">&quot;proxy&quot;</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">harbor:</span><br>    <span class="hljs-attr">external:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>这表示所有的容器在<strong>意外关闭</strong>后都会自动重启，比如 <code>docker</code> 重启或服务器重启。（手动 <code>stop</code> 不会自动重启）</p><p>但是我在手动运行 <code>docker-compose up -d</code>，然后重启服务器后，发现有几个 container 并没有自动重启：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs armasm">[ryan<span class="hljs-comment">@ryan-pc ~]$ docker ps -a</span><br><span class="hljs-symbol">CONTAINER</span> ID        IMAGE                                               COMMAND                  CREATED             STATUS                             PORTS                       NAMES<br><span class="hljs-symbol">f30d802002a4</span>        goharbor/nginx-photon:<span class="hljs-built_in">v1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">1</span>                        <span class="hljs-string">&quot;nginx -g &#x27;daemon of…&quot;</span>   <span class="hljs-number">13</span> hours ago        Exited (<span class="hljs-number">128</span>) <span class="hljs-number">27</span> minutes ago        <span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>:<span class="hljs-number">80</span>-&gt;<span class="hljs-number">80</span>/tcp          nginx<br><span class="hljs-number">21472</span>ce8a993        goharbor/harbor-portal:<span class="hljs-built_in">v1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">1</span>                       <span class="hljs-string">&quot;nginx -g &#x27;daemon of…&quot;</span>   <span class="hljs-number">13</span> hours ago        Exited (<span class="hljs-number">128</span>) <span class="hljs-number">27</span> minutes ago        <span class="hljs-number">80</span>/tcp                      harbor-portal<br><span class="hljs-number">5</span>d866bb17c58        goharbor/harbor-jobservice:<span class="hljs-built_in">v1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">1</span>                   <span class="hljs-string">&quot;/harbor/start.sh&quot;</span>       <span class="hljs-number">13</span> hours ago        Exited (<span class="hljs-number">137</span>) <span class="hljs-number">26</span> minutes ago                                    harbor-jobservice<br><span class="hljs-number">0</span>cf0f93b5a87        goharbor/harbor-core:<span class="hljs-built_in">v1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">1</span>                         <span class="hljs-string">&quot;/harbor/start.sh&quot;</span>       <span class="hljs-number">13</span> hours ago        Up <span class="hljs-number">11</span> seconds (health: starting)                               harbor-core<br><span class="hljs-symbol">cba280d9b945</span>        goharbor/redis-photon:<span class="hljs-built_in">v1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">1</span>                        <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   <span class="hljs-number">13</span> hours ago        Exited (<span class="hljs-number">137</span>) <span class="hljs-number">26</span> minutes ago        <span class="hljs-number">6379</span>/tcp                    redis<br><span class="hljs-number">473</span>e46d1f746        goharbor/harbor-registryctl:<span class="hljs-built_in">v1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">1</span>                  <span class="hljs-string">&quot;/harbor/start.sh&quot;</span>       <span class="hljs-number">13</span> hours ago        Up <span class="hljs-number">11</span> seconds (health: starting)                               registryctl<br><span class="hljs-number">51</span>f105f1691d        goharbor/registry-photon:<span class="hljs-built_in">v2</span>.<span class="hljs-number">7</span>.<span class="hljs-number">1</span>-patch-<span class="hljs-number">2819</span>-<span class="hljs-built_in">v1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">1</span>   <span class="hljs-string">&quot;/entrypoint.sh /etc…&quot;</span>   <span class="hljs-number">13</span> hours ago        Exited (<span class="hljs-number">137</span>) <span class="hljs-number">26</span> minutes ago        <span class="hljs-number">5000</span>/tcp                    registry<br><span class="hljs-symbol">c41594ec7779</span>        goharbor/harbor-db:<span class="hljs-built_in">v1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">1</span>                           <span class="hljs-string">&quot;/entrypoint.sh post…&quot;</span>   <span class="hljs-number">13</span> hours ago        Up <span class="hljs-number">11</span> seconds (health: starting)   <span class="hljs-number">5432</span>/tcp                    harbor-db<br><span class="hljs-number">713</span>bd4961772        goharbor/harbor-log:<span class="hljs-built_in">v1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">1</span>                          <span class="hljs-string">&quot;/bin/sh -c /usr/loc…&quot;</span>   <span class="hljs-number">13</span> hours ago        Up <span class="hljs-number">11</span> seconds (health: starting)   <span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">1514</span>-&gt;<span class="hljs-number">10514</span>/tcp   harbor-log<br></code></pre></td></tr></table></figure><p>可以看到下列五个容器都处于 Exited 状态：</p><ol><li><code>goharbor/nginx-photon:v1.8.1</code></li><li><code>goharbor/harbor-portal:v1.8.1</code></li><li><code>goharbor/harbor-jobservice:v1.8.1</code></li><li><code>goharbor/redis-photon:v1.8.1</code></li><li><code>goharbor/registry-photon:v2.7.1-patch-2819-v1.8.1</code></li></ol><p>搜索发现有人提过这个 <code>issue</code>: <a href="https://github.com/goharbor/harbor/issues/7008">https://github.com/goharbor/harbor/issues/7008</a></p><p>于是尝试将 harbor 配成<strong><code>systemd</code></strong>的服务，添加配置文件 <code>/lib/systemd/system/harbor.service</code>，内容如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">[Unit]</span><br><span class="hljs-attr">Description</span>=<span class="hljs-string">Harbor</span><br><span class="hljs-attr">After</span>=<span class="hljs-string">docker.service systemd-networkd.service systemd-resolved.service</span><br><span class="hljs-attr">Requires</span>=<span class="hljs-string">docker.service</span><br><span class="hljs-attr">Documentation</span>=<span class="hljs-string">http://github.com/vmware/harbor</span><br><br><span class="hljs-attr">[Service]</span><br><span class="hljs-attr">Type</span>=<span class="hljs-string">simple</span><br><span class="hljs-attr">Restart</span>=<span class="hljs-string">on-failure</span><br><span class="hljs-attr">RestartSec</span>=<span class="hljs-string">5</span><br><span class="hljs-attr">ExecStart</span>=<span class="hljs-string">/usr/local/bin/docker-compose -f $harbor_path/harbor/docker-compose.yml up</span><br><span class="hljs-attr">ExecStop</span>=<span class="hljs-string">/usr/local/bin/docker-compose -f $harbor_path/harbor/docker-compose.yml down</span><br><br><span class="hljs-attr">[Install]</span><br><span class="hljs-attr">WantedBy</span>=<span class="hljs-string">multi-user.target</span><br></code></pre></td></tr></table></figure><p>其中<strong><code>$harbor_path</code></strong> 换成自己的 harbor 安装路径。  </p><p>还有 docker-compose 的绝对路径，请通过 <code>which docker-compose</code> 查看，默认路径为<code>/usr/local/bin/docker-compose</code>。</p><p>此时通过<code>docker-compose down</code>关闭harbor</p><p>然后通过systemd设置为开机启动并启动该项服务：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">sudo systemctl <span class="hljs-keyword">enable</span> harbor<br>sudo systemctl <span class="hljs-keyword">start</span> harbor<br></code></pre></td></tr></table></figure><p>若提示找不到<code>harbor.servce</code>，则执行<code>systemctl daemon-reload</code>重启<code>systemd</code>服务</p><p><code>systemctl status harobr</code>查看 <code>harbor.service</code> 的情况：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">● harbor.service - Harbor<br>   Loaded: loaded (<span class="hljs-regexp">/lib/</span>systemd<span class="hljs-regexp">/system/</span>harbor.service; enabled; vendor preset: enabled)<br>   Active: active (running) since Mon <span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">14</span> <span class="hljs-number">18</span>:<span class="hljs-number">55</span>:<span class="hljs-number">28</span> CST; <span class="hljs-number">49</span>s ago<br>     Docs: http:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/vmware/</span>harbor<br> Main PID: <span class="hljs-number">15706</span> (docker-compose)<br>    Tasks: <span class="hljs-number">12</span> (limit: <span class="hljs-number">2312</span>)<br>   CGroup: <span class="hljs-regexp">/system.slice/</span>harbor.service<br>           ├─<span class="hljs-number">15706</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-compose -f <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/harbor/</span>harbor/docker-compose.yml up<br>           └─<span class="hljs-number">15717</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>docker-compose -f <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/harbor/</span>harbor/docker-compose.yml up<br><br>.....省略.....<br></code></pre></td></tr></table></figure><p>状态为：<code>active</code></p><p>重启再看，发现 harbor 容器组终于全部 up 了：</p><p><code>docker-compose ps</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">      Name                     Command                  State                 Ports<br>---------------------------------------------------------------------------------------------<br>harbor-core         <span class="hljs-regexp">/harbor/</span>harbor_core              Up (healthy)<br>harbor-db           <span class="hljs-regexp">/docker-entrypoint.sh            Up (healthy)   5432/</span>tcp<br>harbor-jobservice   <span class="hljs-regexp">/harbor/</span>harbor_jobservice  ...   Up (healthy)<br>harbor-log          <span class="hljs-regexp">/bin/</span>sh -c <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span> ...   Up (healthy)   <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">1514</span>-&gt;<span class="hljs-number">10514</span>/tcp<br>harbor-portal       nginx -g daemon off;             Up (healthy)   <span class="hljs-number">8080</span>/tcp<br>nginx               nginx -g daemon off;             Up (healthy)   <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">9090</span>-&gt;<span class="hljs-number">8080</span>/tcp<br>redis               redis-server <span class="hljs-regexp">/etc/</span>redis.conf     Up (healthy)   <span class="hljs-number">6379</span>/tcp<br>registry            <span class="hljs-regexp">/entrypoint.sh /</span>etc<span class="hljs-regexp">/regist ...   Up (healthy)   5000/</span>tcp<br>registryctl         <span class="hljs-regexp">/harbor/</span>start.sh                 Up (healthy)<br></code></pre></td></tr></table></figure><p>Web端Harbor也可正常访问:</p><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/MFGgetjQuJ5NPCA-20210224210941379.png" alt="image.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/goharbor/harbor/issues/7008">Harbor containers fail to start on docker startup</a></li><li><a href="https://www.cnblogs.com/kirito-c/p/10331598.html">通过 systemctl 设置自定义 Service</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PaaS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>docker</tag>
      
      <tag>harbor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS7下离线安装MySQL5.7</title>
    <link href="/2019/09/10/linux/CentOS7%E4%B8%8B%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85MySQL5.7/"/>
    <url>/2019/09/10/linux/CentOS7%E4%B8%8B%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85MySQL5.7/</url>
    
    <content type="html"><![CDATA[<h1 id="CentOS7下离线安装MySQL5-7"><a href="#CentOS7下离线安装MySQL5-7" class="headerlink" title="CentOS7下离线安装MySQL5.7"></a>CentOS7下离线安装MySQL5.7</h1><p>😭客户现场没有互联网，需要在 <code>CentOS</code> 系统的测试服务器上安装 <code>MySQL</code> </p><p><strong>本文适用于服务器不能联网的情况下的安装操作</strong></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h2><table><thead><tr><th>项目</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td>操作系统</td><td>CentOS 7.2.1511 x86_64</td><td>最小化安装</td></tr><tr><td>MySQL</td><td>Community 5.7.18-1.el7.x86_64</td><td>rpm 包</td></tr></tbody></table><p>注：可以使用 <code>cat /etc/redhat-release</code> 命令，来确定自己安装的 CentOS 的具体版本。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li><p>下载 <code>MySQL</code> 的安装包，这里推荐使用搜狐的镜像站下载，因为从 MySQL 官网下载的速度实在感人，<a href="http://mirrors.sohu.com/mysql/MySQL-5.7/">镜像地址</a> 选择对应的版本号下载即可。我在此使用的 rpm 包有以下 4 个：</p><ul><li><p>mysql-community-client-5.7.18-1.el7.x86_64.rpm</p></li><li><p>mysql-community-common-5.7.18-1.el7.x86_64.rpm</p></li><li><p>mysql-community-libs-5.7.18-1.el7.x86_64.rpm</p></li><li><p>mysql-community-server-5.7.18-1.el7.x86_64.rpm</p></li></ul></li></ul><pre><code>以上四个 rpm 包是必须的，如果还需要其他的功能，可以自行进行下载。以当前版本为例，包含全部的 rpm 包的文件为`mysql-5.7.18-1.el7.x86_64.rpm-bundle.tar`</code></pre><ul><li><p>下载 <code>numactl</code> 软件包：</p><ul><li><p><code>numactl-2.0.9-6.el7_2.x86_64.rpm</code></p></li><li><p><code>numactl-devel-2.0.9-6.el7_2.x86_64.rpm</code></p></li><li><p><code>numactl-libs-2.0.9-6.el7_2.x86_64.rpm</code></p></li></ul></li><li><p>下载其他相关支持：</p><ul><li><p><code>perl-Data-Dumper-2.145-3.el7.x86_64.rpm</code></p></li><li><p><code>libaio-0.3.109-13.el7.x86_64.rpm</code></p></li></ul></li></ul><pre><code>以上软件包是待会儿要用到的，请提前准备好。这个软件包网上直接搜索就能下载得到，这里提供一个下载地址[下载地址](http://rpmfind.net/linux/rpm2html/) 直接在搜索框搜索即可，下载时注意看版本号和位数（64 位）</code></pre><ul><li>将下载好的软件包一并上传到服务器上，准备安装。</li></ul><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><p>以下只是我的安装顺序，其实这些软件包的安装顺序没有太多明确的要求，不一定非要按以下顺序安装，但是可以会有一些相关的依赖问题，如果抛出依赖相关的错误，只要把上边对应的依赖安装上在重试一次即可。</p><ul><li><p>安装 <code>libaio-0.3.109-13.el7.x86_64.rpm</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">rpm</span> -ivh libaio-<span class="hljs-number">0</span>.<span class="hljs-number">3</span>.<span class="hljs-number">109</span>-<span class="hljs-number">13</span>.el<span class="hljs-number">7</span>.x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>.rpm<br></code></pre></td></tr></table></figure></li><li><p>安装<code>perl-Data-Dumper-2.145-3.el7.x86_64.rpm</code></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">rpm</span> -ivh perl-Data-Dumper-<span class="hljs-number">2</span>.<span class="hljs-number">145</span>-<span class="hljs-number">3</span>.el<span class="hljs-number">7</span>.x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>.rpm<br></code></pre></td></tr></table></figure><p>以上这两项安装时我并没有遇到依赖问题，如果在实际安装时遇到了，请查看相关提示，在下载对应的包安装即可。</p></li><li><p>安装<code>numactl</code>相关</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">rpm</span> -ivh numactl*<br></code></pre></td></tr></table></figure><p>如果不安装此包，我们将会得到如下错误</p><blockquote><p>error: Failed dependencies:<br>libnuma.so.1()(64bit) is needed by mysql-community-server-5.7.18-1.el7.x86_64<br>libnuma.so.1(libnuma_1.1)(64bit) is needed by mysql-community-server-5.7.18-1.el7.x86_64<br>libnuma.so.1(libnuma_1.2)(64bit) is needed by mysql-community-server-5.7.18-1.el7.x86_64</p></blockquote></li><li><p>若此时直接安装 mysql，我们会得到一个异常：</p><blockquote><p>warning: mysql-community-libs-5.7.18-1.el7.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY error: Failed dependencies:<br>mysql-community-common(x86-64) &gt;= 5.7.9 is needed by mysql-community-libs-5.7.18-1.el7.x86_64<br>mariadb-libs is obsoleted by mysql-community-libs-5.7.18-1.el7.x86_64</p></blockquote></li></ul><p>第一行还能看明白，是依赖问题，第二行的 “mariadb-libs 被废弃” 是什么鬼？废弃了为什么不提供一个新的还要出现这种弱智提示呢？经过一番搜寻，才发现是因为在 CentOS 7 上已经有一个<code>mariadb</code> 而这个会与 <code>MySQL</code>的<code>mariadb</code>发生冲突。所以此时我们需要将系统自带的<code>mariadb</code>卸载掉，然后使用 mysql 自带的<code>mariadb</code>。</p><p>我们先来查看系统安装的版本<code>rpm -qa | grep mariadb</code>, 随后进行卸载，卸载的过程中会提示不能卸载，因为有其他软件依赖此包，我们要加上 <code>--nodeps</code> 参数强制卸载</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">rpm</span> -e --nodeps mariadb-libs-<span class="hljs-number">5</span>.<span class="hljs-number">5</span>.<span class="hljs-number">37</span>-<span class="hljs-number">1</span>.el<span class="hljs-number">7</span>_<span class="hljs-number">0</span>.x<span class="hljs-number">86</span>_<span class="hljs-number">64</span><br></code></pre></td></tr></table></figure><p>注意我上述写的 <code>mariadb-libs-5.5.37-1.el7_0.x86_64</code> 是我刚刚用<code>rpm -qa | grep mariadb</code>查询出的结果。不同版本可能会有所不同。</p><ul><li>解决好这个问题后，就可以安装 mysql 了，<code>rpm -ivh mysql-community-*</code> 即可。</li></ul><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>使用 <code>service mysqld start</code> 命令启动 mysql 实例，为了验证，我们使用<code>service mysqld status</code>验证一下。输出结果如下：</p><blockquote><p>Redirecting to /bin/systemctl status mysqld.service<br>● mysqld.service - MySQL Server<br>Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled)<br>Active: active (<strong><em>running</em></strong>) since Mon 2017-07-03 15:39:02 CST; 5s ago</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">Docs: man:mysqld(<span class="hljs-number">8</span>)<br>   http:<span class="hljs-regexp">//</span>dev.mysql.com<span class="hljs-regexp">/doc/</span>refman<span class="hljs-regexp">/en/u</span>sing-systemd.html<br></code></pre></td></tr></table></figure><p>Process: 28054 ExecStart=/usr/sbin/mysqld –daemonize –pid-file=/var/run/mysqld/mysqld.pid $MYSQLD_OPTS (code=exited, status=0/SUCCESS)<br>Process: 27978 ExecStartPre=/usr/bin/mysqld_pre_systemd (code=exited, status=0/SUCCESS)<br>Main PID: 28056 (mysqld)<br>CGroup: /system.slice/mysqld.service</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">└─<span class="hljs-number">28056</span> <span class="hljs-regexp">/usr/</span>sbin<span class="hljs-regexp">/mysqld --daemonize --pid-file=/</span>var<span class="hljs-regexp">/run/my</span>sqld/mysqld.pid<br></code></pre></td></tr></table></figure><p>Jul 03 15:38:57 nodemaster systemd[1]: Starting MySQL Server…<br>Jul 03 15:39:02 nodemaster systemd[1]: Started MySQL Server.</p></blockquote><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>我们使用 <code>mysql -u root</code>时会提示我们要输入密码，这个密码存储在 <code>/var/log/mysqld.log</code> 文件内，是系统自动生成的。我们可以使用 <code>cat /var/log/mysqld.log | grep password</code> 命令将密码找出来，然后填入，进行登录，登录之后进行修改密码等操作。这些操作在官方文档上都有详细的说明，可以自行查看。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS7 &amp; Ubuntu 18 时间设置</title>
    <link href="/2019/08/30/linux/CentOS7-Ubuntu-18-%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE/"/>
    <url>/2019/08/30/linux/CentOS7-Ubuntu-18-%E6%97%B6%E9%97%B4%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><h3 id="1-1-GMT、UTC、CST、DST-时间"><a href="#1-1-GMT、UTC、CST、DST-时间" class="headerlink" title="1.1 GMT、UTC、CST、DST 时间"></a>1.1 GMT、UTC、CST、DST 时间</h3><ul><li>UTC</li></ul><p>整个地球分为二十四时区，每个时区都有自己的本地时间。在国际无线电通信场合，为了统一起见，使用一个统一的时间，称为通用协调时(UTC, Universal Time Coordinated)。</p><ul><li>GMT</li></ul><p>格林威治标准时间 (Greenwich Mean Time)指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。(UTC与GMT时间基本相同，本文中不做区分)</p><ul><li>CST</li></ul><p>中国标准时间 (China Standard Time)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">GMT + 8 &#x3D; UTC + 8 &#x3D; CST<br></code></pre></td></tr></table></figure><ul><li>DST</li></ul><p>夏令时(Daylight Saving Time) 指在夏天太阳升起的比较早时，将时间拨快一小时，以提早日光的使用。（中国不使用）</p><span id="more"></span><h3 id="1-2-硬件时间和系统时间"><a href="#1-2-硬件时间和系统时间" class="headerlink" title="1.2 硬件时间和系统时间"></a>1.2 硬件时间和系统时间</h3><ul><li>硬件时间</li></ul><p>RTC(Real-Time Clock)或CMOS时间，一般在主板上靠电池供电，服务器断电后也会继续运行。仅保存日期时间数值，无法保存时区和夏令时设置。</p><ul><li>系统时间</li></ul><p>一般在服务器启动时复制RTC时间，之后独立运行，保存了时间、时区和夏令时设置。</p><h2 id="2-timedatectl-命令"><a href="#2-timedatectl-命令" class="headerlink" title="2. timedatectl 命令"></a>2. timedatectl 命令</h2><h3 id="2-1-使用帮助"><a href="#2-1-使用帮助" class="headerlink" title="2.1 使用帮助"></a>2.1 使用帮助</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">[<span class="hljs-symbol">root@</span>localhost ~]# timedatectl -h<br>timedatectl [OPTIONS...] COMMAND ...<br><br>Query or change system time and date settings.<br><br>  -h --help              Show <span class="hljs-keyword">this</span> help<br>     --version           Show <span class="hljs-keyword">package</span> version<br>     --adjust-system-clock<br>                         Adjust system clock <span class="hljs-keyword">when</span> changing local RTC mode<br>     --no-pager          Do not pipe output into a pager<br>  -P --privileged        Acquire privileges before execution<br>     --no-ask-password   Do not prompt <span class="hljs-keyword">for</span> password<br>  -H --host=[<span class="hljs-symbol">USER@</span>]HOST  Operate on remote host<br><br>Commands:<br>  status                 Show current time settings<br>  <span class="hljs-keyword">set</span>-time TIME          Set system time<br>  <span class="hljs-keyword">set</span>-timezone ZONE      Set system timezone<br>  list-timezones         Show known timezones<br>  <span class="hljs-keyword">set</span>-local-rtc BOOL     Control whether RTC <span class="hljs-keyword">is</span> <span class="hljs-keyword">in</span> local time<br>  <span class="hljs-keyword">set</span>-ntp BOOL           Control whether NTP <span class="hljs-keyword">is</span> enabled<br></code></pre></td></tr></table></figure><h3 id="2-2-命令示例"><a href="#2-2-命令示例" class="headerlink" title="2.2 命令示例"></a>2.2 命令示例</h3><p>1.显示系统的当前时间和日期</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">timedatectl<br><span class="hljs-comment"># timedatectl status</span><br><span class="hljs-comment"># 两条命令效果等同</span><br></code></pre></td></tr></table></figure><p>2.设置日期与时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">timedatectl set-time <span class="hljs-string">&quot;YYYY-MM-DD HH:MM:SS&quot;</span><br>timedatectl set-time <span class="hljs-string">&quot;YYYY-MM-DD&quot;</span><br>timedatectl set-time <span class="hljs-string">&quot;HH:MM:SS&quot;</span><br></code></pre></td></tr></table></figure><p>3.查看所有可用的时区</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php">timedatectl <span class="hljs-keyword">list</span>-timezones<br><span class="hljs-comment"># 亚洲</span><br>timedatectl <span class="hljs-keyword">list</span>-timezones |  grep  -E <span class="hljs-string">&quot;Asia/S.*&quot;</span><br></code></pre></td></tr></table></figure><p>4.设置时区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">timedatectl set-timezone Asia/Shanghai<br></code></pre></td></tr></table></figure><p>5.设置硬件时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 硬件时间默认为UTC</span><br>timedatectl set-local-rtc 1<br><span class="hljs-comment"># hwclock --systohc --localtime</span><br><span class="hljs-comment"># 两条命令效果等同</span><br></code></pre></td></tr></table></figure><p>6.启用时间同步</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">timedatectl set-ntp yes<br><span class="hljs-comment"># yes或no; 1或0也可以</span><br></code></pre></td></tr></table></figure><h2 id="3-Chrony-服务"><a href="#3-Chrony-服务" class="headerlink" title="3. Chrony 服务"></a>3. Chrony 服务</h2><p>Chrony是网络时间协议的 (NTP) 的另一种实现，由两个程序组成，分别是chronyd和chronyc。</p><p>chronyd是一个后台运行的守护进程，用于调整内核中运行的系统时钟和时钟服务器同步。它确定计算机增减时间的比率，并对此进行补偿。</p><p>chronyc提供了一个用户界面，用于监控性能并进行多样化的配置。它可以在chronyd实例控制的计算机上工作，也可以在一台不同的远程计算机上工作。</p><p>优势：</p><ul><li>更快的同步只需要数分钟而非数小时时间，从而最大程度减少了时间和频率误差，这对于并非全天 24 小时运行的台式计算机或系统而言非常有用。</li><li>能够更好地响应时钟频率的快速变化，这对于具备不稳定时钟的虚拟机或导致时钟频率发生变化的节能技术而言非常有用。</li><li>在初始同步后，它不会停止时钟，以防对需要系统时间保持单调的应用程序造成影响。</li><li>在应对临时非对称延迟时（例如，在大规模下载造成链接饱和时）提供了更好的稳定性。</li><li>无需对服务器进行定期轮询，因此具备间歇性网络连接的系统仍然可以快速同步时钟。</li></ul><blockquote><p>在CentOS7下为标配的时间同步服务，当然也可以使用以前的NTP同步方式，不过要安装NTP服务。</p></blockquote><h3 id="3-1-安装使用"><a href="#3-1-安装使用" class="headerlink" title="3.1 安装使用"></a>3.1 安装使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install chrony<br>systemctl start chronyd<br>systemctl <span class="hljs-built_in">enable</span> chronyd<br></code></pre></td></tr></table></figure><h3 id="3-2-配置文件"><a href="#3-2-配置文件" class="headerlink" title="3.2 配置文件"></a>3.2 配置文件</h3><p>当Chrony启动时，它会读取/etc/chrony.conf配置文件中的设置。也就是锁，如果需要更改时间同步的服务器，修改此配置文件即可。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[root@localhost ~]<span class="hljs-meta"># grep -Ev <span class="hljs-meta-string">&quot;^$|^#&quot;</span> /etc/chrony.conf</span><br># 该参数可以多次用于添加时钟服务器，必须以<span class="hljs-string">&quot;server &quot;</span>格式使用。一般而言，你想添加多少服务器，就可以添加多少服务器。<br>server <span class="hljs-number">0.</span>centos.pool.ntp.org iburst<br>server <span class="hljs-number">1.</span>centos.pool.ntp.org iburst<br>server <span class="hljs-number">2.</span>centos.pool.ntp.org iburst<br>server <span class="hljs-number">3.</span>centos.pool.ntp.org iburst<br><span class="hljs-meta"># stratumweight指令设置当chronyd从可用源中选择同步源时，每个层应该添加多少距离到同步距离。默认情况下，设置为0，让chronyd在选择源时忽略源的层级。</span><br>stratumweight <span class="hljs-number">0</span><br><span class="hljs-meta"># chronyd程序的主要行为之一，就是根据实际时间计算出计算机增减时间的比率，将它记录到一个文件中是最合理的，它会在重启后为系统时钟作出补偿，甚至可能的话，会从时钟服务器获得较好的估值。</span><br>driftfile /var/lib/chrony/drift<br><span class="hljs-meta"># rtcsync指令将启用一个内核模式，在该模式中，系统时间每11分钟会拷贝到实时时钟（RTC）。</span><br>rtcsync<br># 通常，chronyd将根据需求通过减慢或加速时钟，使得系统逐步纠正所有时间偏差。在某些特定情况下，系统时钟可能会漂移过快，导致该调整过程消耗很长的时间来纠正系统时钟。<br># 该指令强制chronyd在调整期大于某个阀值时步进调整系统时钟，但只有在因为chronyd启动时间超过指定限制（可使用负值来禁用限制），没有更多时钟更新时才生效。<br>makestep <span class="hljs-number">10</span> <span class="hljs-number">3</span><br># 这里你可以指定一台主机、子网，或者网络以允许或拒绝NTP连接到扮演时钟服务器的机器。<br><span class="hljs-meta">#allow 192.168/16</span><br># 该指令允许你限制chronyd监听哪个网络接口的命令包（由chronyc执行）。该指令通过cmddeny机制提供了一个除上述限制以外可用的额外的访问控制等级。<br>bindcmdaddress <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>bindcmdaddress ::<span class="hljs-number">1</span><br>keyfile /etc/chrony.keys<br># 指定了/etc/chrony.keys中哪一条密码被使用<br>commandkey <span class="hljs-number">1</span><br># 此参数指定了产生一个SHA1或MD5加密的密码，存放在/etc/chrony.keys中<br>generatecommandkey<br>noclientlog<br>logchange <span class="hljs-number">0.5</span><br>logdir /var/log/chrony<br></code></pre></td></tr></table></figure><p>/etc/chrony.keys文件</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta">#  cat /etc/chrony.keys</span><br><span class="hljs-meta">#1 a_key</span><br><br><span class="hljs-number">1</span> SHA1 HEX:<span class="hljs-number">8B</span>96920E9C83612FE34A8C281C31310BD2E1F624<br></code></pre></td></tr></table></figure><p>内容来自 <a href="https://link.jianshu.com?t=http://www.cnblogs.com/abclife/p/4736064.html">RHEL7 – 使用Chrony设置时间与时钟服务器同步</a></p><h2 id="3-3-chronyc"><a href="#3-3-chronyc" class="headerlink" title="3.3 chronyc"></a>3.3 chronyc</h2><p>1.查看帮助</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[root@localhost ~]</span># chronyc --help<br>Usage: chronyc [-h HOST] [-p PORT] [-n] [-<span class="hljs-number">4</span>|-<span class="hljs-number">6</span>] [-a] [-f FILE] [-m] [COMMAND]<br></code></pre></td></tr></table></figure><p>2.查看详细的帮助信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs xml">[root@localhost ~]# chronyc<br>chrony version 2.1.1<br>Copyright (C) 1997-2003, 2007, 2009-2015 Richard P. Curnow and others<br>chrony comes with ABSOLUTELY NO WARRANTY.  This is free software, and<br>you are welcome to redistribute it under certain conditions.  See the<br>GNU General Public License version 2 for details.<br><br>chronyc&gt; help<br>Commands:<br>accheck <span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span> : Check whether NTP access is allowed to <span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span><br>activity : Check how many NTP sources are online/offline<br>add peer <span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span> ... : Add a new NTP peer<br>add server <span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span> ... : Add a new NTP server<br>allow [<span class="hljs-tag">&lt;<span class="hljs-name">subnet-addr</span>&gt;</span>] : Allow NTP access to that subnet as a default<br>allow all [<span class="hljs-tag">&lt;<span class="hljs-name">subnet-addr</span>&gt;</span>] : Allow NTP access to that subnet and all children<br>burst <span class="hljs-tag">&lt;<span class="hljs-name">n-good</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">n-max</span>&gt;</span> [<span class="hljs-tag">&lt;<span class="hljs-name">mask</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">masked-address</span>&gt;</span>] : Start a rapid set of measurements<br>clients : Report on clients that have accessed the server<br>cmdaccheck <span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span> : Check whether command access is allowed to <span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span><br>cmdallow [<span class="hljs-tag">&lt;<span class="hljs-name">subnet-addr</span>&gt;</span>] : Allow command access to that subnet as a default<br>cmdallow all [<span class="hljs-tag">&lt;<span class="hljs-name">subnet-addr</span>&gt;</span>] : Allow command access to that subnet and all children<br>cmddeny [<span class="hljs-tag">&lt;<span class="hljs-name">subnet-addr</span>&gt;</span>] : Deny command access to that subnet as a default<br>cmddeny all [<span class="hljs-tag">&lt;<span class="hljs-name">subnet-addr</span>&gt;</span>] : Deny command access to that subnet and all children<br>cyclelogs : Close and re-open logs files<br>delete <span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span> : Remove an NTP server or peer<br>deny [<span class="hljs-tag">&lt;<span class="hljs-name">subnet-addr</span>&gt;</span>] : Deny NTP access to that subnet as a default<br>deny all [<span class="hljs-tag">&lt;<span class="hljs-name">subnet-addr</span>&gt;</span>] : Deny NTP access to that subnet and all children<br>dump : Dump all measurements to save files<br>local off : Disable server capability for unsynchronised clock<br>local stratum <span class="hljs-tag">&lt;<span class="hljs-name">stratum</span>&gt;</span> : Enable server capability for unsynchronised clock<br>makestep [<span class="hljs-tag">&lt;<span class="hljs-name">threshold</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">updates</span>&gt;</span>] : Correct clock by stepping<br>manual off|on|reset : Disable/enable/reset settime command and statistics<br>manual list : Show previous settime entries<br>maxdelay <span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">new-max-delay</span>&gt;</span> : Modify maximum round-trip valid sample delay for source<br>maxdelayratio <span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">new-max-ratio</span>&gt;</span> : Modify max round-trip delay ratio for source<br>maxdelaydevratio <span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">new-max-ratio</span>&gt;</span> : Modify max round-trip delay dev ratio for source<br>maxpoll <span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">new-maxpoll</span>&gt;</span> : Modify maximum polling interval of source<br>maxupdateskew <span class="hljs-tag">&lt;<span class="hljs-name">new-max-skew</span>&gt;</span> : Modify maximum skew for a clock frequency update to be made<br>minpoll <span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">new-minpoll</span>&gt;</span> : Modify minimum polling interval of source<br>minstratum <span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">new-min-stratum</span>&gt;</span> : Modify minimum stratum of source<br>offline [<span class="hljs-tag">&lt;<span class="hljs-name">mask</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">masked-address</span>&gt;</span>] : Set sources in subnet to offline status<br>online [<span class="hljs-tag">&lt;<span class="hljs-name">mask</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">masked-address</span>&gt;</span>] : Set sources in subnet to online status<br>password [<span class="hljs-tag">&lt;<span class="hljs-name">new-password</span>&gt;</span>] : Set command authentication password<br>polltarget <span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">new-poll-target</span>&gt;</span> : Modify poll target of source<br>reselect : Reselect synchronisation source<br>rtcdata : Print current RTC performance parameters<br>settime &lt;date/time (e.g. Nov 21, 1997 16:30:05 or 16:30:05)&gt; : Manually set the daemon time<br>smoothing : Display current time smoothing state<br>smoothtime reset|activate : Reset/activate time smoothing<br>sources [-v] : Display information about current sources<br>sourcestats [-v] : Display estimation information about current sources<br>tracking : Display system time information<br>trimrtc : Correct RTC relative to system clock<br>waitsync [max-tries [max-correction [max-skew]]] : Wait until synchronised<br>writertc : Save RTC parameters to file<br><br>authhash <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>: Set command authentication hash function<br>dns -n|+n : Disable/enable resolving IP addresses to hostnames<br>dns -4|-6|-46 : Resolve hostnames only to IPv4/IPv6/both addresses<br>timeout <span class="hljs-tag">&lt;<span class="hljs-name">milliseconds</span>&gt;</span> : Set initial response timeout<br>retries <span class="hljs-tag">&lt;<span class="hljs-name">n</span>&gt;</span> : Set maximum number of retries<br>exit|quit : Leave the program<br>help : Generate this help<br><br>chronyc&gt; quit<br></code></pre></td></tr></table></figure><p>3.常用命令</p><ul><li><code>accheck</code> 检查NTP访问是否对特定主机可用</li><li><code>activity</code> 该命令会显示有多少NTP源在线/离线</li><li><code>add server</code> 手动添加一台新的NTP服务器</li><li><code>clients</code> 在客户端报告已访问到服务器</li><li><code>delete</code> 手动移除NTP服务器或对等服务器</li><li><code>settime</code> 手动设置守护进程时间</li><li><code>tracking</code> 显示系统时间信息</li></ul><p>示例：查看时间同步的信息来源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># chronyc sources</span><br>210 Number of sources = 3<br>MS Name/IP address         Stratum Poll Reach LastRx Last sample<br>===============================================================================<br>^+ 202.118.1.130                 2   6    37   104  +2189us[  +23ms] +/-   27ms<br>^* dns1.synet.edu.cn             2   6    77    40   +626us[  +21ms] +/-   33ms<br>^? 2001:da8:9000::81             0   6     0   10y     +0ns[   +0ns] +/-    0ns<br></code></pre></td></tr></table></figure><p>sources可以加-v参数查看状态信息的说明</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@localhost ~]<span class="hljs-comment"># chronyc sources -v</span><br>210 Number of sources = 3<br><br>  .-- Source mode  <span class="hljs-string">&#x27;^&#x27;</span> = server, <span class="hljs-string">&#x27;=&#x27;</span> = peer, <span class="hljs-string">&#x27;#&#x27;</span> = <span class="hljs-built_in">local</span> clock.<br> / .- Source state <span class="hljs-string">&#x27;*&#x27;</span> = current synced, <span class="hljs-string">&#x27;+&#x27;</span> = combined , <span class="hljs-string">&#x27;-&#x27;</span> = not combined,<br>| /   <span class="hljs-string">&#x27;?&#x27;</span> = unreachable, <span class="hljs-string">&#x27;x&#x27;</span> = time may be <span class="hljs-keyword">in</span> error, <span class="hljs-string">&#x27;~&#x27;</span> = time too variable.<br>||                                                 .- xxxx [ yyyy ] +/- zzzz<br>||      Reachability register (octal) -.           |  xxxx = adjusted offset,<br>||      Log2(Polling interval) --.      |          |  yyyy = measured offset,<br>||                                \     |          |  zzzz = estimated error.<br>||                                 |    |           \<br>MS Name/IP address         Stratum Poll Reach LastRx Last sample<br>===============================================================================<br>^+ 202.118.1.130                 2   6    37   126  +2189us[  +23ms] +/-   27ms<br>^* dns1.synet.edu.cn             2   6    77    61   +626us[  +21ms] +/-   33ms<br>^? 2001:da8:9000::81             0   6     0   10y     +0ns[   +0ns] +/-    0ns<br></code></pre></td></tr></table></figure><p>4.chronyc在桌面版提供用户界面，需要通过以下命令安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">yum -y install system-config-date<br></code></pre></td></tr></table></figure><h2 id="4-实例"><a href="#4-实例" class="headerlink" title="4. 实例"></a>4. 实例</h2><h3 id="4-1-设置系统时间为中国时区并启用时间同步"><a href="#4-1-设置系统时间为中国时区并启用时间同步" class="headerlink" title="4.1 设置系统时间为中国时区并启用时间同步"></a>4.1 设置系统时间为中国时区并启用时间同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装</span><br>yum install chrony<br><span class="hljs-comment"># 启用</span><br>  systemctl start chronyd<br>systemctl <span class="hljs-built_in">enable</span> chronyd<br><span class="hljs-comment"># 设置亚洲时区</span><br>timedatectl set-timezone Asia/Shanghai<br><span class="hljs-comment"># 启用NTP同步</span><br>timedatectl set-ntp yes<br></code></pre></td></tr></table></figure><p>这样服务器的时间就跟NTP服务器同步了，非常简单的操作。</p><p>也可以不使用Chrony，用NTP服务的时间同步。但<strong>不推荐</strong>。</p><h3 id="4-2-安装NTP服务使用其同步时间"><a href="#4-2-安装NTP服务使用其同步时间" class="headerlink" title="4.2 安装NTP服务使用其同步时间"></a>4.2 安装NTP服务使用其同步时间</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装ntp服务</span><br>yum install ntp<br><span class="hljs-comment"># 开机启动服务</span><br>systemctl <span class="hljs-built_in">enable</span> ntpd<br><span class="hljs-comment"># 启动服务</span><br>systemctl start ntpd<br><span class="hljs-comment"># 设置亚洲时区</span><br>timedatectl set-timezone Asia/Shanghai<br><span class="hljs-comment"># 启用NTP同步</span><br>timedatectl set-ntp yes<br><span class="hljs-comment"># 重启ntp服务</span><br>systemctl restart ntpd<br><span class="hljs-comment"># 手动同步时间</span><br>ntpq -p<br></code></pre></td></tr></table></figure><h3 id="4-3-RTC设为本地时间会有告警"><a href="#4-3-RTC设为本地时间会有告警" class="headerlink" title="4.3 RTC设为本地时间会有告警"></a>4.3 RTC设为本地时间会有告警</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># timedatectl set-local-rtc 1</span><br>[<span class="hljs-meta">root@localhost ~</span>]<span class="hljs-meta"># timedatectl</span><br>      Local time: Thu <span class="hljs-number">2016</span><span class="hljs-number">-05</span><span class="hljs-number">-26</span> <span class="hljs-number">15</span>:<span class="hljs-number">31</span>:<span class="hljs-number">59</span> CST<br>  Universal time: Thu <span class="hljs-number">2016</span><span class="hljs-number">-05</span><span class="hljs-number">-26</span> <span class="hljs-number">07</span>:<span class="hljs-number">31</span>:<span class="hljs-number">59</span> UTC<br>        RTC time: Thu <span class="hljs-number">2016</span><span class="hljs-number">-05</span><span class="hljs-number">-26</span> <span class="hljs-number">15</span>:<span class="hljs-number">31</span>:<span class="hljs-number">59</span><br>       Time zone: Asia/Shanghai (CST, +<span class="hljs-number">0800</span>)<br>     NTP enabled: yes<br>NTP synchronized: yes<br> RTC <span class="hljs-keyword">in</span> local TZ: yes<br>      DST active: n/a<br><br>Warning: The system <span class="hljs-keyword">is</span> configured to read the RTC time <span class="hljs-keyword">in</span> the local time zone.<br>         This mode can <span class="hljs-keyword">not</span> be fully supported. It will create various problems<br>         <span class="hljs-keyword">with</span> time zone changes <span class="hljs-keyword">and</span> daylight saving time adjustments. The RTC<br>         time <span class="hljs-keyword">is</span> never updated, it relies <span class="hljs-keyword">on</span> external facilities to maintain it.<br>         If at all possible, use RTC <span class="hljs-keyword">in</span> UTC <span class="hljs-keyword">by</span> calling<br>         <span class="hljs-string">&#x27;timedatectl set-local-rtc 0&#x27;</span>.<br></code></pre></td></tr></table></figure><blockquote><p>因为硬件时钟不能保存时区和夏令时调整，修改后就无法从硬件时钟中读取出准确标准时间；不建议修改。</p></blockquote><ol><li><code># 安装 ntpdate</code></li><li><code>apt-get install ntpdate</code></li><li></li><li><code># 设置系统时间与网络时间同步（cn.pool.ntp.org 位于中国的公共 NTP 服务器）</code></li><li><code>ntpdate cn.pool.ntp.org</code></li><li></li><li><code># 将系统时间写入硬件时间</code></li><li><code>hwclock --systohc</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-Cloud分布式项目搭建模板</title>
    <link href="/2019/07/02/spring/Spring-Cloud%E5%88%86%E5%B8%83%E5%BC%8F%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E6%A8%A1%E6%9D%BF/"/>
    <url>/2019/07/02/spring/Spring-Cloud%E5%88%86%E5%B8%83%E5%BC%8F%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Cloud分布式项目搭建模板"><a href="#Spring-Cloud分布式项目搭建模板" class="headerlink" title="Spring-Cloud分布式项目搭建模板"></a>Spring-Cloud分布式项目搭建模板</h1><h1 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h1><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p><strong>Eureka:</strong> 服务注册中心。通过Eureka可以监控各个服务的运行状态。它具有如下几个角色：</p><ul><li><p>Eureka Server： 提供服务注册与发现</p></li><li><p>Service Provider: 服务提供方。将自身注册到Eureka，供消费者使用</p></li><li><p>Service Consumer:  服务消费方。从Eureka中获取服务器提供方列表，从而消费服务</p></li></ul><span id="more"></span><p>[TOC]</p><p>举个栗子：</p><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/O7VLhv5gmTUioEX.png" alt=""></p><blockquote><p>  问题引入：</p></blockquote><p>前端APP发送一个请求，此请求需要调用某个服务的接口，比如此时有两个订单服务、一个派送服务 ( 因为要考虑并发，所以通常服务不止一个，而是一个集群 )。上图中前端APP直接请求某个具体服务的接口，如果后端服务集群非常庞大，前端就要记录很多服务的IP地址。并且对于同一服务的集群配置情况，前端APP还需要自行判断到底调用哪个服务。</p><blockquote><p>  解决办法：</p></blockquote><p>显然上述的方式是不可取的。按照之前开发SSM框架前后端不分离时，通常页面直接请求的内部服务接口，从不考虑服务的具体IP地址，因为默认使用的此服务的IP地址。那么在微服务架构中也应该这样设计。所以我们加一个 <strong>GateWay网关服务</strong>，前端APP直接请求请求网关，仅需要记录网关的IP地址即可，这样就将后端服务接口寻址调用的工作交给了服务端完成。举个栗子：</p><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/2rpeySQnmYPkvRM.png" alt=""></p><blockquote><p>  问题引入：</p></blockquote><p>虽然使用了网关让前端APP直接调用网关地址，由网关负责具体的接口寻址调用，从而减轻了前端的负担。但是，同样，网关也仍然需要知道所有服务的IP地址和对应的接口，并且对于同一服务集群配置的情况仍然要考虑到底调用哪个服务才能分摊请求压力。</p><blockquote><p>  解决办法：</p></blockquote><p>所以，需要一个服务，他能记录系统中所有的微服务IP地址；并且有类似负载均衡的算法，对于服务集群配置，该服务能知道调用哪些服务才能平均分配请求的压力；并且，如果哪个服务崩溃，该服务还能快速知道并不再向崩溃的服务发送请求。于是，<strong>Eureka</strong>诞生了。</p><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/I2DozuMlL3gWQ61.png" alt=""></p><p>Eureka是服务注册中心，其他具体服务可以向这个Eureka注册中心注册自己。当前端发送请求时，首先前端APP会直接请求网关，当然网关服务也注册在Eureka注册中心上，然后网关把接收到的请求交由Eureka处理，Eureka接收到这些请求，会从自己的服务注册列表中寻找对应的服务地址，然后实现调用具体的服务。</p><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><blockquote><p>  问题引入：</p></blockquote><p>在上面的介绍中，我们基本解决了前端APP调用后端服务集群的问题。但又必须考虑一个问题，分布式微服务项目，即各个服务相互独立，但是各个服务又存在相互调用的关系。如何解决服务于服务之间的通信呢？</p><blockquote><p>  解决办法：</p></blockquote><p>在微服务架构中，服务于服务的通讯都是基于Http Restful的。SpringCloud有两种调用方式：</p><ul><li>使用 <strong>Ribbon + RestTemplate</strong>。<strong>Ribbon</strong>是一个负载均衡客户端，可以很好的控制Http和Tcp的一些行为。而<strong>RestTemplate</strong>是Spring本身提供的用于远程调用Rest接口的HTTP客户端。</li><li>使用 <strong>Feign</strong>。<strong>Feign</strong>是一个声明式的HTTP客户端，仅需要一个<strong>@FeignClient</strong>注解就能实现远程调用。<strong>Feign</strong>默认集成了<strong>Ribbon</strong>，并和<code>Eureka</code>结合，默认实现了负载均衡的效果。</li></ul><h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><blockquote><p>  问题引入：</p></blockquote><p>在集群项目中，如果突然某个服务因为访问压力过大崩溃了，Eureka再调用该服务就会调用失败，并且如果该服务向下还存在与其他服务的关联，那么就会造成其他服务也不可用，从而使错误传递下去，这也就是<strong>雪崩效应</strong>。如何解决呢？</p><blockquote><p>  解决办法：</p></blockquote><p><strong>Hystrix</strong>的出现就是解决这一现象。<strong>Hystrix</strong>熔断器就像家用电闸中的保险丝，如果整个电路中某处发生了漏电、或者用电过高保险丝就会直接熔断，直接停电阻止事态恶化。如果集群中某个服务不可用、或者响应时间过长，Hystrix会直接阻断Eureka再调用此服务，从而避免了系统中所有服务都不可用。</p><h2 id="Hystrix-Dashboard"><a href="#Hystrix-Dashboard" class="headerlink" title="Hystrix-Dashboard"></a>Hystrix-Dashboard</h2><blockquote><p>  问题引入：</p></blockquote><p>上面介绍了使用<strong>Hystrix</strong>实现熔断服务，但作为开发者，我们并不能确定服务什么时候被熔断。</p><blockquote><p>  解决办法：</p></blockquote><p>提供了<code>hystrix-dashboard</code>工具实现实时监控Hystrix熔断器的状态。</p><h2 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h2><p><strong>Zuul</strong>路由网关。举个栗子：</p><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/Vf9DvhrYsFmpgTC.png" alt=""></p><p>如上是一个基本的微服务架构图，先抛开左侧的配置服务，如果前端APP请求后台接口，显然前端无法记录后端那么多服务的API地址，按照SSM框架的开发思路，前端APP仅需要记录一个IP地址即可，所有的请求都应该是请求这个IP中的某个接口。</p><p>那么<strong>Zuul</strong>路由网关的作用就是如此，他实现将客户端<strong>按照一定约束</strong>的不同请求转发到对应的服务，这样就实现客户端仅记录一个IP地址就能实现请求不同服务的接口。</p><h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><p>如果系统服务模块非常多时，每次修改服务配置都要修改服务<code>src/main/resources</code>下的<code>application.yml</code>可能会很麻烦，<code>spring-cloud-config</code>就解决了这个问题，Config Server端实现将配置文件内容以接口的形式暴露，Client端通过该接口得到配置文件内容，并以此初始化自己的应用。</p><h2 id="ZipKin"><a href="#ZipKin" class="headerlink" title="ZipKin"></a>ZipKin</h2><p><strong>ZipKin</strong> 服务链路追踪。可以追踪系统中服务间的依赖调用关系，查看调用的详细数据，收集服务的详细数据。提供 <strong>Zipkin UI</strong> 可以轻松的在Web端收集和分析数据。</p><h2 id="Spring-Boot-Admin"><a href="#Spring-Boot-Admin" class="headerlink" title="Spring-Boot-Admin"></a>Spring-Boot-Admin</h2><p><strong>Spring Boot Admin</strong> 实现堆各个微服务的健康状态、会话数量、并发数、服务资源、延迟等信息的收集，是一套强大的监控管理系统</p><h1 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h1><p>本地创建一个空文件夹，使用IDEA打开这个文件夹，并在其中创建<code>pom.xml</code>文件</p><p><code>pom.xml</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.eric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>template<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>template<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud.version</span>&gt;</span>Greenwich.SR1<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="搭建Eureka服务"><a href="#搭建Eureka服务" class="headerlink" title="搭建Eureka服务"></a>搭建Eureka服务</h2><p>Eureka是服务注册中心，但它自己同样也是一个服务。</p><ol><li><p>和上面一样，在<code>cloud-template</code>文件夹下创建<code>template-eureka</code>文件夹</p></li><li><p>创建该服务的启动器类：<code>EurekaApplication</code> </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableEurekaServer</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(EurekaApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>仅需要添加<code>@EnableEurekaServer</code>就告诉了Spring这个服务的Eureka服务注册中心。</p><ol start="3"><li>在<code>cloud-template</code>父工程<code>pom.xml</code>中新增一个节点</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>template-eureka<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>创建<code>application.yml</code>配置文件</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-comment"># 应用名称</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">template-eureka</span><br><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-comment"># Eureka注册中心HOST主机地址，可以采用：1.直接配置IP；2.配置本地域名并修改本地hosts文件</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">localhost</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-comment"># 是否将自己注册到注册中心。因为项目中只有一个注册中心就是自己，所以无需再注册</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-comment"># 是否从远程拉取其他注册中心，因为注册中心只有自己所以不需要。如果注册中心有多个，可以相互暴露，相互拉取</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-comment"># 该注册中心连接地址</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span><br></code></pre></td></tr></table></figure><ol start="5"><li>启动<code>EurekaApplication.java</code>中的main方法，浏览器访问：<code>localhost:8080</code></li></ol><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/vhbmQpCikURyDJe.png" alt=""></p><p>可以看到此时没有任何服务注册到Eureka注册中心。</p><h2 id="搭建生产者服务"><a href="#搭建生产者服务" class="headerlink" title="搭建生产者服务"></a>搭建生产者服务</h2><ol><li>在<code>cloud-template</code>下创建<code>template-admin</code>文件夹</li><li>创建<code>pom.xml</code>，主要添加一个依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>在父工程<code>cloud-template</code>的<code>pom.xml</code>中再添加一个节点</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>template-eureka<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>template-admin<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>创建该服务的启动器类：<code>AdminApplication.java</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdminApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(AdminApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只需要添加注解<code>@EnableEurekaClient</code>就表明该服务Eureka的一个服务提供方。</p><ol start="5"><li>创建配置文件<code>application.yml</code></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9001</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">template-admin</span><br><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-comment"># Eureka注册中心连接地址</span><br>      <span class="hljs-comment"># 如果注册中心地址配置的域名，这里使用 http://域名/eureka/ 格式</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8080/eureka/</span><br></code></pre></td></tr></table></figure><ol start="6"><li>运行<code>AdminApplication.java</code>中的main方法，刷新<code>localhost:8080</code>地址：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/UcqQY278mZfA3ko.png" alt=""></p><p>可看到，<code>template-admin</code>服务已经注册到了Eureka注册中心</p><ol start="7"><li>在<code>template-admin</code>服务中创建一个Controller类：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdminController</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="hljs-keyword">this</span>.getClass());<br><br>    <span class="hljs-meta">@GetMapping(&quot;hello/&#123;name&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String name)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;&#123;&#125;===&gt;&gt;&gt;&#123;&#125;&quot;</span>, <span class="hljs-string">&quot;Getting into admin&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello,&quot;</span> + name + <span class="hljs-string">&quot;, this is template admin!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="8"><li>重启<code>template-admin</code>服务，访问：`localhost:9001/hello/kobe:</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/DZXc49fqLjGvgao.png" alt=""></p><h2 id="搭建消费者服务"><a href="#搭建消费者服务" class="headerlink" title="搭建消费者服务"></a>搭建消费者服务</h2><p>上面搭建了 <code>template-admin</code> 生产者服务，它暴露了Rest接口，那么其他服务想要调用生产者服务的接口，就必须实现与生产者服务的通信。最开始<strong>概念引入</strong>部分我们提到了<code>SpringCloud</code>实现服务间通信的两种方式，这里我们直接使用<strong>Feign</strong>实现。</p><ol><li>在<code>cloud-template</code>下创建<code>template-auth</code>文件夹</li><li>创建<code>pom.xml</code>，主要添加两个依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>在父工程<code>cloud-template</code>下再添加一个节点</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>template-eureka<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>template-admin<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>template-auth<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>创建该服务的启动器类：<code>AuthApplication.java</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(AuthApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意添加<code>@EnableDiscoveryClient</code>注解声明该服务为Eureka中服务消费方；添加<code>@EnableFeignClients</code>开启Feign声明式服务间通信（配合<code>@FeignClient</code>注解使用）。</p><ol start="5"><li>创建配置文件<code>application.yml</code></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9002</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">template-auth</span><br><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-comment"># Eureka注册中心连接地址</span><br>      <span class="hljs-comment"># 如果注册中心地址配置的域名，这里使用 http://域名/eureka/ 格式</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8080/eureka/</span><br></code></pre></td></tr></table></figure><ol start="6"><li>模拟创建一个Controller：<code>AuthController.java</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdminController</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="hljs-keyword">this</span>.getClass());<br><br>    <span class="hljs-meta">@GetMapping(&quot;hello/&#123;name&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String name)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;&#123;&#125;===&gt;&gt;&gt;&#123;&#125;&quot;</span>, <span class="hljs-string">&quot;Getting into admin&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello,&quot;</span> + name + <span class="hljs-string">&quot;, this is template admin!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="7"><li>启动项目，访问<code>localhost:8080</code></li></ol><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/a4JBlPqKbQc2AEw.png" alt=""></p><p>可以看到该服务已经注册到了Eureka注册中心了。继续访问<code>http://localhost:9002/hello/james</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/Fa6oiXsYTHI7Lx3.png" alt=""></p><ol start="8"><li>在<code>template-auth</code>服务下创建<code>feign/service</code>文件夹，并在其中创建<code>AuthFeignService.java</code>接口：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;template-admin&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AuthFeignService</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这里暴露一个Feign接口地址，其中`<span class="hljs-doctag">@GetMapping</span>`中的地址一定对应了`template-admin`服务中某个Controller中的请求地址（如果`template-admin`服务中没有这个接口地址就会404）</span><br><span class="hljs-comment">     * 如果其他地方调用了AuthFeignService接口的hello方法，FeignClient将类似通过转发的方式去请求调用`template-admin`服务中符合的接口地址的方法</span><br><span class="hljs-comment">     * 如果请求传递了参数，需要加<span class="hljs-doctag">@RequestParam</span>注解标识。如果URL中有动态参数，要添加<span class="hljs-doctag">@PathVariable</span>注解</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/hello/&#123;name&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(name = &quot;name&quot;)</span> String name)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上，这是一个供Feign调用的接口。Feign实现服务端通信有几个基本条件：</p><ul><li>该服务添加了<code>spring-cloud-starter-openfeign</code>依赖</li><li>该服务的启动器类上添加了<code>@EnableFeignClients</code>注解</li><li>该服务提供了一个接口类，并在该接口上添加了<code>@FeignClient</code>注解，并且<code>@FeignClient</code>注解中<code>value</code>属性值必须等于一个已在Eureka中注册的服务名称。</li><li>在该接口上添加一个调用的方法，该方法必须和被调用服务方<code>Controller</code>中的方法格式相同(除了没有方法具体实现，方法的返回值、参数列表都要相同)，并且需要和被调用方<code>Controller</code>接口一样在方法上添加<code>@RequestMapping</code>注解，指明被调用方接口的具体<code>URL</code>。</li></ul><ol start="9"><li>修改<code>template-auth</code>服务中的<code>AuthController</code>类，添加一个请求接口：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AuthFeignService authFeignService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模拟Feign远程调用，这里暴露一个请求接口`/feignHello`</span><br><span class="hljs-comment">     * 这个请求接口将调用`AuthFeignService`（Feign接口）</span><br><span class="hljs-comment">     * Feign接口（`AuthFeignService`接口）将会通过`<span class="hljs-doctag">@FeignClient</span>(value = &quot;template-admin&quot;)`在Eureka注册中心寻找`template-admin`模块</span><br><span class="hljs-comment">     * Feign接口类似Controller的Rest接口，也暴露一个地址，这个地址对应`template-admin`模块的一个Controller接口地址</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/feignHello/&#123;name&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">feignHello</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String name)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> authFeignService.hello(name);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如上，这个<code>/feignHello/&#123;name&#125;</code>请求接口将调用<code>AuthFeignService</code>的<code>hello</code>方法，而<code>AuthFeignService</code>的<code>hello</code>方法最终由Feign调用<code>template-admin</code>中的<code>/hello</code>请求接口。</p><p>所以，<code>template-auth</code>服务中的<code>/feignHello/&#123;name&#125;</code>接口最终调用了<code>template-admin</code>服务中的<code>/hello/&#123;name&#125;</code>接口。重启<code>template-auth</code>服务，访问：<code>localhost:9002/feignHello/tycoding</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/EDgaLsp8vkRxJdQ.png" alt=""></p><p>显然，我们的分析都是正确的，使用Feign声明式服务调用，仅通过<code>@FeignClient</code>注解就能完成服务间通信。</p><h2 id="配置Hystrix熔断机制"><a href="#配置Hystrix熔断机制" class="headerlink" title="配置Hystrix熔断机制"></a>配置Hystrix熔断机制</h2><p>前面提到了Hystrix主要用于在多个服务间存在通信，而通信的某一方因为压力过大、响应时间过长而导致不可用，Hystrix就会阻止Eureka再给该服务分配请求，从而保证服务的高可用。</p><p>因此，Hystrix主要配置在存在服务间通信的地方。因为我们使用的Feign，Feign正是用来实现服务间通信的。所以我们只需要在自己创建的Feign接口中配置熔断器即可。因为Feign已经内置了Hystrix，我们只需要配置启用hystrix即可。</p><ol><li>修改<code>template-auth</code>中的<code>application.yml</code>:</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">hystrix:</span><br>    <span class="hljs-comment"># 开启Feign的Hystrix熔断器支持</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ol start="2"><li>在<code>/feign/service/fallback</code>中创建<code>AuthFeignServiceFallbackImpl.java</code>:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthFeignServiceFallbackImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AuthFeignService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello &quot;</span> + name + <span class="hljs-string">&quot;, this is template-auth, but request error&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个类实现了<code>AuthFeignService</code>远程调用接口，作用就是当<code>AuthFeignService</code>调用的服务不可用时，Hystrix直接执行这个实现类中的方法，而不再执行<code>AuthFeignService</code>中的远程调用方法。</p><ol start="3"><li>重启<code>template-auth</code>服务，访问<code>localhost:9002/feignHello/james发现正常访问。此时关闭</code>template-admin`服务：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/etEUOThk3rXIdMf.png" alt=""></p><p>该服务已关闭，继续访问：<code>localhost:9002/feignHello/james</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/lO6KjUqHCGpYovA.png" alt=""></p><p>可以看到访问该URL时，浏览器直接显示的<code>AuthFeignServiceFallbackImpl.java</code>中的响应数据，而不是再加载一下请求<code>AuthFeignService.java</code>中的请求。就是说如果被调用方服务一旦不可用，Hystrix就<strong>立刻</strong>熔断与该服务之间的通信。</p><h2 id="配置Hystrix-Dashboard"><a href="#配置Hystrix-Dashboard" class="headerlink" title="配置Hystrix-Dashboard"></a>配置Hystrix-Dashboard</h2><p>可以通过<code>hystrix-dashboard</code>工具实现对熔断器Hystrix的实时监控。因为我们在<code>template-auth</code>服务中使用了Feign远程调用，并且使用了Hystrix熔断器，所以我们只需要在<code>template-auth</code>服务中配置熔断监控：</p><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>在<code>template-auth</code>启动器类上添加<code>@EnableHystrixDashboard</code>注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-meta">@EnableHystrixDashboard</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(AuthApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>在<code>/config</code>文件夹下创建<code>HystrixDashboardConfig.java</code>:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HystrixDashboardConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">getServlet</span><span class="hljs-params">()</span> </span>&#123;<br>        HystrixMetricsStreamServlet streamServlet = <span class="hljs-keyword">new</span> HystrixMetricsStreamServlet();<br>        ServletRegistrationBean registrationBean = <span class="hljs-keyword">new</span> ServletRegistrationBean(streamServlet);<br>        registrationBean.setLoadOnStartup(<span class="hljs-number">1</span>);<br>        registrationBean.addUrlMappings(<span class="hljs-string">&quot;/hystrix.stream&quot;</span>);<br>        registrationBean.setName(<span class="hljs-string">&quot;HystrixMetricsStreamServlet&quot;</span>);<br>        <span class="hljs-keyword">return</span> registrationBean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果项目中添加了<code>spring-cloud-starter-netflix-hystrix-dashboard</code>依赖，此依赖提供了 <code>/hystrix</code> 接口地址，这是访问<code>hystrix-dashboard</code>的入口地址。但是<code>hystrix-dashboard</code>需要监控某个Hystrix熔断器地址，那么这个监控地址哪来呢？</p><p>在SpringBoot2.x之前的版本中，SpringBoot默认提供了一个接口地址用于访问Hystrix熔断器。但是在SpringBoot2版本中需要手动提供一个Hystrix监控地址。上面的配置就是将Servlet ( HystrixMetricsStreamServlet )注入到Web容器中，类似<code>web.xml</code>中的<code>&lt;servlet-mapping&gt;</code>和<code>&lt;servlet-name&gt;</code>。</p><ol start="4"><li>重启<code>template-auth</code>服务，访问：<code>localhost:9002/hystrix</code></li></ol><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/18ZU9HbWRMVpAKf.png" alt=""></p><p>在<code>http...</code>输入框中输入``localhost:9002/hystrix.stream<code>，其中</code>Delay`是每隔几毫秒刷新一次</p><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/8gIpa9RoBfkyZYG.png" alt=""></p><p>显示Loading说明连接成功，但是因为没有触发Hystrix熔断器，所以监控没有显示数据。我们继续访问：<code>localhost:9002/feignHello/james</code>，重复刷新5次网页：</p><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/qHsrO8RSLc6lkFI.png" alt=""></p><p>因为，所有的服务都是启动的，所以熔断器没有熔断。此时关掉<code>template-admin</code>服务，再次刷新<code>localhost:9002/feignHello/james</code>接口7次：</p><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/4cxAfe1k2m8IhNO.png" alt=""></p><h2 id="配置Zuul路由网关"><a href="#配置Zuul路由网关" class="headerlink" title="配置Zuul路由网关"></a>配置Zuul路由网关</h2><ol><li><p>在<code>cloud-template</code>下创建<code>template-zuul</code>文件夹</p></li><li><p>创建<code>pom.xml</code>，主要添加两个依赖：</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>在父工程<code>cloud-template</code>的<code>pom.xml</code>下添加一个节点：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>template-eureka<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>template-admin<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>template-auth<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>template-zuul<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>创建该服务的启动器类：<code>ZuulApplication.java</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableZuulProxy</span><br><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZuulApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(ZuulApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>@EnableEurekaClient</code>表明此服务是<strong>Eureka</strong>的客户端，也就是此服务需要注册到Eureka注册中心；而注解<code>@EnableZuulProxy</code>就是开启<strong>Zuul</strong>网关的支持。</p><ol start="4"><li>创建配置文件：<code>application.yml</code></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9003</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">template-zuul</span><br><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-comment"># Eureka注册中心连接地址</span><br>      <span class="hljs-comment"># 如果注册中心地址配置的域名，这里使用 http://域名/eureka/ 格式</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8080/eureka/</span><br><br><span class="hljs-attr">zuul:</span><br>  <span class="hljs-attr">routes:</span><br>    <span class="hljs-comment"># 路由名称，随意</span><br>    <span class="hljs-attr">template-admin:</span><br>      <span class="hljs-comment"># 路由地址</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">/api/admin/**</span><br>      <span class="hljs-comment"># 该路由地址对应的服务名称</span><br>      <span class="hljs-attr">serviceId:</span> <span class="hljs-string">template-admin</span><br>    <span class="hljs-attr">template-auth:</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">/api/auth/**</span><br>      <span class="hljs-attr">serviceId:</span> <span class="hljs-string">template-auth</span><br></code></pre></td></tr></table></figure><p>其中，<code>zuul.routers</code>下可以配置多个路由表，每个路由表中对应了具体的请求路径前缀<code>path</code>，这个请求路径最终会被<code>Zuul</code>路由到某个服务中，所需需要对应配置一个<code>serviceId</code>对应某个服务的名称。这样就实现了请求<code>/api/admin/xx</code>接口<code>Zuul</code>就会将请求转发到<code>template-admin</code>服务、请求<code>/api/auth/xx</code>接口Zuul就会将请求转发到<code>template-auth</code>服务。</p><ol start="5"><li>按照<code>template-eureka</code> 、<code>template-zuul</code>、<code>template-admin</code>、<code>template-auth</code>的顺序启动项目。</li></ol><ul><li>访问：<code>localhost:9003/api/admin/hello/curry</code>:</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/m3MTD45Urevkacs.png" alt=""></p><ul><li>访问：<code>localhost:9003/api/auth/hello/curry</code>:</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/ZobVIiUnG3tAcuN.png" alt=""></p><ul><li>访问：<code>localhost:9003/api/auth/feignHello/curry</code>:</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/r9znF72vs1BXtLW.png" alt=""></p><p>如此，通过<code>template-zuul</code>服务的路由转发功能，实现了仅仅通过请求<code>9003</code>这一个IP地址就能访问多个服务的接口。但实际测试中你可能还会遇到如下的错误：</p><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/XRZJfxuKYnMb4gy.png" alt=""></p><p>这就是一个服务不可用的现象，Eureka会直接熔断与该服务的链接。而产生的原因与本地电脑的性能有关，所以就可能在项目运行中出现服务链接不上而被Eureka熔断的情况。</p><h3 id="配置Zuul的错误回调"><a href="#配置Zuul的错误回调" class="headerlink" title="配置Zuul的错误回调"></a>配置Zuul的错误回调</h3><p>上面图中就一个Zuul网关路由错误的情况，而出现错误，肯定不能弹出Spring内置的错误页面，而需要定制一个错误信息，通常是JSON格式。</p><p>在<code>/fallback</code>目录下创建：<code>AuthFeignFallbackProvider.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthFeignFallbackProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FallbackProvider</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getRoute</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// serviceId，如果需要所有的调用都支持回退，则return &quot;*&quot; 或 return null</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;template-auth&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回定制的错误信息</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> route</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cause</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ClientHttpResponse <span class="hljs-title">fallbackResponse</span><span class="hljs-params">(String route, Throwable cause)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ClientHttpResponse() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> HttpStatus <span class="hljs-title">getStatusCode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-keyword">return</span> HttpStatus.OK;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRawStatusCode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-keyword">return</span> HttpStatus.OK.value();<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getStatusText</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-keyword">return</span> HttpStatus.OK.getReasonPhrase();<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br><br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> InputStream <span class="hljs-title">getBody</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();<br>                Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>                map.put(<span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-number">200</span>);<br>                map.put(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-string">&quot;链接失败，请检查您的网络&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ByteArrayInputStream(mapper.writeValueAsString(map).getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> HttpHeaders <span class="hljs-title">getHeaders</span><span class="hljs-params">()</span> </span>&#123;<br>                HttpHeaders httpHeaders = <span class="hljs-keyword">new</span> HttpHeaders();<br>                httpHeaders.setContentType(MediaType.APPLICATION_JSON_UTF8);<br>                <span class="hljs-keyword">return</span> httpHeaders;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里要强调一个细节，如果Zuul路由服务失败不应该给客户端返回404、500等错误，因为客户端直接请求的是<code>template-zuul</code>路由网关服务，而请求<code>template-zuul</code>服务是成功的，<code>template-zuul</code>将请求转发到其他服务属于服务器内部错误，这中错误不应该暴露给客户端。除非是<code>template-zuul</code>路由网关服务自己挂了，才会返回给客户端404、500等错误。</p><p>重启<code>template-zuul</code>服务，<strong>立即</strong>访问<code>http://localhost:9003/api/auth/feignHello/curry</code>，一般都会链接不上服务：</p><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/uXk1PAfrUYSpoMB.png" alt=""></p><h3 id="配置Zuul服务过滤器"><a href="#配置Zuul服务过滤器" class="headerlink" title="配置Zuul服务过滤器"></a>配置Zuul服务过滤器</h3><p>如果需要对请求进行拦截过滤，比如登录时应该携带<code>Token</code>值才运行请求，那么就可以使用Zuul提供的过滤器功能。</p><ul><li>在<code>/filter</code>目录下创建<code>LoginFilter.java</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ZuulFilter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(<span class="hljs-keyword">this</span>.getClass());<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 过滤器类型：</span><br><span class="hljs-comment">     * pre: 路由前</span><br><span class="hljs-comment">     * routing: 路由时</span><br><span class="hljs-comment">     * post: 路由后</span><br><span class="hljs-comment">     * error: 路由发生错误时</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">filterType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;pre&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 过滤的顺序</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">filterOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否需要过滤</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 过滤器的具体业务逻辑</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> ZuulException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ZuulException </span>&#123;<br>        RequestContext currentContext = RequestContext.getCurrentContext();<br>        HttpServletRequest request = currentContext.getRequest();<br>        logger.info(<span class="hljs-string">&quot;&#123;&#125; &gt;&gt;&gt; &#123;&#125;&quot;</span>, request.getMethod(),   request.getRequestURI().toString());<br>        String token = request.getParameter(<span class="hljs-string">&quot;token&quot;</span>);<br>        <span class="hljs-keyword">if</span> (token == <span class="hljs-keyword">null</span>) &#123;<br>            logger.error(<span class="hljs-string">&quot;Error! Request Token is Empty&quot;</span>);<br>            currentContext.setSendZuulResponse(<span class="hljs-keyword">false</span>);<br>            currentContext.setResponseStatusCode(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                currentContext.getResponse().getWriter().write(<span class="hljs-string">&quot;Request token is empty&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>重新启动<code>template-zuul</code>服务。访问<code>localhost:9003/api/admin/hello/curry</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/TdC8DXRcMfe9hBF.png" alt=""></p><p>增加<code>token</code>，访问``localhost:9003/api/admin/hello/curry?token=123`</p><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/PesWG7ox5p2TFda.png" alt="image.png"></p><h2 id="搭建Config服务"><a href="#搭建Config服务" class="headerlink" title="搭建Config服务"></a>搭建Config服务</h2><h3 id="Server端"><a href="#Server端" class="headerlink" title="Server端"></a>Server端</h3><ol><li>在<code>cloud-template</code>下创建文件夹<code>template-config</code></li><li>创建<code>pom.xml</code>，主要添加以下两个依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>创建配置文件<code>application.yml</code></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8888</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">template-config</span><br><br>  <span class="hljs-comment"># 获取本地配置文件，本身支持：本地储存、git远程、SVN</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">native</span><br><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">server:</span><br>        <span class="hljs-comment"># 获取本地配置文件的位置</span><br>        <span class="hljs-attr">native:</span><br>          <span class="hljs-attr">search-locations:</span> <span class="hljs-string">classpath:config/</span><br><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-comment"># Eureka注册中心连接地址</span><br>      <span class="hljs-comment"># 如果注册中心地址配置的域名，这里使用 http://域名/eureka/ 格式</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8080/eureka/</span><br></code></pre></td></tr></table></figure><p>这里使用的本地储存配置文件，也可以采用从远程github、gitlab端读取：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 远程读取</span><br><span class="hljs-attr">cloud:</span><br>  <span class="hljs-attr">config:</span><br>    <span class="hljs-attr">label:</span> <span class="hljs-string">master</span> <span class="hljs-comment"># 配置仓库的分支</span><br>    <span class="hljs-attr">server:</span><br>      <span class="hljs-attr">git:</span><br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">https://github.com/xx/spring-cloud-config</span> <span class="hljs-comment"># 配置Git仓库地址，如果用Github需要加.git，如果用Gitlab则不需要</span><br>        <span class="hljs-attr">search-paths:</span> <span class="hljs-string">respo</span> <span class="hljs-comment"># 配置仓库路径</span><br>        <span class="hljs-attr">username:</span> <span class="hljs-comment"># 访问Git仓库的账号</span><br>        <span class="hljs-attr">password:</span> <span class="hljs-comment"># 访问Git仓库的密码</span><br></code></pre></td></tr></table></figure><ol start="4"><li>创建该服务的启动器类<code>ConfigApplication.java</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableConfigServer</span><br><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(ConfigApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>@EnableConfigServer</code>就是开启配置文件服务支持</p><ol start="5"><li>将<code>template-zuul</code>服务的配置文件<code>application.yml</code>拷贝到服务<code>template-zuul</code>的<code>/resources/config</code>目录下，重命名为<code>application-zuul-deb.yml</code>。</li><li>重启<code>template-zuul</code>服务，访问<code>localhost:8888/application-zuul/dev</code></li></ol><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/73WazdrIYmPUZMo.png" alt="image-20191112184807433"></p><p>如此，就完成了Congi服务端配置。可以看到<code>application-zuul-dev.yml</code>文件中的数据已接口的形式可直接通过请求接口访问。注意主要使用<code>localhost:8888/config/application-zuul-dev.yml</code>访问，这样就相当于访问静态文件了。</p><h3 id="Client端"><a href="#Client端" class="headerlink" title="Client端"></a>Client端</h3><p>因为上面我们copy的<code>template-zuul</code>服务的配置文件到<code>template-config</code>服务的<code>/resources/config</code>文件夹下，所以以<code>template-zuul</code>服务举例，让<code>template-zuul</code>服务从<code>template-config</code>分布式配置中心获取配置文件。</p><ol><li>在<code>template-cloud</code>服务的<code>pom.xml</code>中添加依赖：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>修改<code>template-cloud</code>服务的<code>application.yml</code>配置文件：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">native</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">uri:</span> <span class="hljs-string">http://locahost:8888</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">application-zuul</span><br>      <span class="hljs-attr">profile:</span> <span class="hljs-string">dev</span><br><span class="hljs-comment">#      label:</span><br></code></pre></td></tr></table></figure><p>如上，删除了<code>template-zuul</code>服务配置文件中原有的配置，这里仅配置从分布式配置中心<code>template-config</code>服务中读取配置文件信息。相关参数说明：</p><ul><li><code>spring.cloud.config.uri</code>: 配置服务中心的网址</li><li><code>spring.cloud.config.name</code>: 配置文件的前缀名</li><li><code>spring.cloud.config.label</code>: 配置仓库的分支。如果是本地读取，可不配置</li><li><code>spring.cloud.config.profile</code>: 配置文件的环境标识<ul><li><code>dev</code>: 开发环境</li><li><code>test</code>: 测试环境</li><li><code>prod</code>: 生产环境</li></ul></li></ul><ol start="3"><li>重新启动<code>template-zuul</code>服务，访问：<code>localhost:9003/api/admin/hello/tycoding?token=123</code></li></ol><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/e5DpFjgnPI74oRQ.png" alt="image.png"></p><ol start="4"><li><p>注意事项：</p><p>  配置服务器的默认端口是 8888， 如果修改了默认端口，则客户端项目中就不能在<code>application.yml</code>或<code>application.properties</code>中配置<code>spring.cloud.config.uri</code>，必须在<code>bootstrap.yml</code>或是<code>bootstrap.properties</code>中配置，原因是<code>bootstrap</code>开头的配置文件会优先加载和配置。</p></li></ol><p><strong>开启Spring Boot Profile</strong></p><p>如果项目中分别部署了开发、测试、生产环境的配置文件，但如果切换不同的开发环境就可能要修改对应配置文件中的配置 ( <code>spring.cloud.config.profile</code>的参数值 )，而使用Spring Boot Profile就仅需要在启动项目时指定加载的文件，Spring就会自动加载该配置文件来启动项目。举个栗子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar template-auth-1.0.0-SNAPSHOT.jar --spring.profiles.active=prod<br></code></pre></td></tr></table></figure><p>其中<code>--spring.prodiles.active=prod</code>就会自动加载<code>application-auth-prod.yml</code>配置文件</p><h2 id="搭建ZipKin服务"><a href="#搭建ZipKin服务" class="headerlink" title="搭建ZipKin服务"></a>搭建ZipKin服务</h2><h3 id="Server端-1"><a href="#Server端-1" class="headerlink" title="Server端"></a>Server端</h3><ol><li>在<code>cloud-template</code>下创建文件夹<code>template-zipkin</code></li><li>创建<code>pom.xml</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.zipkin.java<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zipkin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.zipkin.java<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zipkin-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.zipkin.java<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zipkin-autoconfigure-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>在父工程<code>pom.xml</code>中添加ZipKin依赖的版本约定：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud.version</span>&gt;</span>Greenwich.SR1<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">zipkin.version</span>&gt;</span>2.10.1<span class="hljs-tag">&lt;/<span class="hljs-name">zipkin.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>template-eureka<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>template-admin<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>template-auth<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>template-zuul<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>template-config<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>template-zipkin<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.zipkin.java<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zipkin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;zipkin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.zipkin.java<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zipkin-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;zipkin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.zipkin.java<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zipkin-autoconfigure-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;zipkin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>创建该服务的启动器类<code>ZipKinApplication.java</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableZipkinServer</span><br><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZipkinApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(ZipkinApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>创建配置文件<code>pom.xml</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml">spring:<br>  application:<br>    name: template-zipkin<br><br>  # 解决Zipkin启动The bean &#x27;characterEncodingFilter&#x27;, defined in<br>  main:<br>    allow-bean-definition-overriding: true<br><br>server:<br>  port: 9411<br><br>eureka:<br>  client:<br>    serviceUrl:<br>      defaultZone: http://localhost:8080/eureka/<br><br>management:<br>  metrics:<br>    web:<br>      # 解决Zipkin报错IllegalArgumentException: Prometheus requires that all meters<br>      server:<br>        auto-time-requests: false<br></code></pre></td></tr></table></figure><p>注意：<code>9411</code>是默认端口</p><ol start="6"><li>启动项目，访问：<code>localhost:9411</code></li></ol><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/uyKLf9UqRDgdnrO.png" alt="image.png"></p><h3 id="Client端-1"><a href="#Client端-1" class="headerlink" title="Client端"></a>Client端</h3><p>如果需要ZipKin监控所有服务的信息，需要让每个服务都成为ZipKin的服务端。</p><p>除了<code>template-zipkin</code>服务本身，其他的服务全都要成为ZipKin的客户端，以下配置需要在每个服务中都添加：</p><ol><li>修改服务的<code>pom.xml</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>修改服务的<code>application.yml</code>，如果服务的配置文件从<code>template-config</code>服务中加载的，就直接在<code>template-config</code>中配置该服务：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">zipkin:</span><br>    <span class="hljs-attr">base-url:</span> <span class="hljs-string">http://localhost:9411</span><br></code></pre></td></tr></table></figure><ol start="3"><li>按照<code>template-eureka</code>、<code>template-config</code>、<code>template-zipkin</code>、<code>template-admin</code>、<code>template-auth</code>、<code>template-zuul</code>的顺序依次启动所有服务。访问<code>localhost:8080</code>:</li></ol><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/JcD7NU4stz3uXT1.png" alt="image.png"></p><p>访问所有我们之前写好的接口，再访问<code>localhost:9411</code>:</p><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/S7MaD9iBk63dhXq.png" alt="image.png"></p><p>比如观察<code>localhost:9003/api/auth/hello/tycoding?token=123</code>接口的链路信息：</p><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/XlWT2mLDJjaSbtr.png" alt="image.png"></p><p>参数说明：</p><ul><li><code>span</code>: 基本工作单元</li><li><code>Trace</code>: 一系列Spans组成的树状结构</li><li><code>Annotation</code>: 用来即时记录一个时间的存在，比如请求的开始于结束<ul><li><code>cs</code>: Client Server，客户端发起一个请求，这个Annotation描述了这个Span的开始</li><li><code>sr</code>: Server Received，服务端获取请求并开始处理它。<code>sr - cs</code>得到网络延迟时间</li><li><code>ss</code>: Server Sent 请求处理完成，请求返回客户端。<code>ss - sr</code> 得到服务端处理请求的时间</li><li><code>cr</code>: Client Received 表明Span的结束，客户端成功接收到服务端的回复。<code>cr - cs</code>得到客户端从服务端获取回复花费的总时间。 </li></ul></li></ul><h2 id="搭建SpringBootAdmin服务"><a href="#搭建SpringBootAdmin服务" class="headerlink" title="搭建SpringBootAdmin服务"></a>搭建SpringBootAdmin服务</h2><h3 id="Server端-2"><a href="#Server端-2" class="headerlink" title="Server端"></a>Server端</h3><ol><li>在<code>cloud-template</code>下创建<code>template-boot-admin</code>文件夹</li><li>在<code>template-boot-admin</code>下创建<code>pom.xml</code></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jolokia<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jolokia-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>和ZipKin一样，SpringBootAdmin不受SpringCloud管理，所以要手动管理版本。修改父工程<code>pom.xml</code>:</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">spring-boot-admin.version</span>&gt;</span>2.1.5<span class="hljs-tag">&lt;/<span class="hljs-name">spring-boot-admin.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-boot-admin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-boot-admin.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="4"><li>创建配置文件：<code>application.yml</code></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">9004</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">template-boot-admin</span><br>  <span class="hljs-attr">zipkin:</span><br>    <span class="hljs-attr">base-url:</span> <span class="hljs-string">http://localhost:9411</span><br><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-comment"># Eureka注册中心连接地址</span><br>      <span class="hljs-comment"># 如果注册中心地址配置的域名，这里使用 http://域名/eureka/ 格式</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8080/eureka/</span><br><br><span class="hljs-attr">management:</span><br>  <span class="hljs-attr">endpoint:</span><br>    <span class="hljs-attr">health:</span><br>      <span class="hljs-attr">show-details:</span> <span class="hljs-string">always</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">health,info</span><br></code></pre></td></tr></table></figure><ol start="5"><li>创建该服务的启动器类：<code>BootAdminApplication.java</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAdminServer</span><br><span class="hljs-meta">@EnableEurekaClient</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BootAdminApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(BootAdminApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Client端-2"><a href="#Client端-2" class="headerlink" title="Client端"></a>Client端</h3><p>和ZipKin一样，如果需要SpringBootAdmin监控所有服务，就必须让所有服务都成为SpringBootAdmin的客户端。除了<code>template-boot-admin</code>服务本身，其他所有的服务都执行下列配置：</p><ol><li>修改<code>pom.xml</code>，添加如下配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>修改<code>application.yml</code>，添加如下配置。如果服务的配置加载于Config配置中心，就修改配置中心的配置文件。</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">boot:</span><br>    <span class="hljs-attr">admin:</span><br>      <span class="hljs-attr">client:</span><br>        <span class="hljs-attr">url:</span> <span class="hljs-string">http://localhost:9004</span><br></code></pre></td></tr></table></figure><ol start="3"><li><p>按照<code>template-eureka</code>、<code>template-config</code>、<code>template-zipkin</code>、<code>template-boot-admin</code>、<code>template-admin</code>、<code>template-auth</code>、<code>template-zuul</code> 顺序依次启动服务，查看<strong>Eureka</strong>访问<code>http://localhost:8080</code>，检查各服务状态：</p><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/Rkva3ECl4jHrJNB.png" alt="image.png"></p></li><li><p>查看<strong>SpringBootAdmin</strong>，访问 <code>http://localhost:9004/</code><br><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/HC2DmONLYzblswB.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/N25ROMD8uhKdxX1.png" alt="image.png"></p></li></ol><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>请按照如下顺序依次启动服务：</p><ul><li>1.<code>template-eureka</code>: 分布式服务注册中心</li><li>2.<code>template-config</code>: 分布式配置中心</li><li>3.<code>template-zipkin</code>: 分布式服务链路追踪</li><li>4.<code>template-boot-admin</code>: 分布式服务监控中心</li><li>5.<code>template-admin</code>: 服务提供者</li><li>6.<code>template-auth</code>: 服务消费者</li><li>7.<code>template-zuul</code>: 分布式API网关</li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Cloud</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZooKeeper Docker Cluster(ZK伪集群)</title>
    <link href="/2019/06/15/ZooKeeper-Docker-Cluster-ZK%E4%BC%AA%E9%9B%86%E7%BE%A4/"/>
    <url>/2019/06/15/ZooKeeper-Docker-Cluster-ZK%E4%BC%AA%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1. 概述"></a>1.1. 概述</h3><p>原来搭建 zookeeper 集群时，都是要一个个去搭建、配置、启动，但总体部署起来还有有点麻烦的，尤其是当你只需要一个测试环境时，就更没有必要大费周章的去搭建 zookeeper 集群了，使用了 Docker 之后，大大简化的集群搭建的步骤，而且还可以重复利用配置文件。</p><p>尤其是在测试时，大大的方便了我们搭建集群的时间。</p><span id="more"></span><p>Docker 的安装详见《<a href="http://ericshen.tech/2019/04/15/Ubuntu安装Dokcer-CE/">Linux安装Dokcer CE</a>》</p><h3 id="1-2-环境"><a href="#1-2-环境" class="headerlink" title="1.2 . 环境"></a>1.2 . 环境</h3><ul><li><p>Ubuntu 18.04.3 LTS</p></li><li><p>Docker 19.03.2, build 6a30dfc</p><p>[TOC]</p></li></ul><h2 id="2-zk镜像的基本操作"><a href="#2-zk镜像的基本操作" class="headerlink" title="2. zk镜像的基本操作"></a>2. zk镜像的基本操作</h2><h3 id="2-1-这里我们使用-zookeeper3-5-的版本"><a href="#2-1-这里我们使用-zookeeper3-5-的版本" class="headerlink" title="2.1 这里我们使用 zookeeper3.5 的版本"></a>2.1 这里我们使用 zookeeper3.5 的版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull zookeeper:3.5<br></code></pre></td></tr></table></figure><h3 id="2-2-出现如下结果时，说明镜像已经下载完成"><a href="#2-2-出现如下结果时，说明镜像已经下载完成" class="headerlink" title="2.2 出现如下结果时，说明镜像已经下载完成"></a>2.2 出现如下结果时，说明镜像已经下载完成</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">3</span>.<span class="hljs-number">5</span>: Pulling from library/zookeeper<br><span class="hljs-attribute">ff3a5c916c92</span>: Pull complete <br><span class="hljs-attribute">5de5f69f42d7</span>: Pull complete <br><span class="hljs-attribute">fa7536dd895a</span>: Pull complete <br><span class="hljs-attribute">644150d38454</span>: Pull complete <br><span class="hljs-attribute">9ff28e2fa4ed</span>: Pull complete <br><span class="hljs-attribute">51e97a19e3a8</span>: Pull complete <br><span class="hljs-attribute">13b26111158e</span>: Pull complete <br><span class="hljs-attribute">Digest</span>: sha<span class="hljs-number">256</span>:<span class="hljs-number">18</span>b<span class="hljs-number">81</span>f<span class="hljs-number">09</span>a<span class="hljs-number">371</span>e<span class="hljs-number">69</span>be<span class="hljs-number">882</span>dd<span class="hljs-number">759</span>c<span class="hljs-number">93</span>ad<span class="hljs-number">9</span>d<span class="hljs-number">450</span>d<span class="hljs-number">7</span>c<span class="hljs-number">6</span>a<span class="hljs-number">628458</span>b<span class="hljs-number">2</span>b<span class="hljs-number">38123</span>c<span class="hljs-number">078</span>ba<span class="hljs-number">01</span>ae<br><span class="hljs-attribute">Status</span>: Downloaded newer image for zookeeper:<span class="hljs-number">3</span>.<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h4 id="2-2-1-运行如下命令启动一个-zookeeper-实例-默认端口-2181"><a href="#2-2-1-运行如下命令启动一个-zookeeper-实例-默认端口-2181" class="headerlink" title="2.2.1 运行如下命令启动一个 zookeeper 实例, 默认端口 2181"></a>2.2.1 运行如下命令启动一个 zookeeper 实例, 默认端口 2181</h4><h4 id="2-2-2-查看运行日志"><a href="#2-2-2-查看运行日志" class="headerlink" title="2.2.2 查看运行日志"></a>2.2.2 查看运行日志</h4><h4 id="2-2-3-输出如下-说明启动成功"><a href="#2-2-3-输出如下-说明启动成功" class="headerlink" title="2.2.3 输出如下, 说明启动成功"></a>2.2.3 输出如下, 说明启动成功</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ZooKeeper JMX enabled by default<br>Using config: /conf/zoo.cfg<br>2018-04-06 14:26:29,648 [myid:] - <span class="hljs-builtin-name">INFO</span>  [main:QuorumPeerConfig@117] - Reading configuration <span class="hljs-keyword">from</span>: /conf/zoo.cfg<br>2018-04-06 14:26:29,651 [myid:] - <span class="hljs-builtin-name">INFO</span>  [main:QuorumPeerConfig@317] - clientPort is <span class="hljs-keyword">not</span> set<br>2018-04-06 14:26:29,651 [myid:] - <span class="hljs-builtin-name">INFO</span>  [main:QuorumPeerConfig@331] - secureClientPort is <span class="hljs-keyword">not</span> set<br>2018-04-06 14:26:29,655 [myid:] - WARN  [main:QuorumPeerConfig@590] - <span class="hljs-literal">No</span><span class="hljs-built_in"> server </span>failure will be tolerated. You need at least 3 servers.<br>    [省略若干<span class="hljs-built_in">..</span>. ]<br>2018-04-06 14:26:30,164 [myid:1] - <span class="hljs-builtin-name">INFO</span>  [QuorumPeer[<span class="hljs-attribute">myid</span>=1](<span class="hljs-attribute">plain</span>=/0.0.0.0:2181)(secure=disabled):ContainerManager@64] - Using <span class="hljs-attribute">checkIntervalMs</span>=60000 <span class="hljs-attribute">maxPerMinute</span>=10000<br></code></pre></td></tr></table></figure><h3 id="2-3-使用-ZK-命令行客户端连接-ZK"><a href="#2-3-使用-ZK-命令行客户端连接-ZK" class="headerlink" title="2.3 使用 ZK 命令行客户端连接 ZK"></a>2.3 使用 ZK 命令行客户端连接 ZK</h3><p>因为刚才我们启动的那个 ZK 容器并没有绑定宿主机的端口, 因此我们不能直接访问它. 但是我们可以通过 Docker 的 link 机制来对这个 ZK 容器进行访问. 执行如下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --rm --link my_zk:my_zk2 zookeeper:3.5 zkCli.sh -server my_zk2<br></code></pre></td></tr></table></figure><blockquote><p>这个命令的含义是:</p></blockquote><ul><li>启动一个 <code>zookeeper</code> 镜像, 并运行这个镜像内的 <code>zkCli.sh</code> 命令, 命令参数是 <code>&quot;-server my_zk2&quot;</code></li><li>将我们先前启动的名为 <code>my_zk</code> 的容器连接 (link) 到我们新建的这个容器上, 并将其主机名命名为 <code>my_zk2</code></li></ul><h2 id="3-zk-集群"><a href="#3-zk-集群" class="headerlink" title="3. zk 集群"></a>3. zk 集群</h2><p>因为一个一个地启动 zk 太麻烦了, 所以为了方便起见, 我直接使用 docker-compose 来启动 zk 集群.</p><h3 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h3><ul><li>首先创建一个名为 docker-compose.yml 的文件, 其内容如下:</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.1&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">zoo1:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">zookeeper</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">zoo1</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">zoo1</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">2181</span><span class="hljs-string">:2181</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">ZOO_MY_ID:</span> <span class="hljs-number">1</span><br>      <span class="hljs-attr">ZOO_SERVERS:</span> <span class="hljs-string">server.1=0.0.0.0:2888:3888;2181</span> <span class="hljs-string">server.2=zoo2:2888:3888;2181</span> <span class="hljs-string">server.3=zoo3:2888:3888;2181</span><br><br>  <span class="hljs-attr">zoo2:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">zookeeper</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">zoo2</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">zoo2</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">2182</span><span class="hljs-string">:2181</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">ZOO_MY_ID:</span> <span class="hljs-number">2</span><br>      <span class="hljs-attr">ZOO_SERVERS:</span> <span class="hljs-string">server.1=zoo1:2888:3888;2181</span> <span class="hljs-string">server.2=0.0.0.0:2888:3888;2181</span> <span class="hljs-string">server.3=zoo3:2888:3888;2181</span><br><br>  <span class="hljs-attr">zoo3:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">zookeeper</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">zoo3</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">zoo3</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">2183</span><span class="hljs-string">:2181</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">ZOO_MY_ID:</span> <span class="hljs-number">3</span><br>      <span class="hljs-attr">ZOO_SERVERS:</span> <span class="hljs-string">server.1=zoo1:2888:3888;2181</span> <span class="hljs-string">server.2=zoo2:2888:3888;2181</span> <span class="hljs-string">server.3=0.0.0.0:2888:3888;2181</span><br></code></pre></td></tr></table></figure><p>这个配置文件会告诉 Docker 分别运行三个 zookeeper 镜像, 并分别将本地的 2181, 2182, 2183 端口绑定到对应的容器的 2181 端口上. <code>ZOO_MY_ID</code> 和 <code>ZOO_SERVERS</code> 是搭建 ZK 集群需要设置的两个环境变量, 其中 <code>ZOO_MY_ID</code> 表示 zk 服务的 id, 它是 1-255 之间的整数, 必须在集群中唯一. <code>ZOO_SERVERS</code> 是 zk 集群的主机列表.</p><ul><li>接着我们在 docker-compose.yml 当前目录下运行如下命令, 就可以启动 zk 集群了:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose up -d<br></code></pre></td></tr></table></figure><p><strong>注：如果出现以下错误，参考《<a href="https://ericshen.coding.me/2019/10/15/Linux%E5%AE%89%E8%A3%85Dokcer-CE/">Linux安装Dokcer CE</a>》的 4.4 开启 Docker Remote API。</strong></p><blockquote><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">ERROR: </span>Couldn&#x27;t connect to Docker daemon at http+docker://localhost - is &gt; it running?<br><br>If it&#x27;s at a non-standard location, specify the URL with the DOCKER_HOST &gt; environment variable.<br></code></pre></td></tr></table></figure></blockquote><ul><li>执行上述命令成功后, 运行 <code>docker-compose ps</code> 命令可以查看启动的 zk 容器:</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">Name              Command               State                          Ports<br>----------------------------------------------------------------------------------------------------<br>zoo1   <span class="hljs-regexp">/docker-entrypoint.sh zkSe ...   Up      0.0.0.0:2181-&gt;2181/</span>tcp, <span class="hljs-number">2888</span><span class="hljs-regexp">/tcp, 3888/</span>tcp, <span class="hljs-number">8080</span>/tcp<br>zoo2   <span class="hljs-regexp">/docker-entrypoint.sh zkSe ...   Up      0.0.0.0:2182-&gt;2181/</span>tcp, <span class="hljs-number">2888</span><span class="hljs-regexp">/tcp, 3888/</span>tcp, <span class="hljs-number">8080</span>/tcp<br>zoo3   <span class="hljs-regexp">/docker-entrypoint.sh zkSe ...   Up      0.0.0.0:2183-&gt;2181/</span>tcp, <span class="hljs-number">2888</span><span class="hljs-regexp">/tcp, 3888/</span>tcp, <span class="hljs-number">8080</span>/tcp<br><br></code></pre></td></tr></table></figure><h3 id="3-2-使用-Docker-命令行客户端连接-zk-集群"><a href="#3-2-使用-Docker-命令行客户端连接-zk-集群" class="headerlink" title="3.2 使用 Docker 命令行客户端连接 zk 集群"></a>3.2 使用 Docker 命令行客户端连接 zk 集群</h3><p>通过 <code>docker-compose ps</code> 命令, 我们知道启动的 zk 集群的三个主机名分别是 zoo1, zoo2, zoo3, 因此我们分别 <code>link</code> 它们即可:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --rm \<br>--link zoo1:zk1 \<br>--link zoo2:zk2 \<br>--link zoo3:zk3 \<br>--net pseudo_cluster_default \<br>zookeeper zkCli.sh -server zk1:2181,zk2:2181,zk3:2181<br><br></code></pre></td></tr></table></figure><blockquote><p><code>net</code>为容器所使用的的<code>network</code>，若未通过<code>docker-compose.yml</code>指定，默认为<code>$pwd_dafult,</code></p><p>通过<code>docker inspect zoo1 | grep Networks -A 20</code>可以查看所使用的network名称</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;Networks&quot;</span>: &#123;<br>             <span class="hljs-string">&quot;pseudo_cluster_default&quot;</span>: &#123; <span class="hljs-meta"># network名称</span><br>                 <span class="hljs-string">&quot;IPAMConfig&quot;</span>: <span class="hljs-literal">null</span>,<br>                 <span class="hljs-string">&quot;Links&quot;</span>: <span class="hljs-literal">null</span>,<br>                 <span class="hljs-string">&quot;Aliases&quot;</span>: [<br>                     <span class="hljs-string">&quot;ad0acab9b92f&quot;</span>,<br>                     <span class="hljs-string">&quot;zoo1&quot;</span><br>                 ],<br>                 <span class="hljs-string">&quot;NetworkID&quot;</span>: <span class="hljs-string">&quot;c40c9639a37ebc901369a762ec69dedd137bcdf22a1277811e592790fdaf9f08&quot;</span>,<br>                 <span class="hljs-string">&quot;EndpointID&quot;</span>: <span class="hljs-string">&quot;708837900be7d8fda10d7469791bc58f335e13804718c46267b37a908e3f9140&quot;</span>,<br>                 <span class="hljs-string">&quot;Gateway&quot;</span>: <span class="hljs-string">&quot;172.28.0.1&quot;</span>,<br>                 <span class="hljs-string">&quot;IPAddress&quot;</span>: <span class="hljs-string">&quot;172.28.0.3&quot;</span>,<br>                 <span class="hljs-string">&quot;IPPrefixLen&quot;</span>: <span class="hljs-number">16</span>,<br>                 <span class="hljs-string">&quot;IPv6Gateway&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>                 <span class="hljs-string">&quot;GlobalIPv6Address&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>                 <span class="hljs-string">&quot;GlobalIPv6PrefixLen&quot;</span>: <span class="hljs-number">0</span>,<br>                 <span class="hljs-string">&quot;MacAddress&quot;</span>: <span class="hljs-string">&quot;02:42:ac:1c:00:03&quot;</span>,<br>                 <span class="hljs-string">&quot;DriverOpts&quot;</span>: <span class="hljs-literal">null</span><br>             &#125;<br>         &#125;<br>     &#125;<br><br></code></pre></td></tr></table></figure></blockquote><p><strong>输出如下：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs awk">Connecting to zk1:<span class="hljs-number">2181</span>,zk2:<span class="hljs-number">2181</span>,zk3:<span class="hljs-number">2181</span><br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">485</span> [myid:] - INFO  [main:Environment@<span class="hljs-number">109</span>] - Client environment:zookeeper.version=<span class="hljs-number">3.5</span>.<span class="hljs-number">5</span>-<span class="hljs-number">390</span>fe37ea45dee01bf87dc1c042b5e3dcce88653, built on <span class="hljs-number">05</span><span class="hljs-regexp">/03/</span><span class="hljs-number">2019</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span> GMT<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">487</span> [myid:] - INFO  [main:Environment@<span class="hljs-number">109</span>] - Client environment:host.name=b017d561bf98<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">488</span> [myid:] - INFO  [main:Environment@<span class="hljs-number">109</span>] - Client environment:java.version=<span class="hljs-number">1.8</span>.<span class="hljs-number">0</span>_222<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">489</span> [myid:] - INFO  [main:Environment@<span class="hljs-number">109</span>] - Client environment:java.vendor=Oracle Corporation<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">489</span> [myid:] - INFO  [main:Environment@<span class="hljs-number">109</span>] - Client environment:java.home=<span class="hljs-regexp">/usr/</span>local/openjdk-<span class="hljs-number">8</span><br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">489</span> [myid:] - INFO  [main:Environment@<span class="hljs-number">109</span>] - Client environment:java.class.path=<span class="hljs-regexp">/apache-zookeeper-3.5.5-bin/</span>bin<span class="hljs-regexp">/../</span>zookeeper-server<span class="hljs-regexp">/target/</span>classes:<span class="hljs-regexp">/apache-zookeeper-3.5.5-bin/</span>bin<span class="hljs-regexp">/../</span>build<span class="hljs-regexp">/classes:/</span>apache-zookeeper-<span class="hljs-number">3.5</span>.<span class="hljs-number">5</span>-bin<span class="hljs-regexp">/bin/</span>..<span class="hljs-regexp">/zookeeper-server/</span>target<span class="hljs-regexp">/lib/</span>*.jar:<span class="hljs-regexp">/apache-zookeeper-3.5.5-bin/</span>bin<span class="hljs-regexp">/../</span>build<span class="hljs-regexp">/lib/</span>*.jar:<span class="hljs-regexp">/apache-zookeeper-3.5.5-bin/</span>bin<span class="hljs-regexp">/../</span>lib<span class="hljs-regexp">/zookeeper-jute-3.5.5.jar:/</span>apache-zookeeper-<span class="hljs-number">3.5</span>.<span class="hljs-number">5</span>-bin<span class="hljs-regexp">/bin/</span>..<span class="hljs-regexp">/lib/</span>zookeeper-<span class="hljs-number">3.5</span>.<span class="hljs-number">5</span>.jar:<span class="hljs-regexp">/apache-zookeeper-3.5.5-bin/</span>bin<span class="hljs-regexp">/../</span>lib<span class="hljs-regexp">/slf4j-log4j12-1.7.25.jar:/</span>apache-zookeeper-<span class="hljs-number">3.5</span>.<span class="hljs-number">5</span>-bin<span class="hljs-regexp">/bin/</span>..<span class="hljs-regexp">/lib/</span>slf4j-api-<span class="hljs-number">1.7</span>.<span class="hljs-number">25</span>.jar:<span class="hljs-regexp">/apache-zookeeper-3.5.5-bin/</span>bin<span class="hljs-regexp">/../</span>lib<span class="hljs-regexp">/netty-all-4.1.29.Final.jar:/</span>apache-zookeeper-<span class="hljs-number">3.5</span>.<span class="hljs-number">5</span>-bin<span class="hljs-regexp">/bin/</span>..<span class="hljs-regexp">/lib/</span>log4j-<span class="hljs-number">1.2</span>.<span class="hljs-number">17</span>.jar:<span class="hljs-regexp">/apache-zookeeper-3.5.5-bin/</span>bin<span class="hljs-regexp">/../</span>lib<span class="hljs-regexp">/json-simple-1.1.1.jar:/</span>apache-zookeeper-<span class="hljs-number">3.5</span>.<span class="hljs-number">5</span>-bin<span class="hljs-regexp">/bin/</span>..<span class="hljs-regexp">/lib/</span>jline-<span class="hljs-number">2.11</span>.jar:<span class="hljs-regexp">/apache-zookeeper-3.5.5-bin/</span>bin<span class="hljs-regexp">/../</span>lib<span class="hljs-regexp">/jetty-util-9.4.17.v20190418.jar:/</span>apache-zookeeper-<span class="hljs-number">3.5</span>.<span class="hljs-number">5</span>-bin<span class="hljs-regexp">/bin/</span>..<span class="hljs-regexp">/lib/</span>jetty-servlet-<span class="hljs-number">9.4</span>.<span class="hljs-number">17</span>.v20190418.jar:<span class="hljs-regexp">/apache-zookeeper-3.5.5-bin/</span>bin<span class="hljs-regexp">/../</span>lib<span class="hljs-regexp">/jetty-server-9.4.17.v20190418.jar:/</span>apache-zookeeper-<span class="hljs-number">3.5</span>.<span class="hljs-number">5</span>-bin<span class="hljs-regexp">/bin/</span>..<span class="hljs-regexp">/lib/</span>jetty-security-<span class="hljs-number">9.4</span>.<span class="hljs-number">17</span>.v20190418.jar:<span class="hljs-regexp">/apache-zookeeper-3.5.5-bin/</span>bin<span class="hljs-regexp">/../</span>lib<span class="hljs-regexp">/jetty-io-9.4.17.v20190418.jar:/</span>apache-zookeeper-<span class="hljs-number">3.5</span>.<span class="hljs-number">5</span>-bin<span class="hljs-regexp">/bin/</span>..<span class="hljs-regexp">/lib/</span>jetty-http-<span class="hljs-number">9.4</span>.<span class="hljs-number">17</span>.v20190418.jar:<span class="hljs-regexp">/apache-zookeeper-3.5.5-bin/</span>bin<span class="hljs-regexp">/../</span>lib<span class="hljs-regexp">/javax.servlet-api-3.1.0.jar:/</span>apache-zookeeper-<span class="hljs-number">3.5</span>.<span class="hljs-number">5</span>-bin<span class="hljs-regexp">/bin/</span>..<span class="hljs-regexp">/lib/</span>jackson-databind-<span class="hljs-number">2.9</span>.<span class="hljs-number">8</span>.jar:<span class="hljs-regexp">/apache-zookeeper-3.5.5-bin/</span>bin<span class="hljs-regexp">/../</span>lib<span class="hljs-regexp">/jackson-core-2.9.8.jar:/</span>apache-zookeeper-<span class="hljs-number">3.5</span>.<span class="hljs-number">5</span>-bin<span class="hljs-regexp">/bin/</span>..<span class="hljs-regexp">/lib/</span>jackson-annotations-<span class="hljs-number">2.9</span>.<span class="hljs-number">0</span>.jar:<span class="hljs-regexp">/apache-zookeeper-3.5.5-bin/</span>bin<span class="hljs-regexp">/../</span>lib<span class="hljs-regexp">/commons-cli-1.2.jar:/</span>apache-zookeeper-<span class="hljs-number">3.5</span>.<span class="hljs-number">5</span>-bin<span class="hljs-regexp">/bin/</span>..<span class="hljs-regexp">/lib/</span>audience-annotations-<span class="hljs-number">0.5</span>.<span class="hljs-number">0</span>.jar:<span class="hljs-regexp">/apache-zookeeper-3.5.5-bin/</span>bin<span class="hljs-regexp">/../</span>zookeeper-*.jar:<span class="hljs-regexp">/apache-zookeeper-3.5.5-bin/</span>bin<span class="hljs-regexp">/../</span>zookeeper-server<span class="hljs-regexp">/src/m</span>ain<span class="hljs-regexp">/resources/</span>lib<span class="hljs-regexp">/*.jar:/</span>conf:<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">490</span> [myid:] - INFO  [main:Environment@<span class="hljs-number">109</span>] - Client environment:java.library.path=<span class="hljs-regexp">/usr/</span>java<span class="hljs-regexp">/packages/</span>lib<span class="hljs-regexp">/amd64:/u</span>sr<span class="hljs-regexp">/lib64:/</span>lib64:<span class="hljs-regexp">/lib:/u</span>sr/lib<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">490</span> [myid:] - INFO  [main:Environment@<span class="hljs-number">109</span>] - Client environment:java.io.tmpdir=/tmp<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">490</span> [myid:] - INFO  [main:Environment@<span class="hljs-number">109</span>] - Client environment:java.compiler=&lt;NA&gt;<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">490</span> [myid:] - INFO  [main:Environment@<span class="hljs-number">109</span>] - Client environment:os.name=Linux<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">490</span> [myid:] - INFO  [main:Environment@<span class="hljs-number">109</span>] - Client environment:os.arch=amd64<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">490</span> [myid:] - INFO  [main:Environment@<span class="hljs-number">109</span>] - Client environment:os.version=<span class="hljs-number">4.15</span>.<span class="hljs-number">0</span>-<span class="hljs-number">65</span>-generic<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">490</span> [myid:] - INFO  [main:Environment@<span class="hljs-number">109</span>] - Client environment:user.name=root<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">490</span> [myid:] - INFO  [main:Environment@<span class="hljs-number">109</span>] - Client environment:user.home=/root<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">491</span> [myid:] - INFO  [main:Environment@<span class="hljs-number">109</span>] - Client environment:user.dir=/apache-zookeeper-<span class="hljs-number">3.5</span>.<span class="hljs-number">5</span>-bin<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">491</span> [myid:] - INFO  [main:Environment@<span class="hljs-number">109</span>] - Client environment:os.memory.free=<span class="hljs-number">55</span>MB<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">492</span> [myid:] - INFO  [main:Environment@<span class="hljs-number">109</span>] - Client environment:os.memory.max=<span class="hljs-number">228</span>MB<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">493</span> [myid:] - INFO  [main:Environment@<span class="hljs-number">109</span>] - Client environment:os.memory.total=<span class="hljs-number">59</span>MB<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">496</span> [myid:] - INFO  [main:ZooKeeper@<span class="hljs-number">868</span>] - Initiating client connection, connectString=zk1:<span class="hljs-number">2181</span>,zk2:<span class="hljs-number">2181</span>,zk3:<span class="hljs-number">2181</span> sessionTimeout=<span class="hljs-number">30000</span> watcher=org.apache.zookeeper.ZooKeeperMain<span class="hljs-variable">$MyWatcher</span>@<span class="hljs-number">3</span>b95a09c<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">501</span> [myid:] - INFO  [main:X509Util@<span class="hljs-number">79</span>] - Setting -D jdk.tls.rejectClientInitiatedRenegotiation=true to disable client-initiated TLS renegotiation<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">508</span> [myid:] - INFO  [main:ClientCnxnSocket@<span class="hljs-number">237</span>] - jute.maxbuffer value is <span class="hljs-number">4194304</span> Bytes<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">515</span> [myid:] - INFO  [main:ClientCnxn@<span class="hljs-number">1653</span>] - zookeeper.request.timeout value is <span class="hljs-number">0</span>. feature enabled=<br>Welcome to ZooKeeper!<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">525</span> [myid:zk1:<span class="hljs-number">2181</span>] - INFO  [main-SendThread(zk1:<span class="hljs-number">2181</span>):ClientCnxn<span class="hljs-variable">$SendThread</span>@<span class="hljs-number">1112</span>] - Opening socket connection to server zk1/<span class="hljs-number">172.28</span>.<span class="hljs-number">0.3</span>:<span class="hljs-number">2181</span>. Will not attempt to authenticate using SASL (unknown error)<br>JLine support is enabled<br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">587</span> [myid:zk1:<span class="hljs-number">2181</span>] - INFO  [main-SendThread(zk1:<span class="hljs-number">2181</span>):ClientCnxn<span class="hljs-variable">$SendThread</span>@<span class="hljs-number">959</span>] - Socket connection established, initiating session, client: <span class="hljs-regexp">/172.28.0.5:35980, server: zk1/</span><span class="hljs-number">172.28</span>.<span class="hljs-number">0.3</span>:<span class="hljs-number">2181</span><br><span class="hljs-number">2019</span>-<span class="hljs-number">10</span>-<span class="hljs-number">15</span> <span class="hljs-number">12</span>:<span class="hljs-number">07</span>:<span class="hljs-number">11</span>,<span class="hljs-number">607</span> [myid:zk1:<span class="hljs-number">2181</span>] - INFO  [main-SendThread(zk1:<span class="hljs-number">2181</span>):ClientCnxn<span class="hljs-variable">$SendThread</span>@<span class="hljs-number">1394</span>] - Session establishment complete on server zk1/<span class="hljs-number">172.28</span>.<span class="hljs-number">0.3</span>:<span class="hljs-number">2181</span>, sessionid = <span class="hljs-number">0</span>x100010585200003, negotiated timeout = <span class="hljs-number">30000</span><br><br>WATCHER::<br><br>WatchedEvent state:SyncConnected type:None path:null<br>[zk: zk1:<span class="hljs-number">2181</span>,zk2:<span class="hljs-number">2181</span>,zk3:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">0</span>]  <span class="hljs-comment"># 连接成功，进入命令行交互模式</span><br><br></code></pre></td></tr></table></figure><h3 id="3-3-通过本地主机连接-ZK-集群"><a href="#3-3-通过本地主机连接-ZK-集群" class="headerlink" title="3.3 通过本地主机连接 ZK 集群"></a>3.3 通过本地主机连接 ZK 集群</h3><p>因为我们分别将 zoo1, zoo2, zoo3 的 2181 端口映射到了本地主机的 2181, 2182, 2183 端口上, 因此我们使用如下命令即可连接 zk 集群了:</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">zkCli.sh -server <span class="hljs-number">192.192.1.12</span>:<span class="hljs-number">2181,192.192</span>.<span class="hljs-number">1.12:2182</span>,<span class="hljs-number">192.192.1.12</span>:<span class="hljs-number">2183</span><br><br></code></pre></td></tr></table></figure><blockquote><p>注: <code>zkCli.sh</code> 工具需要到 <a href="http://zookeeper.apache.org/">Zookeeper 官网</a>下载安装包里面会有</p></blockquote><blockquote><p>Mac可以使用<code>homebrew</code>进行安装<code>brew install zookeeper</code></p></blockquote><ul><li>执行<br><code>zkCli -server 192.192.1.12:2181,192.192.1.12:2182,192.192.1.12:2183</code></li><li>结果</li></ul><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dns">Connecting to <span class="hljs-number">192.192.1.12</span>:<span class="hljs-number">2181,192.192</span>.<span class="hljs-number">1.12:2182</span>,<span class="hljs-number">192.192.1.12</span>:<span class="hljs-number">2183</span><br>Welcome to ZooKeeper!<br>JLine support is enabled<br>[zk: <span class="hljs-number">192.192.1.12</span>:<span class="hljs-number">2181,192.192</span>.<span class="hljs-number">1.12:2182</span>,<span class="hljs-number">192.192.1.12</span>:<span class="hljs-number">2183</span>(CONNECTING) <span class="hljs-number">0</span>] # 连接成功，进入命令行交互模式<br><br></code></pre></td></tr></table></figure><h3 id="3-4-以docker-exec交互方式进入容器查看"><a href="#3-4-以docker-exec交互方式进入容器查看" class="headerlink" title="3.4 以docker exec交互方式进入容器查看"></a>3.4 以docker exec交互方式进入容器查看</h3><ul><li><p>宿主机内执行<code>docker exec -it zoo1  /bin/bash</code>进入容器，修改<code>container_name</code>为<code>zoo2</code>或<code>zoo3</code>即可查看其他zk节点</p></li><li><p>进入容器后执行<code>./bin/zkServer.sh status</code></p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it zoo1  /bin/bash <br>root@zoo1:/apache-zookeeper-3.5.5-bin<span class="hljs-comment"># ./bin/zkServer.sh status</span><br>ZooKeeper JMX enabled by default<br>Using config: /conf/zoo.cfg<br>Client port found: 2181. Client address: localhost.<br>Mode: follower<br>root@zoo1:/apache-zookeeper-3.5.5-bin<span class="hljs-comment">#</span><br><br></code></pre></td></tr></table></figure><h3 id="3-5-停止和关闭集群"><a href="#3-5-停止和关闭集群" class="headerlink" title="3.5 停止和关闭集群"></a>3.5 停止和关闭集群</h3><p><code>cd</code>到<code>docker-compose.yml</code><strong>文件路径下</strong></p><p>停止集群</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker-compose <span class="hljs-built_in">stop</span><br><br></code></pre></td></tr></table></figure><p>删除集群</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker-compose  rm</span><br><br></code></pre></td></tr></table></figure><p>停止并删除</p><p><code>docker-compose down</code></p><h2 id="4-zk的其它环境变量"><a href="#4-zk的其它环境变量" class="headerlink" title="4. zk的其它环境变量"></a>4. zk的其它环境变量</h2><ul><li>ZOO_TICK_TIME<code>默认 2000. ZooKeeper 的</code>tickTime`</li><li><code>ZOO_INIT_LIMIT</code> 默认 5. ZooKeeper 的 <code>initLimit</code></li><li><code>ZOO_SYNC_LIMIT</code> 默认 2. ZooKeeper 的 <code>syncLimit</code></li><li><code>ZOO_MAX_CLIENT_CNXNS</code> 默认 60. ZooKeeper 的 <code>maxClientCnxns</code></li></ul><p>[TOC]</p>]]></content>
    
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>zk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nexus源替换及Gitlab迁移</title>
    <link href="/2019/05/22/Nexus%E6%BA%90%E6%9B%BF%E6%8D%A2%E5%8F%8AGitlab%E8%BF%81%E7%A7%BB/"/>
    <url>/2019/05/22/Nexus%E6%BA%90%E6%9B%BF%E6%8D%A2%E5%8F%8AGitlab%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="Maven镜像替换"><a href="#Maven镜像替换" class="headerlink" title="Maven镜像替换"></a>Maven镜像替换</h1><h2 id="一、替换settings文件"><a href="#一、替换settings文件" class="headerlink" title="一、替换settings文件"></a>一、替换settings文件</h2><span id="more"></span><blockquote><p>注意：<code>localRepository</code>需替换为本机仓库地址</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">Licensed to the Apache Software Foundation (ASF) under one</span><br><span class="hljs-comment">or more contributor license agreements.  See the NOTICE file</span><br><span class="hljs-comment">distributed with this work for additional information</span><br><span class="hljs-comment">regarding copyright ownership.  The ASF licenses this file</span><br><span class="hljs-comment">to you under the Apache License, Version 2.0 (the</span><br><span class="hljs-comment">&quot;License&quot;); you may not use this file except in compliance</span><br><span class="hljs-comment">with the License.  You may obtain a copy of the License at</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Unless required by applicable law or agreed to in writing,</span><br><span class="hljs-comment">software distributed under the License is distributed on an</span><br><span class="hljs-comment">&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY</span><br><span class="hljs-comment">KIND, either express or implied.  See the License for the</span><br><span class="hljs-comment">specific language governing permissions and limitations</span><br><span class="hljs-comment">under the License.</span><br><span class="hljs-comment">--&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment"> | This is the configuration file for Maven. It can be specified at two levels:</span><br><span class="hljs-comment"> |</span><br><span class="hljs-comment"> |  1. User Level. This settings.xml file provides configuration for a single user,</span><br><span class="hljs-comment"> |                 and is normally provided in $&#123;user.home&#125;/.m2/settings.xml.</span><br><span class="hljs-comment"> |</span><br><span class="hljs-comment"> |                 <span class="hljs-doctag">NOTE:</span> This location can be overridden with the CLI option:</span><br><span class="hljs-comment"> |</span><br><span class="hljs-comment"> |                 -s /path/to/user/settings.xml</span><br><span class="hljs-comment"> |</span><br><span class="hljs-comment"> |  2. Global Level. This settings.xml file provides configuration for all Maven</span><br><span class="hljs-comment"> |                 users on a machine (assuming they&#x27;re all using the same Maven</span><br><span class="hljs-comment"> |                 installation). It&#x27;s normally provided in</span><br><span class="hljs-comment"> |                 $&#123;maven.conf&#125;/settings.xml.</span><br><span class="hljs-comment"> |</span><br><span class="hljs-comment"> |                 <span class="hljs-doctag">NOTE:</span> This location can be overridden with the CLI option:</span><br><span class="hljs-comment"> |</span><br><span class="hljs-comment"> |                 -gs /path/to/global/settings.xml</span><br><span class="hljs-comment"> |</span><br><span class="hljs-comment"> | The sections in this sample file are intended to give you a running start at</span><br><span class="hljs-comment"> | getting the most out of your Maven installation. Where appropriate, the default</span><br><span class="hljs-comment"> | values (values used when the setting is not specified) are provided.</span><br><span class="hljs-comment"> |</span><br><span class="hljs-comment"> |--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">settings</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- localRepository</span><br><span class="hljs-comment">     | The path to the local repository maven will use to store artifacts.</span><br><span class="hljs-comment">     |</span><br><span class="hljs-comment">     | Default: ~/.m2/repository</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>~/.m2/repository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">pluginGroups</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">pluginGroup</span>&gt;</span>org.sonatype.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">pluginGroup</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">pluginGroups</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">servers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>administrator<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>releases<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>administrator<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>administrator<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">servers</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus Repository<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://172.16.140.153:9003/repository/maven-public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">releases</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">releases</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br>        <br>        <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>releases<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus Releases<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://172.16.140.153:9003/repository/maven-releases/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">releases</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">releases</span>&gt;</span>       <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus Snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://172.16.140.153:9003/repository/maven-snapshots/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">releases</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">releases</span>&gt;</span>          <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">pluginRepositories</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">pluginRepository</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://172.16.140.153:9003/repository/maven-public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepository</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">pluginRepository</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>releases<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://172.16.140.153:9003/repository/maven-releases/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">releases</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">releases</span>&gt;</span>       <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepository</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">pluginRepository</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://172.16.140.153:9003/repository/maven-snapshots/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">releases</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">releases</span>&gt;</span>         <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepository</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">pluginRepositories</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">activeProfiles</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">activeProfile</span>&gt;</span>nexus<span class="hljs-tag">&lt;/<span class="hljs-name">activeProfile</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">activeProfiles</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h1 id="NPM-源替换"><a href="#NPM-源替换" class="headerlink" title="NPM 源替换"></a>NPM 源替换</h1><h2 id="一、使用153私服镜像"><a href="#一、使用153私服镜像" class="headerlink" title="一、使用153私服镜像"></a>一、使用153私服镜像</h2><h3 id="1-临时使用"><a href="#1-临时使用" class="headerlink" title="1.临时使用"></a>1.临时使用</h3><p><code>npm --registry http://172.16.140.153:9003/repository/npm-nexus install express</code></p><h3 id="2-长久使用"><a href="#2-长久使用" class="headerlink" title="2.长久使用"></a>2.长久使用</h3><p><code>npm config set registry http://172.16.140.153:9003/repository/npm-nexus</code></p><h3 id="3-通过cnpm"><a href="#3-通过cnpm" class="headerlink" title="3.通过cnpm"></a>3.通过cnpm</h3><p><code>npm install -g cnpm --registry=http://172.16.140.153:9003/repository/npm-nexus</code></p><h2 id="二、恢复官方镜像"><a href="#二、恢复官方镜像" class="headerlink" title="二、恢复官方镜像"></a>二、恢复官方镜像</h2><p><code>npm config set registry https://registry.npmjs.org/</code></p><h2 id="三、查看npm源地址"><a href="#三、查看npm源地址" class="headerlink" title="三、查看npm源地址"></a>三、查看npm源地址</h2><p><code>npm config get registry</code></p><h1 id="Gitlab迁移"><a href="#Gitlab迁移" class="headerlink" title="Gitlab迁移"></a>Gitlab迁移</h1><ul><li>通过邮箱查看密码重置链接，登录后添加SSH key，头像&gt;&gt;Settings&gt;&gt;SSH Keys</li><li>修改本地已有项目的gitlab地址，cd到项目下，执行：<br>如：<code>git remote set-url origin ssh://git@172.16.140.153:10022/rs/remoteservice-new.git</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>PaaS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>nexus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nexus源替换及Gitlab迁移</title>
    <link href="/2019/05/22/Netty+Protobuf%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <url>/2019/05/22/Netty+Protobuf%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="Netty-PortoBuf实现客户端"><a href="#Netty-PortoBuf实现客户端" class="headerlink" title="Netty + PortoBuf实现客户端"></a>Netty + PortoBuf实现客户端</h2><ul><li>构建Netty 客户端</li><li>利用protobuf定义消息格式</li><li>服务端空闲检测</li><li>客户端发送心跳包与断线重连</li></ul><h2 id="构建-Netty-客户端"><a href="#构建-Netty-客户端" class="headerlink" title="构建 Netty 客户端"></a>构建 Netty 客户端</h2><p>Netty 客户端代码与服务端类似，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String HOST = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">9999</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SocketChannel socketChannel;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            doConnect(<span class="hljs-keyword">new</span> Bootstrap(), group);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Bootstrap <span class="hljs-title">doConnect</span><span class="hljs-params">(Bootstrap bootstrap, EventLoopGroup group)</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;开始连接Netty服务端&quot;</span>);<br>        <span class="hljs-keyword">if</span> (bootstrap != <span class="hljs-keyword">null</span>) &#123;<br>            bootstrap.group(group).channel(NioSocketChannel.class)<br>                .option(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>).option(ChannelOption.TCP_NODELAY, <span class="hljs-keyword">true</span>)<br>                .handler(<span class="hljs-keyword">new</span> ClientHandlerInitializer(<span class="hljs-keyword">this</span>));<br>            bootstrap.remoteAddress(HOST, PORT);<br><br>            bootstrap.connect().addListener((ChannelFutureListener) future -&gt; &#123;<br>                <span class="hljs-keyword">final</span> EventLoop eventLoop = future.channel().eventLoop();<br>                <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>                    log.info(<span class="hljs-string">&quot;连接Netty服务端成功&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    log.info(<span class="hljs-string">&quot;连接失败，进行5秒重连&quot;</span>);<br>                    future.channel().eventLoop()<br>                        .schedule(() -&gt; doConnect(<span class="hljs-keyword">new</span> Bootstrap(), eventLoop), <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>                &#125;<br>                socketChannel = (SocketChannel) future.channel();<br>            &#125;);<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> bootstrap;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(MessageBase.Message message)</span> </span>&#123;<br>        socketChannel.writeAndFlush(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用-protobuf-构建通信协议"><a href="#使用-protobuf-构建通信协议" class="headerlink" title="使用 protobuf 构建通信协议"></a>使用 protobuf 构建通信协议</h2><p>在整合使用 Netty 的过程中，我们使用 Google 的protobuf定义消息格式，下面来简单介绍下 protobuf</p><h3 id="protobuf简介"><a href="#protobuf简介" class="headerlink" title="protobuf简介"></a>protobuf简介</h3><p>Google 官方给 protobuf的定义如下：</p><blockquote><p>Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据序列化，很适合做数据存储或 RPC 数据交换格式。它可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</p></blockquote><p>在 Netty 中常用 protobuf 来做序列化方案，当然也可以用 protobuf来构建 客户端与服务端之间的通信协议</p><h3 id="为什么要用protobuf"><a href="#为什么要用protobuf" class="headerlink" title="为什么要用protobuf"></a>为什么要用protobuf</h3><p>我们这里是用 protobuf 做为我们的序列化手段，那我们为什么要使用 protobuf,而不使用其他序列化方案呢，比如 jdk 自带的序列化，Thrift,fastjson等。</p><p>首先 jdk 自带序列化手段有很多缺点，比如：</p><ul><li>序列化后的码流太大</li><li>性能太低</li><li>无法跨语言</li></ul><p>而 Google Protobuf 跨语言，支持C++、java和python。然后利用protobuf 编码后的消息更小，有利于存储和传输，并且其性能也非常高，相比其他序列化框架，它也是非常有优势的，具体的关于Java 各种序列化框架比较此处就不多说了。总之，目前Google Protobuf 广泛的被使用到各种项目，它的诸多优点让我们选择使用它。</p><h3 id="怎么使用protobuf"><a href="#怎么使用protobuf" class="headerlink" title="怎么使用protobuf"></a>怎么使用protobuf</h3><p>对于 Java 而言，使用 protobuf 主要有以下几步：</p><ul><li>在 <code>.proto</code> 文件中定义消息格式</li><li>使用 protobuf 编译器编译 <code>.proto</code>文件 成 Java 类</li><li>使用 Java 对应的 protobuf API来写或读消息</li></ul><h4 id="定义-protobuf-协议格式"><a href="#定义-protobuf-协议格式" class="headerlink" title="定义 protobuf 协议格式"></a>定义 protobuf 协议格式</h4><p>这里为我Demo里的 <code>message.proto</code>文件为例，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs proto">&#x2F;&#x2F;protobuf语法有 proto2和proto3两种，这里指定 proto3<br>syntax &#x3D; &quot;proto3&quot;;<br><br>option java_package &#x3D; &quot;com.eric.netty.protocol.protobuf&quot;;<br>option java_outer_classname &#x3D; &quot;MessageBase&quot;;<br>import &quot;google&#x2F;protobuf&#x2F;any.proto&quot;;<br>import &quot;Command.proto&quot;;<br><br>message Message &#123;<br>  string requestId &#x3D; 1;<br>  Command cmd &#x3D; 2;<br>  string msg &#x3D; 3;<br>  google.protobuf.Any data &#x3D; 4;<br>&#125;<br></code></pre></td></tr></table></figure><p>文件解读：</p><ul><li>文中的第一行指定正在使用 <code>proto3</code>语法，如果没有指定，编译器默认使用 <code>proto2</code>的语法。现在新项目中可能一般多用 <code>proto3</code>的语法，<code>proto3</code>比 <code>proto2</code>支持更多的语言但更简洁。如果首次使用 protobuf,可以选择使用 <code>proto3</code></li><li>定义 <code>.proto</code>文件时，可以标注一系列的选项，一些选项是文件级别的，比如上面的第二行和第三行，<code>java_package</code>文件选项表明protocol编译器编译 <code>.proto</code>文件生成的 Java 类所在的包，<code>java_outer_classname</code>选项表明想要生成的 Java 类的名称</li><li><code>Message</code>中定义了具体的消息格式，我这里定义了三个字段，每个字段都有唯一的一个数字标识符，这些标识符用来在消息的二进制格式中识别各个字段的</li><li><code>Message</code>中还添加了一个枚举类型，该枚举中含有类型 <code>CommandType</code>中所有的值，每个枚举类型必须将其第一个类型映射为 0，该0值为默认值。</li></ul><p><strong>消息模型定义</strong></p><p>关于消息格式，此处我只是非常非常简单的定义了几个字段，<code>requestId</code>代表消息Id,<code>CommandType</code>表示消息的类型，这里简单分为心跳消息类型和业务消息类型，然后<code>content</code>就是具体的消息内容。这里的消息格式定义是十分简陋，真正的项目实战中，关于自定义消息格式的要求是非常多的，是比较复杂的。</p><p>上面简单的介绍了 protobuf的一些语法规则，关于 protobuf语法的更多介绍参考官方文档：<a href="https://developers.google.com/protocol-buffers/docs/proto3">https://developers.google.com/protocol-buffers/docs/proto3</a></p><h4 id="使用-proto编译器编译"><a href="#使用-proto编译器编译" class="headerlink" title="使用 .proto编译器编译"></a>使用 <code>.proto</code>编译器编译</h4><p>第一步已经定义好了 protobuf的消息格式，然后我们用 <code>.proto</code>文件的编译器将我们定义的 消息格式编译生成对应的 Java类，以便于我们在项目中使用该消息类。</p><p>关于protobuf编译器的安装这里我就不细说，详情见官方文档： <a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a></p><p>安装好编译器以后，使用以下命令编译<code>.proto</code>文件：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">protoc -I = <span class="hljs-string">./</span> <span class="hljs-params">--java_out=</span><span class="hljs-string">./</span> <span class="hljs-string">./Message.proto</span><br></code></pre></td></tr></table></figure><ul><li><code>-I</code> 选项用于指定待编译的 <code>.proto</code>消息定义文件所在的目录，该选项也可以写作为 <code>--proto_path</code></li><li><code>--java_out</code>选项表示生成 Java代码后存放位置，对于不同语言，我们的选项可能不同，比如生成C++代码为 <code>--cpp_out</code></li><li>在前两个选项后再加上 待编译的消息定义文件</li></ul><h4 id="使用-Java-对应-的-protobuf-API来读写消息"><a href="#使用-Java-对应-的-protobuf-API来读写消息" class="headerlink" title="使用 Java 对应 的 protobuf API来读写消息"></a>使用 Java 对应 的 protobuf API来读写消息</h4><p>前面已经根据 <code>.proto</code>消息定义文件生成的Java类，我们这里代码根据 <code>Message.proto</code>生成了<code>MessageBase</code>类，但是要正常的使用生成的 Java 类，我们还需要引入 protobuf-java的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.protobuf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>protobuf-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用 protobuf 生成的每一个 Java类中，都会包含两种内部类：Msg 和 Msg 包含的 Builder(这里的Msg就是实际消息传输类)。具体是<code>.proto</code>中定义的每一个message 都会生成一个 Msg，每一个Msg对应一个 Builder:</p><ul><li>Buidler提供了构建类，查询类的API</li><li>Msg提供了查询，序列化，反序列化的API</li></ul><p>比如我们使用 Builder来构建 Msg,例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageBaseTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MessageBase.Message message = MessageBase.Message.newBuilder()<br>                .setRequestId(UUID.randomUUID().toString())<br>                .setContent(<span class="hljs-string">&quot;hello world&quot;</span>).build();<br>        System.out.println(<span class="hljs-string">&quot;message: &quot;</span>+message.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就不多介绍protobuf-java API的相关用法了，更多详情还是参考官方文档：<a href="https://developers.google.com/protocol-buffers/docs/reference/java/">https://developers.google.com/protocol-buffers/docs/reference/java/</a></p><h3 id="protobuf的编解码器"><a href="#protobuf的编解码器" class="headerlink" title="protobuf的编解码器"></a>protobuf的编解码器</h3><p>上面说了这么多，消息传输格式已经定义好了，但是在客户端和服务端传输过程中我们还需要对这种 protobuf格式进行编解码，当然我们可以自定义消息的编解码，<code>protobuf-java</code> 的API中提供了相关的序列化和反序列化方法。好消息是，Netty 为了支持 protobuf提供了针对 protobuf的编解码器，如下表所示（摘自《Netty实战》) ：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>ProtobufDecoder</td><td>使用 protobuf 对消息进行解码</td></tr><tr><td>ProtobufEncoder</td><td>使用 protobuf 对消息进行编码</td></tr><tr><td>ProtobufVarint32FrameDecoder</td><td>根据消息中的 Google Protocol Buffers 的 “Base 128 Varint” 整型长度字段值动态地分割所接收到的 ByteBuf</td></tr><tr><td>ProtobufVarint32LengthFieldPrepender</td><td>向 ByteBuf 前追加一个Google Protocol Buffers 的 “Base 128 Varint” 整型长度字段值</td></tr></tbody></table><p>有了这些编解码器，将其加入客户端和服务端的 ChannelPipeline中以用于对消息进行编解码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandlerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ch.pipeline()<br>                <span class="hljs-comment">//空闲检测</span><br>                .addLast(<span class="hljs-keyword">new</span> ServerIdleStateHandler())<br>                .addLast(<span class="hljs-keyword">new</span> ProtobufVarint32FrameDecoder())<br>                .addLast(<span class="hljs-keyword">new</span> ProtobufDecoder(MessageBase.Message.getDefaultInstance()))<br>                .addLast(<span class="hljs-keyword">new</span> ProtobufVarint32LengthFieldPrepender())<br>                .addLast(<span class="hljs-keyword">new</span> ProtobufEncoder())<br>                .addLast(<span class="hljs-keyword">new</span> NettyServerHandler());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="客户端心跳机制"><a href="#客户端心跳机制" class="headerlink" title="客户端心跳机制"></a>客户端心跳机制</h2><h3 id="心跳机制简介"><a href="#心跳机制简介" class="headerlink" title="心跳机制简介"></a>心跳机制简介</h3><p>心跳是在TCP长连接中，客户端与服务端之间定期发送的一种特殊的数据包，通知对方在线以确保TCP连接的有效性。</p><h3 id="如何实现心跳机制"><a href="#如何实现心跳机制" class="headerlink" title="如何实现心跳机制"></a>如何实现心跳机制</h3><p>有两种方式实现心跳机制：</p><ul><li>使用TCP协议层面的 keepalive 机制</li><li>在应用层上自定义的心跳机制</li></ul><p>TCP层面的 keepalive 机制我们在之前构建 Netty服务端和客户端启动过程中也有定义，我们需要手动开启，示例如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 设置TCP的长连接，默认的 keepalive的心跳时间是两个小时</span><br><span class="hljs-function"><span class="hljs-title">childOption</span><span class="hljs-params">(ChannelOption.SO_KEEPALIVE, true)</span></span><br></code></pre></td></tr></table></figure><p>除了开启 TCP协议的 keepalive 之外，在我研究了github的一些开源Demo发现，人们往往也会自定义自己的心跳机制，定义心跳数据包。而Netty也提供了 <strong>IdleStateHandler</strong> 来实现心跳机制</p><h3 id="Netty-实现心跳机制"><a href="#Netty-实现心跳机制" class="headerlink" title="Netty 实现心跳机制"></a>Netty 实现心跳机制</h3><p>下面来看看客户端如何实现心跳机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeartbeatHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            <span class="hljs-keyword">if</span> (evt <span class="hljs-keyword">instanceof</span> IdleStateEvent) &#123;<br>                IdleStateEvent idleStateEvent = (IdleStateEvent) evt;<br>                <span class="hljs-keyword">if</span> (idleStateEvent.state() == IdleState.WRITER_IDLE) &#123;<br>                    log.info(<span class="hljs-string">&quot;10s空闲发送消息给服务端&quot;</span>);<br>                    Message heartbeat = Message.newBuilder().setCmd(Command.PING)<br>                        .setRequestId(UUID.randomUUID().toString()).setMsg(<span class="hljs-string">&quot;heartbeat&quot;</span>).build();<br>                    <span class="hljs-comment">//发送心跳消息，并在发送失败时关闭该连接</span><br>                    ctx.writeAndFlush(heartbeat).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">super</span>.userEventTriggered(ctx, evt);<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们这里创建了一个ChannelHandler类并重写了<code>userEventTriggered</code>方法，在该方法里实现发送心跳数据包的逻辑，同时将 <code>IdleStateEvent</code>类加入逻辑处理链上。</p><p>实际上是当连接空闲时间太长时，将会触发一个 <code>IdleStateEvent</code>事件，然后我们调用 <code>userEventTriggered</code>来处理该 <code>IdleStateEvent</code>事件。</p><p>当启动客户端和服务端之后，控制台打印心跳</p><p>上面我们只讨论了客户端发送心跳消息给服务端，那么服务端还需要发心跳消息给客户端吗？</p><p>一般情况是，对于长连接而言，一种方案是两边都发送心跳消息，另一种是服务端作为被动接收一方，如果一段时间内服务端没有收到心跳包那么就直接断开连接。</p><p>我们这里采用第二种方案，只需要客户端发送心跳消息，然后服务端被动接收，然后设置一段时间，在这段时间内如果服务端没有收到任何消息，那么就主动断开连接，这也就是后面要说的 <strong>空闲检测</strong></p><h2 id="Netty-客户端断线重连"><a href="#Netty-客户端断线重连" class="headerlink" title="Netty 客户端断线重连"></a>Netty 客户端断线重连</h2><p>一般有以下两种情况，Netty 客户端需要重连服务端：</p><ul><li>Netty 客户端启动时，服务端挂掉，连不上服务端</li><li>在程序运行过程中，服务端突然挂掉</li></ul><p>第一种情况实现 <code>ChannelFutureListener</code>用来监测连接是否成功，不成功就进行断连重试机制，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String HOST = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">9999</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SocketChannel socketChannel;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            doConnect(<span class="hljs-keyword">new</span> Bootstrap(), group);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Bootstrap <span class="hljs-title">doConnect</span><span class="hljs-params">(Bootstrap bootstrap, EventLoopGroup group)</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;开始连接Netty服务端&quot;</span>);<br>        <span class="hljs-keyword">if</span> (bootstrap != <span class="hljs-keyword">null</span>) &#123;<br>            bootstrap.group(group).channel(NioSocketChannel.class)<br>                .option(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>).option(ChannelOption.TCP_NODELAY, <span class="hljs-keyword">true</span>)<br>                .handler(<span class="hljs-keyword">new</span> ClientHandlerInitializer(<span class="hljs-keyword">this</span>));<br>            bootstrap.remoteAddress(HOST, PORT);<br><br>            bootstrap.connect().addListener((ChannelFutureListener) future -&gt; &#123;<br>                <span class="hljs-keyword">final</span> EventLoop eventLoop = future.channel().eventLoop();<br>                <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>                    log.info(<span class="hljs-string">&quot;连接Netty服务端成功&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    log.info(<span class="hljs-string">&quot;连接失败，进行5秒重连&quot;</span>);<br>                    future.channel().eventLoop()<br>                        .schedule(() -&gt; doConnect(<span class="hljs-keyword">new</span> Bootstrap(), eventLoop), <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>                &#125;<br>                socketChannel = (SocketChannel) future.channel();<br>            &#125;);<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> bootstrap;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(MessageBase.Message message)</span> </span>&#123;<br>        socketChannel.writeAndFlush(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ChannelFuture添加一个监听器，如果客户端连接服务端失败，调用 <code>channel().eventLoop().schedule()</code>方法执行重试逻辑。</p><p>第二种情况是运行过程中 服务端突然挂掉了，这种情况我们在处理数据读写的Handler中实现，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeartbeatHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> NettyClient nettyClient;<br>    <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            <span class="hljs-comment">//如果运行过程中服务端挂了,执行重连机制</span><br>            log.info(<span class="hljs-string">&quot;服务断开重连&quot;</span>);<br>            <span class="hljs-keyword">final</span> EventLoop eventLoop = ctx.channel().eventLoop();<br>            nettyClient.doConnect(<span class="hljs-keyword">new</span> Bootstrap(), eventLoop);<br>            <span class="hljs-keyword">super</span>.channelInactive(ctx);<br>        &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>我们这里直接在实现心跳机制的 Handler中重写<code>channelInactive</code>方法，然后在该方法中执行重试逻辑，这里注入了 <code>NettyClient</code>类，目的是方便调用 <code>NettyClient</code>的<code>start()</code>方法重新连接服务端</p><p><code>channelInactive()</code>方法是指如果当前Channel没有连接到远程节点，那么该方法将会被调用。</p><h2 id="服务端空闲检测"><a href="#服务端空闲检测" class="headerlink" title="服务端空闲检测"></a>服务端空闲检测</h2><p>空闲检测是什么？实际上空闲检测是每隔一段时间，检测这段时间内是否有数据读写。比如，服务端检测一段时间内，是否收到客户端发送来的数据，如果没有，就及时释放资源，关闭连接。</p><p>对于空闲检测，Netty 特地提供了 <strong>IdleStateHandler</strong> 来实现这个功能。下面的代码参考自<a href="https://juejin.im/book/5b4bc28bf265da0f60130116/section/5b4db16de51d4519601ab69f#heading-2">《Netty 入门与实战：仿写微信 IM 即时通讯系统》</a>中空闲检测部分的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerIdleStateHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IdleStateHandler</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置空闲检测时间为 30s</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> READER_IDLE_TIME = <span class="hljs-number">30</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServerIdleStateHandler</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(READER_IDLE_TIME, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, TimeUnit.SECONDS);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelIdle</span><span class="hljs-params">(ChannelHandlerContext ctx, IdleStateEvent evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        log.info(<span class="hljs-string">&quot;&#123;&#125; 秒内没有读取到数据,关闭连接&quot;</span>, READER_IDLE_TIME);<br>        ctx.channel().close();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Controller方法测试"><a href="#Controller方法测试" class="headerlink" title="Controller方法测试"></a>Controller方法测试</h2><p>因为这是 SpringBoot 整合 Netty 的一个Demo,我们创建一个<code>Controller</code>方法对Netty 服务端与客户端之间的通信进行测试，controller代码如下，非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerController</span> </span>&#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/send&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">send</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:\\Users\\ahsbt\\Desktop\\20140106170547843.png&quot;</span>);<br><br>        MessageBase.Message message = MessageBase.Message.newBuilder().setCmd(Command.HIGH_PHOTO)<br>            .setMsg(<span class="hljs-string">&quot;hello server&quot;</span>).setRequestId(UUID.randomUUID().toString()).setData(Any.pack(<br>                ResultBase.Result.newBuilder().setShaValue(<span class="hljs-string">&quot;&quot;</span>)<br>                    .setFile(FileTransferUtil.fileToByteString(file)).build())).build();<br>        NettyClient.sendMsg(message);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;send ok&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注入 <code>NettyClient</code>，调用其 <code>sendMsg</code>方法发送消息，结果如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">c<span class="hljs-selector-class">.p</span><span class="hljs-selector-class">.server</span><span class="hljs-selector-class">.server</span><span class="hljs-selector-class">.NettyServerHandler</span>     : 收到客户端的业务消息：requestId: <span class="hljs-string">&quot;aba74c28-1b6e-42b3-9f27-889e7044dcbf&quot;</span><br><span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;hello server&quot;</span><br></code></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://juejin.im/book/5b4bc28bf265da0f60130116">Netty 入门与实战：仿写微信 IM 即时通讯系统</a></li><li><a href="https://colobu.com/2015/08/14/netty-tcp-client-with-reconnect-handling/">Netty Client重连实现</a></li><li><a href="https://crossoverjie.top/2018/05/24/netty/Netty(1)TCP-Heartbeat/">Netty(一) SpringBoot 整合长连接心跳机制</a></li><li><a href="https://segmentfault.com/a/1190000006931568">浅析 Netty 实现心跳机制与断线重连</a></li><li><a href="https://colobu.com/2017/03/16/Protobuf3-language-guide/">[转]Protobuf3 语法指南</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>PaaS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>nexus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap：为什么容量总是为 2 的次幂</title>
    <link href="/2019/05/21/java/HashMap%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%B9%E9%87%8F%E6%80%BB%E6%98%AF%E4%B8%BA%202%20%E7%9A%84%E6%AC%A1%E5%B9%82/"/>
    <url>/2019/05/21/java/HashMap%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%B9%E9%87%8F%E6%80%BB%E6%98%AF%E4%B8%BA%202%20%E7%9A%84%E6%AC%A1%E5%B9%82/</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap：为什么容量总是为-2-的次幂"><a href="#HashMap：为什么容量总是为-2-的次幂" class="headerlink" title="HashMap：为什么容量总是为 2 的次幂"></a>HashMap：为什么容量总是为 2 的次幂</h1><p>HashMap 是根据 key 的 hash 值决策 key 放入到哪个桶（bucket）中，通过 <code>tab=[(n - 1) &amp; hash]</code> 公式计算得出。其中 tab 是一个哈希表</p><span id="more"></span><p>[TOC]</p><h2 id="1-为什么要保证-capacity-是-2-的次幂呢？"><a href="#1-为什么要保证-capacity-是-2-的次幂呢？" class="headerlink" title="1. 为什么要保证 capacity 是 2 的次幂呢？"></a><strong>1. 为什么要保证 capacity 是 2 的次幂呢？</strong></h2><h3 id="（1）在-get-方法实现中，实际上是匹配链表中的-Node-tab-中的数据。"><a href="#（1）在-get-方法实现中，实际上是匹配链表中的-Node-tab-中的数据。" class="headerlink" title="（1）在 get 方法实现中，实际上是匹配链表中的 Node[] tab 中的数据。"></a>（1）在 get 方法实现中，实际上是匹配链表中的 Node[] tab 中的数据。</h3><blockquote><p><code>(n - 1) &amp; hash</code> 实际上是计算出 key 在 tab 中索引位置，当 key 的 hash 没有冲突时，key 在 HashMap 存储的位置就是匹配的 node 中的第一个节点。如果 hash 有冲突，就会在 node 里面节点中查询，直至匹配到相等的 key。 </p></blockquote><p><img src="http://image-ericshen.test.upcdn.net/uPic/o02r7u_LVfmU28zudWYhZK-20210224210647108" alt="HashMap源码getNode方法"></p><h3 id="（2）因为-n-永远是-2-的次幂，所以-n-1-通过-二进制表示，永远都是尾端以连续-1-的形式表示（00001111，00000011）"><a href="#（2）因为-n-永远是-2-的次幂，所以-n-1-通过-二进制表示，永远都是尾端以连续-1-的形式表示（00001111，00000011）" class="headerlink" title="（2）因为 n 永远是 2 的次幂，所以 n-1 通过 二进制表示，永远都是尾端以连续 1 的形式表示（00001111，00000011）"></a>（2）因为 n 永远是 2 的次幂，所以 n-1 通过 二进制表示，永远都是尾端以连续 1 的形式表示（00001111，00000011）</h3><p>当 (n - 1) 和 hash 做与运算时，会保留 hash 中 后 x 位的 1， </p><p>例如 00001111 &amp; 10000011 = 00000011</p><p>这样做有 2 个好处</p><ul><li><strong>&amp; 运算速度快，至少比 % 取模运算块</strong></li><li><strong>能保证 索引值 肯定在 capacity 中，不会超出数组长度</strong></li><li><strong>(n - 1) &amp; hash，当 n 为 2 次幂时，会满足一个公式：(n - 1) &amp; hash = hash % n</strong></li></ul><h2 id="2-为什么要通过-n-1-amp-hash-决定桶的索引呢？"><a href="#2-为什么要通过-n-1-amp-hash-决定桶的索引呢？" class="headerlink" title="2. 为什么要通过 (n - 1) &amp; hash 决定桶的索引呢？"></a><strong>2. 为什么要通过 (n - 1) &amp; hash 决定桶的索引呢？</strong></h2><h3 id="（1）key-具体应该在哪个桶中，肯定要和-key-挂钩的，HashMap-顾名思义就是通过-hash-算法高效的把存储的数据查询出来，所以-HashMap-的所有-get-和-set-的操作都和-hash-相关。"><a href="#（1）key-具体应该在哪个桶中，肯定要和-key-挂钩的，HashMap-顾名思义就是通过-hash-算法高效的把存储的数据查询出来，所以-HashMap-的所有-get-和-set-的操作都和-hash-相关。" class="headerlink" title="（1）key 具体应该在哪个桶中，肯定要和 key 挂钩的，HashMap 顾名思义就是通过 hash 算法高效的把存储的数据查询出来，所以 HashMap 的所有 get 和 set 的操作都和 hash 相关。"></a>（1）key 具体应该在哪个桶中，肯定要和 key 挂钩的，HashMap 顾名思义就是通过 hash 算法高效的把存储的数据查询出来，所以 HashMap 的所有 get 和 set 的操作都和 hash 相关。</h3><h3 id="（2）既然是通过-hash-的方式，那么不可避免的会出现-hash-冲突的场景。hash-冲突就是指-2-个-key-通过-hash-算法得出的哈希值是相等的。hash-冲突是不可避免的，所以如何尽量避免-hash-冲突，或者在-hash-冲突时如何高效定位到数据的真实存储位置就是-HashMap-中最核心的部分。"><a href="#（2）既然是通过-hash-的方式，那么不可避免的会出现-hash-冲突的场景。hash-冲突就是指-2-个-key-通过-hash-算法得出的哈希值是相等的。hash-冲突是不可避免的，所以如何尽量避免-hash-冲突，或者在-hash-冲突时如何高效定位到数据的真实存储位置就是-HashMap-中最核心的部分。" class="headerlink" title="（2）既然是通过 hash 的方式，那么不可避免的会出现 hash 冲突的场景。hash 冲突就是指 2 个 key 通过 hash 算法得出的哈希值是相等的。hash 冲突是不可避免的，所以如何尽量避免 hash 冲突，或者在 hash 冲突时如何高效定位到数据的真实存储位置就是 HashMap 中最核心的部分。"></a>（2）既然是通过 hash 的方式，那么不可避免的会出现 hash 冲突的场景。hash 冲突就是指 2 个 key 通过 hash 算法得出的哈希值是相等的。hash 冲突是不可避免的，所以如何尽量避免 hash 冲突，或者在 hash 冲突时如何高效定位到数据的真实存储位置就是 HashMap 中最核心的部分。</h3><h3 id="（3）首先要提的一点是-HashMap-中-capacity-可以在构造函数中指定，如果不指定默认是-2-的-n-4-次方，即-16。"><a href="#（3）首先要提的一点是-HashMap-中-capacity-可以在构造函数中指定，如果不指定默认是-2-的-n-4-次方，即-16。" class="headerlink" title="（3）首先要提的一点是 HashMap 中 capacity 可以在构造函数中指定，如果不指定默认是 2 的 (n = 4) 次方，即 16。"></a>（3）首先要提的一点是 HashMap 中 capacity 可以在构造函数中指定，如果不指定默认是 2 的 (n = 4) 次方，即 16。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="（4）HashMap-中的-hash-也做了比较特别的处理，-h-key-hashCode-h-gt-gt-gt-16-。"><a href="#（4）HashMap-中的-hash-也做了比较特别的处理，-h-key-hashCode-h-gt-gt-gt-16-。" class="headerlink" title="（4）HashMap 中的 hash 也做了比较特别的处理，(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)。"></a>（4）HashMap 中的 hash 也做了比较特别的处理，<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>。</h3><p>先获得 key 的 hashCode 的值 h，然后 h 和 h 右移 16 位 做异或运算。<br>实质上是把一个数的低 16 位与他的高 16 位做异或运算，因为在前面 (n - 1) &amp; hash 的计算中，hash 变量只有末 x 位会参与到运算。使高 16 位也参与到 hash 的运算能减少冲突。</p><p>例如 1000000 的二进制是 00000000 00001111 01000010 01000000<br>右移 16 位： 00000000 00000000 00000000 00001111<br>异或 00000000 00001111 01000010 01001111</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-capacity-永远都是-2-次幂，那么如果我们指定-initialCapacity-不为-2-次幂时呢，是不是就破坏了这个规则？"><a href="#3-capacity-永远都是-2-次幂，那么如果我们指定-initialCapacity-不为-2-次幂时呢，是不是就破坏了这个规则？" class="headerlink" title="3.capacity 永远都是 2 次幂，那么如果我们指定 initialCapacity 不为 2 次幂时呢，是不是就破坏了这个规则？"></a><strong>3.capacity 永远都是 2 次幂，那么如果我们指定 initialCapacity 不为 2 次幂时呢，是不是就破坏了这个规则？</strong></h2><p>答案是不会的，HashMap 的 tableSizeFor 方法做了处理，能保证 n 永远都是 2 次幂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns a power of two size for the given target capacity.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;<br>    <span class="hljs-comment">//cap-1后，n的二进制最右一位肯定和cap的最右一位不同，即一个为0，一个为1，例如cap=17（00010001），n=cap-1=16（00010000）</span><br>    <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//n = (00010000 | 00001000) = 00011000</span><br>    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//n = (00011000 | 00000110) = 00011110</span><br>    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//n = (00011110 | 00000001) = 00011111</span><br>    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">//n = (00011111 | 00000000) = 00011111</span><br>    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>    <span class="hljs-comment">//n = (00011111 | 00000000) = 00011111</span><br>    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>    <span class="hljs-comment">//n = 00011111 = 31</span><br>    <span class="hljs-comment">//n = 31 + 1 = 32, 即最终的cap = 32 = 2 的 (n=5)次方</span><br>    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>map</tag>
      
      <tag>collection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu&amp;CentOS安装Dokcer-CE</title>
    <link href="/2019/04/15/docker/Ubuntu&amp;CentOS%E5%AE%89%E8%A3%85Dokcer-CE/"/>
    <url>/2019/04/15/docker/Ubuntu&amp;CentOS%E5%AE%89%E8%A3%85Dokcer-CE/</url>
    
    <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作 系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容 器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 containerd。</p><p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极 大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p><span id="more"></span><p>[TOC]</p><h3 id="1-2-为什么要使用-Docker"><a href="#1-2-为什么要使用-Docker" class="headerlink" title="1.2 为什么要使用 Docker"></a>1.2 为什么要使用 Docker</h3><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p><h4 id="1-2-1-更高效的利用系统资源"><a href="#1-2-1-更高效的利用系统资源" class="headerlink" title="1.2.1 更高效的利用系统资源"></a>1.2.1 更高效的利用系统资源</h4><p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用 率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高 效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p><h4 id="1-2-2-更快速的启动时间"><a href="#1-2-2-更快速的启动时间" class="headerlink" title="1.2.2 更快速的启动时间"></a>1.2.2 更快速的启动时间</h4><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主 内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约 了开发、测试、部署的时间。</p><h4 id="1-2-3-一致的运行环境"><a href="#1-2-3-一致的运行环境" class="headerlink" title="1.2.3 一致的运行环境"></a>1.2.3 一致的运行环境</h4><p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一 致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行 时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这 类问题。</p><h4 id="1-2-4-持续交付和部署"><a href="#1-2-4-持续交付和部署" class="headerlink" title="1.2.4 持续交付和部署"></a>1.2.4 持续交付和部署</h4><p>对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运 行。</p><p>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试， 而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。</p><p>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便 运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p><h4 id="1-2-5-更轻松的迁移"><a href="#1-2-5-更轻松的迁移" class="headerlink" title="1.2.5 更轻松的迁移"></a>1.2.5 更轻松的迁移</h4><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台 上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。 因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行 环境的变化导致应用无法正常运行的情况。</p><h4 id="1-2-6-更轻松的维护和扩展"><a href="#1-2-6-更轻松的维护和扩展" class="headerlink" title="1.2.6 更轻松的维护和扩展"></a>1.2.6 更轻松的维护和扩展</h4><p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的 维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各 个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以 作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p><h4 id="1-2-7-对比传统虚拟机总结"><a href="#1-2-7-对比传统虚拟机总结" class="headerlink" title="1.2.7 对比传统虚拟机总结"></a>1.2.7 对比传统虚拟机总结</h4><table><thead><tr><th align="left">特性</th><th align="left">容器</th><th align="left">虚拟机</th></tr></thead><tbody><tr><td align="left">启动</td><td align="left">秒级</td><td align="left">分钟级</td></tr><tr><td align="left">硬盘使用</td><td align="left">一般为MB</td><td align="left">一般为GB</td></tr><tr><td align="left">性能</td><td align="left">接近原生</td><td align="left">弱于</td></tr><tr><td align="left">系统支持量</td><td align="left">单机支持上千个容器</td><td align="left">一般几十个</td></tr></tbody></table><h3 id="1-3-环境"><a href="#1-3-环境" class="headerlink" title="1.3 环境"></a>1.3 环境</h3><ul><li>Ubuntu 18.04.3 LTS</li><li>CentOS Linux release 7.5.1804</li></ul><ul><li>Docker 19.03.2, build 6a30dfc</li></ul><p><strong>老版本的 Docker 被称为 docker 或 docker-engine。如果安装了这些版本，先卸载它们，以及相关的依赖项。</strong></p><h2 id="2-卸载旧版本"><a href="#2-卸载旧版本" class="headerlink" title="2. 卸载旧版本"></a>2. 卸载旧版本</h2><ul><li>Ubuntu</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get remove docker docker-engine<br></code></pre></td></tr></table></figure><ul><li>CentOS<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum remove docker \<br>docker-common \<br>container-selinux \<br>docker-selinux \<br>docker-engine<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-安装Docker"><a href="#3-安装Docker" class="headerlink" title="3. 安装Docker"></a>3. 安装Docker</h2><blockquote><p>APT/YUM安装和脚本安装二选一即可</p></blockquote><h3 id="3-1-Ubuntu使用-APT-安装"><a href="#3-1-Ubuntu使用-APT-安装" class="headerlink" title="3.1 Ubuntu使用 APT 安装"></a>3.1 Ubuntu使用 APT 安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 更新数据源</span><br>sudo apt-get update<br><span class="hljs-comment"># 安装所需依赖</span><br>sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common<br><span class="hljs-comment"># 安装 GPG 证书</span><br>sudo curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -<br><span class="hljs-comment"># 新增数据源</span><br>sudo add-apt-repository <span class="hljs-string">&quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span><br><span class="hljs-comment"># 更新并安装 Docker CE</span><br>sudo apt-get update &amp;&amp; apt-get install -y docker-ce<br></code></pre></td></tr></table></figure><h3 id="3-2-CentOS使用YUM安装"><a href="#3-2-CentOS使用YUM安装" class="headerlink" title="3.2 CentOS使用YUM安装"></a>3.2 CentOS使用YUM安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装yum-utils</span><br>sudo yum install -y yum-utils<br><span class="hljs-meta">#</span><span class="bash"> 安装repo</span><br>sudo yum-config-manager \<br>    --add-repo \<br>    https://download.docker.com/linux/centos/docker-ce.repo<br><span class="hljs-meta">#</span><span class="bash"> 安装docker-ce</span><br>sudo yum install docker-ce docker-ce-cli containerd.io<br></code></pre></td></tr></table></figure><h3 id="3-3-使用脚本自动安装"><a href="#3-3-使用脚本自动安装" class="headerlink" title="3.3 使用脚本自动安装"></a>3.3 使用脚本自动安装</h3><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code> 选项使用国内源进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL get.docker.com -o get-docker.sh<br>sudo sh get-docker.sh --mirror Aliyun<br></code></pre></td></tr></table></figure><p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的稳定(stable)版本安装在系统中。</p><blockquote><p>国内用户如果碰到速度过慢问题，推荐使用DaoCloud的镜像，在这里感谢<strong>DaoCloud</strong></p><p><code>curl -sSL https://get.daocloud.io/docker | sh</code></p></blockquote><h3 id="3-4-查看Docker版本"><a href="#3-4-查看Docker版本" class="headerlink" title="3.4 查看Docker版本"></a>3.4 查看Docker版本</h3><p><code>sudo docker version</code><br><strong>输出如下</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Client</span>: Docker Engine - Community<br> <span class="hljs-attribute">Version</span>:           <span class="hljs-number">19</span>.<span class="hljs-number">03</span>.<span class="hljs-number">2</span><br> <span class="hljs-attribute">API</span> version:       <span class="hljs-number">1</span>.<span class="hljs-number">40</span><br> <span class="hljs-attribute">Go</span> version:        go<span class="hljs-number">1</span>.<span class="hljs-number">12</span>.<span class="hljs-number">8</span><br> <span class="hljs-attribute">Git</span> commit:        <span class="hljs-number">6</span>a<span class="hljs-number">30</span>dfc<br> <span class="hljs-attribute">Built</span>:             Thu Aug <span class="hljs-number">29</span> <span class="hljs-number">05</span>:<span class="hljs-number">29</span>:<span class="hljs-number">11</span> <span class="hljs-number">2019</span><br> <span class="hljs-attribute">OS</span>/Arch:           linux/amd<span class="hljs-number">64</span><br> <span class="hljs-attribute">Experimental</span>:      false<br><br><span class="hljs-attribute">Server</span>: Docker Engine - Community<br> <span class="hljs-attribute">Engine</span>:<br>  <span class="hljs-attribute">Version</span>:          <span class="hljs-number">19</span>.<span class="hljs-number">03</span>.<span class="hljs-number">2</span><br>  <span class="hljs-attribute">API</span> version:      <span class="hljs-number">1</span>.<span class="hljs-number">40</span> (minimum version <span class="hljs-number">1</span>.<span class="hljs-number">12</span>)<br>  <span class="hljs-attribute">Go</span> version:       go<span class="hljs-number">1</span>.<span class="hljs-number">12</span>.<span class="hljs-number">8</span><br>  <span class="hljs-attribute">Git</span> commit:       <span class="hljs-number">6</span>a<span class="hljs-number">30</span>dfc<br>  <span class="hljs-attribute">Built</span>:            Thu Aug <span class="hljs-number">29</span> <span class="hljs-number">05</span>:<span class="hljs-number">27</span>:<span class="hljs-number">45</span> <span class="hljs-number">2019</span><br>  <span class="hljs-attribute">OS</span>/Arch:          linux/amd<span class="hljs-number">64</span><br>  <span class="hljs-attribute">Experimental</span>:     false<br> <span class="hljs-attribute">containerd</span>:<br>  <span class="hljs-attribute">Version</span>:          <span class="hljs-number">1</span>.<span class="hljs-number">2</span>.<span class="hljs-number">6</span><br>  <span class="hljs-attribute">GitCommit</span>:        <span class="hljs-number">894</span>b<span class="hljs-number">81</span>a<span class="hljs-number">4</span>b<span class="hljs-number">802</span>e<span class="hljs-number">4</span>eb<span class="hljs-number">2</span>a<span class="hljs-number">91</span>d<span class="hljs-number">1</span>ce<span class="hljs-number">216</span>b<span class="hljs-number">8817763</span>c<span class="hljs-number">29</span>fb<br> <span class="hljs-attribute">runc</span>:<br>  <span class="hljs-attribute">Version</span>:          <span class="hljs-number">1</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>-rc<span class="hljs-number">8</span><br>  <span class="hljs-attribute">GitCommit</span>:        <span class="hljs-number">425</span>e<span class="hljs-number">105</span>d<span class="hljs-number">5</span>a<span class="hljs-number">03</span>fabd<span class="hljs-number">737</span>a<span class="hljs-number">126</span>ad<span class="hljs-number">93</span>d<span class="hljs-number">62</span>a<span class="hljs-number">9</span>eeede<span class="hljs-number">87</span>f<br> <span class="hljs-attribute">docker</span>-init:<br>  <span class="hljs-attribute">Version</span>:          <span class="hljs-number">0</span>.<span class="hljs-number">18</span>.<span class="hljs-number">0</span><br>  <span class="hljs-attribute">GitCommit</span>:        fec<span class="hljs-number">3683</span><br></code></pre></td></tr></table></figure><h3 id="3-5-systemd启动Docker并配置开机自启"><a href="#3-5-systemd启动Docker并配置开机自启" class="headerlink" title="3.5 systemd启动Docker并配置开机自启"></a>3.5 systemd启动Docker并配置开机自启</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl start docker<br>sudo systemctl <span class="hljs-built_in">enable</span> docker<br></code></pre></td></tr></table></figure><h3 id="3-6-配置镜像加速器"><a href="#3-6-配置镜像加速器" class="headerlink" title="3.6 配置镜像加速器"></a>3.6 配置镜像加速器</h3><blockquote><p>阿里云、DaoCloud、USTC镜像三选一即可</p></blockquote><ul><li>阿里云镜像镜像加速器，登录自己的阿里云官网，找到<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">镜像加速器</a>，根据提示进行配置</li></ul><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/ipMF4SNyKjTqJ8z.png" alt=""></p><ul><li>DaoCloud 镜像站</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://f1361db2.m.daocloud.io<br></code></pre></td></tr></table></figure><ul><li>USTC镜像</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>docker.mirrors.ustc.edu.cn<br></code></pre></td></tr></table></figure><h3 id="3-7-允许Docker测试示例"><a href="#3-7-允许Docker测试示例" class="headerlink" title="3.7 允许Docker测试示例"></a>3.7 允许Docker测试示例</h3><p><code>docker run hello-world</code></p><p><strong>输出如下</strong></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Unable <span class="hljs-built_in">to</span> find image <span class="hljs-string">&#x27;hello-world:latest&#x27;</span> locally  <span class="hljs-comment"># 本地无镜像</span><br>latest: Pulling <span class="hljs-built_in">from</span> library/hello-world <span class="hljs-comment">#从远程仓库拉取</span><br><span class="hljs-number">1</span>b930d010525: Pull complete<br>Digest: sha256:c3b4ada4687bbaa170745b3e4dd8ac3f194ca95b2d0518b417fb47e5879d9b5f<br>Status: Downloaded newer image <span class="hljs-keyword">for</span> hello-world:latest<br><br>Hello <span class="hljs-built_in">from</span> Docker!<br>This message shows that your installation appears <span class="hljs-built_in">to</span> be working correctly.<br><br>To generate this message, Docker took <span class="hljs-keyword">the</span> following steps:<br> <span class="hljs-number">1.</span> The Docker client contacted <span class="hljs-keyword">the</span> Docker daemon.<br> <span class="hljs-number">2.</span> The Docker daemon pulled <span class="hljs-keyword">the</span> <span class="hljs-string">&quot;hello-world&quot;</span> image <span class="hljs-built_in">from</span> <span class="hljs-keyword">the</span> Docker Hub.<br>    (amd64)<br> <span class="hljs-number">3.</span> The Docker daemon created <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> container <span class="hljs-built_in">from</span> that image which runs <span class="hljs-keyword">the</span><br>    executable that produces <span class="hljs-keyword">the</span> output you are currently reading.<br> <span class="hljs-number">4.</span> The Docker daemon streamed that output <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> Docker client, which sent <span class="hljs-keyword">it</span><br>    <span class="hljs-built_in">to</span> your terminal.<br><br>To <span class="hljs-keyword">try</span> something more ambitious, you can run <span class="hljs-keyword">an</span> Ubuntu container <span class="hljs-keyword">with</span>:<br> $ docker run -<span class="hljs-keyword">it</span> ubuntu bash<br><br>Share images, automate workflows, <span class="hljs-keyword">and</span> more <span class="hljs-keyword">with</span> <span class="hljs-keyword">a</span> free Docker ID:<br> <span class="hljs-keyword">https</span>://hub.docker.com/<br><br>For more examples <span class="hljs-keyword">and</span> ideas, visit:<br> <span class="hljs-keyword">https</span>://docs.docker.com/<span class="hljs-built_in">get</span>-started/<br></code></pre></td></tr></table></figure><h3 id="3-8-查看Docker版本信息"><a href="#3-8-查看Docker版本信息" class="headerlink" title="3.8 查看Docker版本信息"></a>3.8 查看Docker版本信息</h3><p><code>sudo docker info</code></p><p><strong>输出如下</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Client:</span><br> <span class="hljs-attr">Debug Mode:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">Server:</span><br> <span class="hljs-attr">Containers:</span> <span class="hljs-number">0</span>                   <span class="hljs-comment"># 容器数</span><br>  <span class="hljs-attr">Running:</span> <span class="hljs-number">0</span>                     <span class="hljs-comment"># 运行容器数</span><br>  <span class="hljs-attr">Paused:</span> <span class="hljs-number">0</span>                      <span class="hljs-comment"># 暂停容器数</span><br>  <span class="hljs-attr">Stopped:</span> <span class="hljs-number">0</span>                     <span class="hljs-comment"># 停止容器数</span><br>  <span class="hljs-attr">Images:</span> <span class="hljs-number">0</span><br> <span class="hljs-attr">Server Version:</span> <span class="hljs-number">19.03</span><span class="hljs-number">.2</span><br> <span class="hljs-attr">Storage Driver:</span> <span class="hljs-string">overlay2</span><br>  <span class="hljs-attr">Backing Filesystem:</span> <span class="hljs-string">extfs</span><br>  <span class="hljs-attr">Supports d_type:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">Native Overlay Diff:</span> <span class="hljs-literal">true</span><br> <span class="hljs-attr">Logging Driver:</span> <span class="hljs-string">json-file</span><br> <span class="hljs-attr">Cgroup Driver:</span> <span class="hljs-string">cgroupfs</span><br> <span class="hljs-attr">Plugins:</span><br>  <span class="hljs-attr">Volume:</span> <span class="hljs-string">local</span><br>  <span class="hljs-attr">Network:</span> <span class="hljs-string">bridge</span> <span class="hljs-string">host</span> <span class="hljs-string">ipvlan</span> <span class="hljs-string">macvlan</span> <span class="hljs-literal">null</span> <span class="hljs-string">overlay</span><br>  <span class="hljs-attr">Log:</span> <span class="hljs-string">awslogs</span> <span class="hljs-string">fluentd</span> <span class="hljs-string">gcplogs</span> <span class="hljs-string">gelf</span> <span class="hljs-string">journald</span> <span class="hljs-string">json-file</span> <span class="hljs-string">local</span> <span class="hljs-string">logentries</span> <span class="hljs-string">splunk</span> <span class="hljs-string">syslog</span><br> <span class="hljs-attr">Swarm:</span> <span class="hljs-string">inactive</span><br> <span class="hljs-attr">Runtimes:</span> <span class="hljs-string">runc</span><br> <span class="hljs-attr">Default Runtime:</span> <span class="hljs-string">runc</span><br> <span class="hljs-attr">Init Binary:</span> <span class="hljs-string">docker-init</span><br> <span class="hljs-attr">containerd version:</span> <span class="hljs-string">894b81a4b802e4eb2a91d1ce216b8817763c29fb</span><br> <span class="hljs-attr">runc version:</span> <span class="hljs-string">425e105d5a03fabd737a126ad93d62a9eeede87f</span><br> <span class="hljs-attr">init version:</span> <span class="hljs-string">fec3683</span><br> <span class="hljs-attr">Security Options:</span><br>  <span class="hljs-string">apparmor</span><br>  <span class="hljs-string">seccomp</span><br>   <span class="hljs-attr">Profile:</span> <span class="hljs-string">default</span><br> <span class="hljs-attr">Kernel Version:</span> <span class="hljs-number">4.15</span><span class="hljs-number">.0</span><span class="hljs-number">-65</span><span class="hljs-string">-generic</span><br> <span class="hljs-attr">Operating System:</span> <span class="hljs-string">Ubuntu</span> <span class="hljs-number">18.04</span><span class="hljs-number">.3</span> <span class="hljs-string">LTS</span><br> <span class="hljs-attr">OSType:</span> <span class="hljs-string">linux</span><br> <span class="hljs-attr">Architecture:</span> <span class="hljs-string">x86_64</span><br> <span class="hljs-attr">CPUs:</span> <span class="hljs-number">2</span><br> <span class="hljs-attr">Total Memory:</span> <span class="hljs-number">3.</span><span class="hljs-string">847GiB</span><br> <span class="hljs-attr">Name:</span> <span class="hljs-string">Paas</span><br> <span class="hljs-attr">ID:</span> <span class="hljs-string">6VRF:YBNF:N6ZG:MLAW:WS7P:ULYU:UJJT:CC43:H43S:XQNJ:PO4K:FALJ</span><br> <span class="hljs-attr">Docker Root Dir:</span> <span class="hljs-string">/var/lib/docker</span><br> <span class="hljs-attr">Debug Mode:</span> <span class="hljs-literal">false</span><br> <span class="hljs-attr">Registry:</span> <span class="hljs-string">https://index.docker.io/v1/</span><br> <span class="hljs-attr">Labels:</span><br> <span class="hljs-attr">Experimental:</span> <span class="hljs-literal">false</span><br> <span class="hljs-attr">Registry Mirrors:</span><br>  <span class="hljs-string">https://xxxxxx.mirror.aliyuncs.com/</span><br> <span class="hljs-attr">Live Restore Enabled:</span> <span class="hljs-literal">false</span><br><br><span class="hljs-attr">WARNING:</span> <span class="hljs-literal">No</span> <span class="hljs-string">swap</span> <span class="hljs-string">limit</span> <span class="hljs-string">support</span><br></code></pre></td></tr></table></figure><h2 id="4-开启Docker-Remote-API"><a href="#4-开启Docker-Remote-API" class="headerlink" title="4. 开启Docker Remote API"></a>4. 开启Docker Remote API</h2><p>修改配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /usr/lib/systemd/system/docker.service<br></code></pre></td></tr></table></figure><p>找到<code>ExecStart=/usr/bin/dockerd</code>行，修改如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ExecStart=/usr/bin/dockerd  -H tcp://0.0.0.0:2375  -H unix:///var/run/docker.sock<br></code></pre></td></tr></table></figure><p>编辑配置文件<code>vim /etc/profile</code>, 写入一下内容, 执行<code>source /etc/profile</code>刷新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> DOCKER_HOST=127.0.0.1:2375<br></code></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl daemon-reload<br>systemctl restart docker<br></code></pre></td></tr></table></figure><p>执行<code>curl http://127.0.0.1:2375/info</code>验证</p><p>输出如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;ID&quot;</span>:<span class="hljs-string">&quot;HPZP:XIWJ:BZP7:YI47:UOLX:YLMM:LBF7:KV4E:Y2A7:ED6B:BHWB:FE4R&quot;</span>,<span class="hljs-attr">&quot;Containers&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">&quot;ContainersRunning&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">&quot;ContainersPaused&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">&quot;ContainersStopped&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">&quot;Images&quot;</span>:<span class="hljs-number">2</span>,<span class="hljs-attr">&quot;Driver&quot;</span>:<span class="hljs-string">&quot;overlay2&quot;</span>,<span class="hljs-attr">&quot;DriverStatus&quot;</span>:[[<span class="hljs-string">&quot;Backing Filesystem&quot;</span>,<span class="hljs-string">&quot;xfs&quot;</span>],[<span class="hljs-string">&quot;Supports d_type&quot;</span>,<span class="hljs-string">&quot;true&quot;</span>],[<span class="hljs-string">&quot;Native Overlay Diff&quot;</span>,<span class="hljs-string">&quot;true&quot;</span>]],<span class="hljs-attr">&quot;SystemStatus&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-attr">&quot;Plugins&quot;</span>:&#123;<span class="hljs-attr">&quot;Volume&quot;</span>:[<span class="hljs-string">&quot;local&quot;</span>],<span class="hljs-attr">&quot;Network&quot;</span>:[<span class="hljs-string">&quot;bridge&quot;</span>,<span class="hljs-string">&quot;host&quot;</span>,<span class="hljs-string">&quot;macvlan&quot;</span>,<span class="hljs-string">&quot;null&quot;</span>,<span class="hljs-string">&quot;overlay&quot;</span>],<span class="hljs-attr">&quot;Authorization&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-attr">&quot;Log&quot;</span>:[<span class="hljs-string">&quot;awslogs&quot;</span>,<span class="hljs-string">&quot;fluentd&quot;</span>,<span class="hljs-string">&quot;gcplogs&quot;</span>,<span class="hljs-string">&quot;gelf&quot;</span>,<span class="hljs-string">&quot;journald&quot;</span>,<span class="hljs-string">&quot;json-file&quot;</span>,<span class="hljs-string">&quot;logentries&quot;</span>,<span class="hljs-string">&quot;splunk&quot;</span>,<span class="hljs-string">&quot;syslog&quot;</span>]&#125;,<span class="hljs-attr">&quot;MemoryLimit&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">&quot;SwapLimit&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">&quot;KernelMemory&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">&quot;CpuCfsPeriod&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">&quot;CpuCfsQuota&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">&quot;CPUShares&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">&quot;CPUSet&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">&quot;IPv4Forwarding&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">&quot;BridgeNfIptables&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">&quot;BridgeNfIp6tables&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">&quot;Debug&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-attr">&quot;NFd&quot;</span>:<span class="hljs-number">20</span>,<span class="hljs-attr">&quot;OomKillDisable&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">&quot;NGoroutines&quot;</span>:<span class="hljs-number">33</span>,<span class="hljs-attr">&quot;SystemTime&quot;</span>:<span class="hljs-string">&quot;2018-04-08T15:41:52.725705339+08:00&quot;</span>,<span class="hljs-attr">&quot;LoggingDriver&quot;</span>:<span class="hljs-string">&quot;json-file&quot;</span>,<span class="hljs-attr">&quot;CgroupDriver&quot;</span>:<span class="hljs-string">&quot;cgroupfs&quot;</span>,<span class="hljs-attr">&quot;NEventsListener&quot;</span>:<span class="hljs-number">0</span>,<span class="hljs-attr">&quot;KernelVersion&quot;</span>:<span class="hljs-string">&quot;3.10.0-693.21.1.el7.x86_64&quot;</span>,<span class="hljs-attr">&quot;OperatingSystem&quot;</span>:<span class="hljs-string">&quot;CentOS Linux 7 (Core)&quot;</span>,<span class="hljs-attr">&quot;OSType&quot;</span>:<span class="hljs-string">&quot;linux&quot;</span>,<span class="hljs-attr">&quot;Architecture&quot;</span>:<span class="hljs-string">&quot;x86_64&quot;</span>,<span class="hljs-attr">&quot;IndexServerAddress&quot;</span>:<span class="hljs-string">&quot;https://index.docker.io/v1/&quot;</span>,<span class="hljs-attr">&quot;RegistryConfig&quot;</span>:&#123;<span class="hljs-attr">&quot;AllowNondistributableArtifactsCIDRs&quot;</span>:[],<span class="hljs-attr">&quot;AllowNondistributableArtifactsHostnames&quot;</span>:[],<span class="hljs-attr">&quot;InsecureRegistryCIDRs&quot;</span>:[<span class="hljs-string">&quot;127.0.0.0/8&quot;</span>],<span class="hljs-attr">&quot;IndexConfigs&quot;</span>:&#123;<span class="hljs-attr">&quot;docker.io&quot;</span>:&#123;<span class="hljs-attr">&quot;Name&quot;</span>:<span class="hljs-string">&quot;docker.io&quot;</span>,<span class="hljs-attr">&quot;Mirrors&quot;</span>:[<span class="hljs-string">&quot;https://0zs97su8.mirror.aliyuncs.com/&quot;</span>],<span class="hljs-attr">&quot;Secure&quot;</span>:<span class="hljs-literal">true</span>,<span class="hljs-attr">&quot;Official&quot;</span>:<span class="hljs-literal">true</span>&#125;&#125;,<span class="hljs-attr">&quot;Mirrors&quot;</span>:[<span class="hljs-string">&quot;https://0zs97su8.mirror.aliyuncs.com/&quot;</span>]&#125;,<span class="hljs-attr">&quot;NCPU&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-attr">&quot;MemTotal&quot;</span>:<span class="hljs-number">1022570496</span>,<span class="hljs-attr">&quot;GenericResources&quot;</span>:<span class="hljs-literal">null</span>,<span class="hljs-attr">&quot;DockerRootDir&quot;</span>:<span class="hljs-string">&quot;/var/lib/docker&quot;</span>,<span class="hljs-attr">&quot;HttpProxy&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-attr">&quot;HttpsProxy&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-attr">&quot;NoProxy&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-attr">&quot;Name&quot;</span>:<span class="hljs-string">&quot;localhost&quot;</span>,<span class="hljs-attr">&quot;Labels&quot;</span>:[],<span class="hljs-attr">&quot;ExperimentalBuild&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-attr">&quot;ServerVersion&quot;</span>:<span class="hljs-string">&quot;18.03.0-ce&quot;</span>,<span class="hljs-attr">&quot;ClusterStore&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-attr">&quot;ClusterAdvertise&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-attr">&quot;Runtimes&quot;</span>:&#123;<span class="hljs-attr">&quot;runc&quot;</span>:&#123;<span class="hljs-attr">&quot;path&quot;</span>:<span class="hljs-string">&quot;docker-runc&quot;</span>&#125;&#125;,<span class="hljs-attr">&quot;DefaultRuntime&quot;</span>:<span class="hljs-string">&quot;runc&quot;</span>,<span class="hljs-attr">&quot;Swarm&quot;</span>:&#123;<span class="hljs-attr">&quot;NodeID&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-attr">&quot;NodeAddr&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-attr">&quot;LocalNodeState&quot;</span>:<span class="hljs-string">&quot;inactive&quot;</span>,<span class="hljs-attr">&quot;ControlAvailable&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-attr">&quot;Error&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-attr">&quot;RemoteManagers&quot;</span>:<span class="hljs-literal">null</span>&#125;,<span class="hljs-attr">&quot;LiveRestoreEnabled&quot;</span>:<span class="hljs-literal">false</span>,<span class="hljs-attr">&quot;Isolation&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-attr">&quot;InitBinary&quot;</span>:<span class="hljs-string">&quot;docker-init&quot;</span>,<span class="hljs-attr">&quot;ContainerdCommit&quot;</span>:&#123;<span class="hljs-attr">&quot;ID&quot;</span>:<span class="hljs-string">&quot;cfd04396dc68220d1cecbe686a6cc3aa5ce3667c&quot;</span>,<span class="hljs-attr">&quot;Expected&quot;</span>:<span class="hljs-string">&quot;cfd04396dc68220d1cecbe686a6cc3aa5ce3667c&quot;</span>&#125;,<span class="hljs-attr">&quot;RuncCommit&quot;</span>:&#123;<span class="hljs-attr">&quot;ID&quot;</span>:<span class="hljs-string">&quot;4fc53a81fb7c994640722ac585fa9ca548971871&quot;</span>,<span class="hljs-attr">&quot;Expected&quot;</span>:<span class="hljs-string">&quot;4fc53a81fb7c994640722ac585fa9ca548971871&quot;</span>&#125;,<span class="hljs-attr">&quot;InitCommit&quot;</span>:&#123;<span class="hljs-attr">&quot;ID&quot;</span>:<span class="hljs-string">&quot;949e6fa&quot;</span>,<span class="hljs-attr">&quot;Expected&quot;</span>:<span class="hljs-string">&quot;949e6fa&quot;</span>&#125;,<span class="hljs-attr">&quot;SecurityOptions&quot;</span>:[<span class="hljs-string">&quot;]&#125;</span><br></code></pre></td></tr></table></figure><h2 id="5-安装-Docker-Compose"><a href="#5-安装-Docker-Compose" class="headerlink" title="5. 安装 Docker Compose"></a>5. 安装 Docker Compose</h2><h3 id="5-1-运行此命令下载最新版本的Docker-Compose"><a href="#5-1-运行此命令下载最新版本的Docker-Compose" class="headerlink" title="5.1 运行此命令下载最新版本的Docker Compose"></a>5.1 运行此命令下载最新版本的Docker Compose</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -L https://github.com/docker/compose/releases/download/1.24.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="hljs-built_in">local</span>/bin/docker-compose<br></code></pre></td></tr></table></figure><blockquote><p>上面的命令是一个例子，可能会过时，为了确保使用最新的版本，请前往 <a href="https://github.com/docker/compose/releases">Github Compose repository release</a> 查看最新版本</p><p>国内用户如果碰到速度过慢问题，可以使用DaoCloud的镜像，这里再次感谢<strong>DaoCloud</strong></p><p><code>curl -L https://get.daocloud.io/docker/compose/releases/download/1.24.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</code></p></blockquote><h3 id="5-2-给可执行文件添加权限"><a href="#5-2-给可执行文件添加权限" class="headerlink" title="5.2 给可执行文件添加权限"></a>5.2 给可执行文件添加权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo chmod +x /usr/<span class="hljs-built_in">local</span>/bin/docker-compose<br></code></pre></td></tr></table></figure><h3 id="5-3-验证安装docker-compose-–version"><a href="#5-3-验证安装docker-compose-–version" class="headerlink" title="5.3 验证安装docker-compose –version"></a>5.3 验证安装docker-compose –version</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker-compose version<br></code></pre></td></tr></table></figure><p><strong>输出如下</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span>-compose version <span class="hljs-number">1</span>.<span class="hljs-number">24</span>.<span class="hljs-number">0</span>, build <span class="hljs-number">0</span>aa<span class="hljs-number">59064</span><br><span class="hljs-attribute">docker</span>-py version: <span class="hljs-number">3</span>.<span class="hljs-number">7</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">CPython</span> version: <span class="hljs-number">3</span>.<span class="hljs-number">6</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">OpenSSL</span> version: OpenSSL <span class="hljs-number">1</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>j  <span class="hljs-number">20</span> Nov <span class="hljs-number">2018</span><br></code></pre></td></tr></table></figure><blockquote><p>参考资料:</p></blockquote><ol><li><a href="https://docs.docker.com/install/linux/docker-ce/centos/">Docker 官方安装文档</a></li><li><a href="https://docs.docker.com/compose/install/">Docker Compose 官网安装文档</a></li><li><a href="https://get.daocloud.io/#install-compose">DaoCloud</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>PaaS</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入分析HashMap</title>
    <link href="/2019/04/03/java/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90HashMap/"/>
    <url>/2019/04/03/java/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90HashMap/</url>
    
    <content type="html"><![CDATA[<h1 id="1-传统-HashMap-的缺点"><a href="#1-传统-HashMap-的缺点" class="headerlink" title="1. 传统 HashMap 的缺点"></a>1. 传统 HashMap 的缺点</h1><ul><li><p>JDK 1.8 以前 HashMap 的实现是 数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。</p></li><li><p>当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个 时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，完全失去了优势。</p></li><li><p>针对这种情况，JDK 1.8 中引入了红黑树(查找时间复杂度为 O(logn))来优化这个问题。</p><span id="more"></span><p>[TOC]</p></li></ul><h1 id="2-JDK1-8中HashMap的数据结构"><a href="#2-JDK1-8中HashMap的数据结构" class="headerlink" title="2. JDK1.8中HashMap的数据结构"></a>2. JDK1.8中HashMap的数据结构</h1><blockquote><p><strong>HashMap</strong> 是数组+链表+红黑树(JDK1.8 增加了红黑树部分)实现的</p></blockquote><p><img src="http://image-ericshen.test.upcdn.net/uPic/Nil92g_5NqP4KTYOufAoHb" alt="image-20200503171753893"></p><h3 id="2-1-新增红黑树"><a href="#2-1-新增红黑树" class="headerlink" title="2.1. 新增红黑树"></a>2.1. 新增红黑树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Tree bins</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span><br><span class="hljs-comment"> * extends Node) so can be used as extension of either regular or</span><br><span class="hljs-comment"> * linked node.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    TreeNode&lt;K,V&gt; parent;  <span class="hljs-comment">// red-black tree links</span><br>    TreeNode&lt;K,V&gt; left;<br>    TreeNode&lt;K,V&gt; right;<br>    TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>    <span class="hljs-keyword">boolean</span> red;<br>    TreeNode(<span class="hljs-keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-keyword">super</span>(hash, key, val, next);<br>    &#125;<br>  ......<br></code></pre></td></tr></table></figure><h3 id="2-2-红黑树的三个关键参数"><a href="#2-2-红黑树的三个关键参数" class="headerlink" title="2.2. 红黑树的三个关键参数"></a>2.2. 红黑树的三个关键参数</h3><table><thead><tr><th>TREEIFY_THRESHOLD</th><th align="center">UNTREEIFY_THRESHOLD</th><th align="center">MIN_TREEIFY_CAPACITY</th></tr></thead><tbody><tr><td>一个桶的树化阈值</td><td align="center">一个树的链表还原阈值</td><td align="center">哈希表的最小树形化容量</td></tr><tr><td>static final int TREEIFY_THRESHOLD = 8</td><td align="center">static final int UNTREEIFY_THRESHOLD = 6</td><td align="center">static final int MIN_TREEIFY_CAPACITY = 64</td></tr><tr><td>当桶中元素个数超过这个值时需要使用红黑树节点替换链表节点</td><td align="center">当扩容时，桶中元素个数小于这个值就会把树形的桶元素 还原(切分)为链 表结构</td><td align="center">当哈希表中的容量大于这个值时，表中的桶才能进行树形化 否则桶内元素太多时会扩容，而不是树形化 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD</td></tr></tbody></table><h3 id="2-3-新增操作-桶的树形化-treeifyBin"><a href="#2-3-新增操作-桶的树形化-treeifyBin" class="headerlink" title="2.3. 新增操作: 桶的树形化 treeifyBin()"></a>2.3. 新增操作: 桶的树形化 treeifyBin()</h3><ul><li>在 Java 8 中，如果一个桶中的元素个数超过 TREEIFY_THRESHOLD(默认是 8 )，就使用<br>红黑树来替换链表，从而提高速度。 这个替换的方法叫 treeifyBin() 即树形化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// 将桶内所有的 链表节点 替换成 红黑树节点</span><br>  <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeifyBin</span><span class="hljs-params">(Node&lt;K, V&gt;[] tab, <span class="hljs-keyword">int</span> hash)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, index;<br>    Node&lt;K, V&gt; e;<br><span class="hljs-comment">// 如果当前哈希表为空，或者哈希表中元素的个数小于 进行树形化的阈值(默认为 64)， 就去新建/扩容</span><br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) &#123;<br>      resize();<br>    &#125;<br>    elseif((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-comment">// 如果哈希表中的元素个数超过了 树形化阈值，进行树形化</span><br>      <span class="hljs-comment">// e 是哈希表中指定位置桶里的链表节点，从第一个开始 </span><br>      TreeNode&lt;K, V&gt; hd = <span class="hljs-keyword">null</span>, tl = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 红黑树的头、尾节点</span><br>      <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">//新建一个树形节点，内容和当前链表节点 e 一致 </span><br>        TreeNode&lt;K, V&gt; p = replacementTreeNode(e, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">if</span> (tl == <span class="hljs-keyword">null</span>) <span class="hljs-comment">//确定树头节点</span><br>        &#123;<br>          hd = p;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          p.prev = tl;<br>          tl.next = p;<br>        &#125;<br>        tl = p;<br>      &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>      <span class="hljs-comment">//让桶的第一个元素指向新建的红黑树头结点，以后这个桶里的元素就是红黑树而不是链表了</span><br>      <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-keyword">null</span>) &#123;<br>        hd.treeify(tab);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-function">TreeNode&lt;K, V&gt; <span class="hljs-title">replacementTreeNode</span><span class="hljs-params">(Node&lt;K, V&gt; p, Node&lt;K, V&gt; next)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);<br>  &#125;<br></code></pre></td></tr></table></figure><blockquote><p>上述操作做了这些事:</p><ul><li><p>根据哈希表中元素个数确定是扩容还是树形化 </p></li><li><p>如果是树形化遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系</p></li><li><p>然后让桶第一个元素指向新建的树头结点，替换桶的链表内容为树形内容</p></li></ul></blockquote><h1 id="3-分析-HashMap-的-put-方法"><a href="#3-分析-HashMap-的-put-方法" class="headerlink" title="3. 分析 HashMap 的 put 方法"></a>3. 分析 HashMap 的 put 方法</h1><h3 id="3-1-HashMap-的-put-方法执行过程可以通过下图来理解"><a href="#3-1-HashMap-的-put-方法执行过程可以通过下图来理解" class="headerlink" title="3.1. HashMap 的 put 方法执行过程可以通过下图来理解"></a>3.1. HashMap 的 put 方法执行过程可以通过下图来理解</h3><p><img src="http://image-ericshen.test.upcdn.net/uPic/gzo5Yg_JK6NFSEB5mDe3uV-20210224210601366" alt="JK6NFSEB5mDe3uV"></p><blockquote><ul><li><p>判断键值对数组 table[i]是否为空或为 null，否则执行 resize()进行扩容;</p></li><li><p>根据键值 key 计算 hash 值得到插入的数组索引 i，如果 table[i]==null，直接新建节点添加， 转向6，如果 table[i]不为空，转向3;</p></li><li><p>判断 table[i]的首个元素是否和 key 一样，如果相同直接覆盖 value，否则转向4，这里的相 同指的是 hashCode 以及 equals;</p></li><li><p>判断 table[i] 是否为 treeNode，即 table[i] 是否是红黑树，如果是红黑树，则直接在树中插 入键值对，否则转向5;</p></li><li><p>遍历 table[i]，判断链表长度是否大于 8，大于 8 的话把链表转换为红黑树，在红黑树中执 行插入操作，否则进行链表的插入操作;遍历过程中若发现 key 已经存在直接覆盖 value 即可;</p></li><li><p>插入成功后，判断实际存在的键值对数量 size 是否超多了最大容量 threshold，如果超过， 进行扩容。</p></li></ul></blockquote><ul><li><p>JDK1.8HashMap 的 put 方法源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>    <span class="hljs-comment">// 对 key 的 hashCode()做 hash</span><br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent, <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>    Node&lt;K, V&gt;[] tab;<br>    Node&lt;K, V&gt; p;<br>    <span class="hljs-keyword">int</span> n, i;<br>    <span class="hljs-comment">// 步骤1:tab 为空则创建</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>) &#123;<br>      n = (tab = resize()).length;<br>    &#125;<br>    <span class="hljs-comment">// 步骤2:计算 index，并对 null 做处理 if((p=tab[i=(n-1)&amp;hash])==null)</span><br>    tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>); <br>  <span class="hljs-keyword">else</span>&#123;<br>      Node&lt;K, V&gt; e;<br>      K k;<br>      <span class="hljs-comment">// 步骤3:节点 key 存在，直接覆盖 value if (p.hash == hash &amp;&amp;</span><br>      ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>      e = p;<br>      <span class="hljs-comment">// 步骤4:判断该链为红黑树</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode) &#123;<br>        e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);<br>      &#125;<br>      <span class="hljs-comment">// 步骤5:该链为链表</span><br>      <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>          <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>            p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>            <span class="hljs-comment">//链表长度大于 8 转换为红黑树进行处理</span><br>            <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st </span><br>            &#123;<br>              treeifyBin(tab, hash);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>          <span class="hljs-comment">// key 已经存在直接覆盖 value </span><br>          <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>              ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<br>            <span class="hljs-keyword">break</span>;<br>          &#125;<br>          p = e;<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key </span><br>        V oldValue = e.value;<br>        <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>) &#123;<br>          e.value = value;<br>        &#125;<br>        afterNodeAccess(e);<br>        <span class="hljs-keyword">return</span> oldValue;<br>      &#125;<br>    &#125;<br>    ++modCount;<br><span class="hljs-comment">// 步骤6:超过最大容量 就扩容 </span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold) &#123;<br>      resize();<br>    &#125;<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p>JDK1.7HashMap 的 put 方法源码</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (table == EMPTY_TABLE) &#123;<br>        inflateTable(threshold); <span class="hljs-comment">//空表 table 的话，根据 size 的阈值填充</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> putForNullKey(value);<br>    <span class="hljs-keyword">int</span> hash = hash(key); <span class="hljs-comment">//成 hash，得到索引 Index 的映射</span><br>    <span class="hljs-keyword">int</span> i = indexFor(hash, table.length);<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)table[i];<br>    <span class="hljs-keyword">for</span>(; e != <span class="hljs-keyword">null</span>; e = e.next) &#123; <span class="hljs-comment">//遍历当前索引的冲突链，找是否存在对应的 key</span><br>        Object k;<br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;<span class="hljs-comment">//如果存 在对应的key， 则替换oldValue并返回oldValue</span><br>            V oldValue = e.value;<br>            e.value = value;<br>            e.recordAccess(<span class="hljs-keyword">this</span>);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br><br>      <span class="hljs-comment">//冲突链中不存在新写入的 Entry 的 key</span><br>    modCount++;<br>    addEntry(hash, key, value, i);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-HashMap-在-JDK-1-8-中新增的操作-红黑树中查找元素-getTreeNode"><a href="#3-2-HashMap-在-JDK-1-8-中新增的操作-红黑树中查找元素-getTreeNode" class="headerlink" title="3.2. HashMap 在 JDK 1.8 中新增的操作: 红黑树中查找元素 getTreeNode()"></a>3.2. HashMap 在 JDK 1.8 中新增的操作: 红黑树中查找元素 getTreeNode()</h3><ul><li><p>JDK1.8 中 hashMap getNode 操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Implements Map.get and related methods.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> hash hash for key</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> key the key</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the node, or null if none</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-keyword">int</span> n; K k;<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = first.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">return</span> first;<br>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>HashMap 的查找方法是 get(),它通过计算指定 key 的哈希值后，调用内部方法 getNode(); </li><li>这个 getNode() 方法就是根据哈希表元素个数与哈希值求模(使用的公式是 (n - 1)</li></ul><p>&amp;hash)得到 key 所在的桶的头结点，如果头节点恰好是红黑树节点， 就调用红黑树节点的 getTreeNode() 方法，否则就遍历链表节点。</p><ul><li>getTreeNode 方法使通过调用树形节点的 find()方法进行查找:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> TreeNode&lt;K,V&gt; <span class="hljs-title">getTreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, Object k)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ((parent != <span class="hljs-keyword">null</span>) ? root() : <span class="hljs-keyword">this</span>).find(h, k, <span class="hljs-keyword">null</span>); <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>由于之前添加时已经保证这个树是有序的，因此查找时基本就是折半查找，效率很高。</p></li><li><p>这里和插入时一样，如果对比节点的哈希值和要查找的哈希值相等，就会判断 key 是否相</p></li></ul><p>等，相等就直接返回;不相等就从子树中递归查找。</p></blockquote></li></ul><h3 id="3-3-JDK1-8-VS-JDK1-7-扩容机制"><a href="#3-3-JDK1-8-VS-JDK1-7-扩容机制" class="headerlink" title="3.3. JDK1.8 VS JDK1.7 扩容机制"></a>3.3. JDK1.8 VS JDK1.7 扩容机制</h3><ul><li>下面举个例子说明下扩容过程。假设了我们的 hash 算法就是简单的用 key mod 一下表的大小(也就是数组的长度)。其中的哈希桶数组 table 的 size=2， 所以 key = 3、7、5，put 顺 序依次为 5、7、3。在 mod 2 以后都冲突在 table[1]这里了。这里假设负载因子 loadFactor=1， 即当键值对的实际大小 size 大于 table 的实际大小时进行扩容。接下来的三个步骤是哈希桶 数组 resize 成 4，然后所有的 Node 重新 rehash 的过程。</li></ul><p><img src="http://image-ericshen.test.upcdn.net/uPic/o1D7Xh_Ck5RnxSTwbXUfjm" alt="Ck5RnxSTwbXUfjm"></p><ul><li>下面我们讲解下 JDK1.8 做了哪些优化。经过观测可以发现，我们使用的是 2 次幂的扩展(指长 度扩为原来 2 倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动 2 次幂的位置。 看下图可以明白这句话的意思，n 为 table 的长度，图(a)表示扩容前的 key1 和 key2 两种 key 确定索引位置的示例，图(b)表示扩容后 key1 和 key2 两种 key 确定索引位置的示例， 其中 hash1 是 key1 对应的哈希与高位运算结果。</li></ul><p><img src="http://image-ericshen.test.upcdn.net/uPic/o70Ff1_XaP9x8RBtn5Zi4K" alt="image-20200504140954765"></p><ul><li><p>元素在重新计算 hash 之后，因为 n 变为 2 倍，那么 n-1 的 mask 范围在高位多 1bit(红色)，因 此新的 index 就会发生这样的变化:<br><img src="http://image-ericshen.test.upcdn.net/uPic/PNmTAu_s6ncj98FyOqvwYk" alt="image-20200504141652310"></p></li><li><p>因此，我们在扩充 HashMap 的时候，不需要像 JDK1.7 的实现那样重新计算 hash，只需要看 看原来的 hash 值新增的那个 bit 是 1 还是 0 就好了，是 0 的话索引没变，是 1 的话索引变成“原 索引+oldCap”，可以看看下图为 16 扩充为 32 的 resize 示意图<br><img src="http://image-ericshen.test.upcdn.net/uPic/JzLQol_3z1KbQcylsBuhRo" alt="image-20200504141050042"></p></li><li><p>这个设计确实非常的巧妙，既省去了重新计算 hash 值的时间，而且同时，由于新增的 1bit 是 0 还是 1 可以认为是随机的，因此 resize 的过程，均匀的把之前的冲突的节点分散到新的 bucket 了。这一块就是 JDK1.8 新增的优化点。</p></li></ul><blockquote><p>参考资料:</p></blockquote><ol><li><a href="https://blog.csdn.net/cyp331203/article/details/42677833">算法导论 红黑树详解之一(插入)</a></li><li><a href="https://blog.csdn.net/lc0817/article/details/48213435/">jdk1.8 HashMap性能提升</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>map</tag>
      
      <tag>collection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Bean Lifecycle</title>
    <link href="/2019/03/21/spring/Spring%20Bean%20Lifecycle/"/>
    <url>/2019/03/21/spring/Spring%20Bean%20Lifecycle/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Spring Bean 的生命周期在整个 Spring 中占有很重要的位置，掌握这些可以加深对 Spring 的理解。</p><p>首先看下生命周期图：</p><p><img src="http://image-ericshen.test.upcdn.net/uPic/YjbEmK_image-20210321141117713" alt="image-20210321141117713"></p><p>再谈生命周期之前有一点需要先明确：</p><blockquote><p>Spring 只帮我们管理单例模式 Bean 的<strong>完整</strong>生命周期，对于 prototype 的 bean ，Spring 在创建好交给使用者之后则不会再管理后续的生命周期。</p></blockquote><span id="more"></span><p>[TOC]</p><h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><p>在 bean 初始化时会经历几个阶段，首先可以使用注解 <code>@PostConstruct</code>, <code>@PreDestroy</code> 来在 bean 的创建和销毁阶段进行调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnnotationBean</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(AnnotationBean.class);<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>&#123;<br>        LOGGER.info(<span class="hljs-string">&quot;AnnotationBean start&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span>&#123;<br>        LOGGER.info(<span class="hljs-string">&quot;AnnotationBean destroy&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="InitializingBean-DisposableBean-接口"><a href="#InitializingBean-DisposableBean-接口" class="headerlink" title="InitializingBean, DisposableBean 接口"></a>InitializingBean, DisposableBean 接口</h3><p>还可以实现 <code>InitializingBean,DisposableBean</code> 这两个接口，也是在初始化以及销毁阶段调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringLifeCycleService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span>,<span class="hljs-title">DisposableBean</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(SpringLifeCycleService.class);<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        LOGGER.info(<span class="hljs-string">&quot;SpringLifeCycleService start&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        LOGGER.info(<span class="hljs-string">&quot;SpringLifeCycleService destroy&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义初始化和销毁方法"><a href="#自定义初始化和销毁方法" class="headerlink" title="自定义初始化和销毁方法"></a>自定义初始化和销毁方法</h3><p>也可以自定义方法用于在初始化、销毁阶段调用:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifeCycleConfig</span> </span>&#123;<br><br><br>    <span class="hljs-meta">@Bean</span>(initMethod = <span class="hljs-string">&quot;start&quot;</span>, destroyMethod = <span class="hljs-string">&quot;destroy&quot;</span>)<br>    <span class="hljs-keyword">public</span> SpringLifeCycle <span class="hljs-function"><span class="hljs-title">create</span>(<span class="hljs-params"></span>)</span>&#123;<br>        SpringLifeCycle springLifeCycle = <span class="hljs-keyword">new</span> SpringLifeCycle() ;<br><br>        <span class="hljs-keyword">return</span> springLifeCycle ;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringLifeCycle</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> final <span class="hljs-keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(SpringLifeCycle.class);<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">start</span>(<span class="hljs-params"></span>)</span>&#123;<br>        LOGGER.info(<span class="hljs-string">&quot;SpringLifeCycle start&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">destroy</span>(<span class="hljs-params"></span>)</span>&#123;<br>        LOGGER.info(<span class="hljs-string">&quot;SpringLifeCycle destroy&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上是在 SpringBoot 中可以这样配置，如果是原始的基于 XML 也是可以使用:</p><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ocaml">&lt;bean <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;com.crossoverjie.spring.SpringLifeCycle&quot;</span> init-<span class="hljs-keyword">method</span>=<span class="hljs-string">&quot;start&quot;</span> destroy-<span class="hljs-keyword">method</span>=<span class="hljs-string">&quot;destroy&quot;</span>&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>来达到同样的效果。</p><h3 id="实现-Aware-接口"><a href="#实现-Aware-接口" class="headerlink" title="实现 *Aware 接口"></a>实现 *Aware 接口</h3><p><code>*Aware</code> 接口可以用于在初始化 bean 时获得 Spring 中的一些对象，如获取 <code>Spring 上下文</code>等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringLifeCycleAware</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContextAware</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(SpringLifeCycleAware.class);<br><br>    <span class="hljs-keyword">private</span> ApplicationContext applicationContext ;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-keyword">this</span>.applicationContext = applicationContext ;<br>        LOGGER.info(<span class="hljs-string">&quot;SpringLifeCycleAware start&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样在 <code>springLifeCycleAware</code> 这个 bean 初始化会就会调用 <code>setApplicationContext</code> 方法，并可以获得 <code>applicationContext</code> 对象。</p><h3 id="BeanPostProcessor-增强处理器"><a href="#BeanPostProcessor-增强处理器" class="headerlink" title="BeanPostProcessor 增强处理器"></a>BeanPostProcessor 增强处理器</h3><p>实现 BeanPostProcessor 接口，Spring 中所有 bean 在做初始化时都会调用该接口中的两个方法，可以用于对一些特殊的 bean 进行处理：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs php">@Component<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringLifeCycleProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-built_in">static</span> Logger LOGGER = LoggerFactory.getLogger(SpringLifeCycleProcessor.<span class="hljs-keyword">class</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 预初始化 初始化之前调用</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bean</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> beanName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> BeansException</span><br><span class="hljs-comment">     */</span><br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">Object</span> postProcessBeforeInitialization(<span class="hljs-keyword">Object</span> bean, <span class="hljs-keyword">String</span> beanName) throws BeansException &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;annotationBean&quot;</span>.equals(beanName))&#123;<br>            LOGGER.info(<span class="hljs-string">&quot;SpringLifeCycleProcessor start beanName=&#123;&#125;&quot;</span>,beanName);<br>        &#125;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 后初始化  bean 初始化完成调用</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bean</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> beanName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> BeansException</span><br><span class="hljs-comment">     */</span><br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">Object</span> postProcessAfterInitialization(<span class="hljs-keyword">Object</span> bean, <span class="hljs-keyword">String</span> beanName) throws BeansException &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;annotationBean&quot;</span>.equals(beanName))&#123;<br>            LOGGER.info(<span class="hljs-string">&quot;SpringLifeCycleProcessor end beanName=&#123;&#125;&quot;</span>,beanName);<br>        &#125;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行之后观察结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs routeros">019-03-21 00:40:24.856 [restartedMain] <span class="hljs-builtin-name">INFO</span>  c.c.s.p.SpringLifeCycleProcessor - SpringLifeCycleProcessor start <span class="hljs-attribute">beanName</span>=annotationBean<br>2019-03-21 00:40:24.860 [restartedMain] <span class="hljs-builtin-name">INFO</span>  c.c.spring.annotation.AnnotationBean - AnnotationBean start<br>2019-03-21 00:40:24.861 [restartedMain] <span class="hljs-builtin-name">INFO</span>  c.c.s.p.SpringLifeCycleProcessor - SpringLifeCycleProcessor end <span class="hljs-attribute">beanName</span>=annotationBean<br>2019-03-21 00:40:24.864 [restartedMain] <span class="hljs-builtin-name">INFO</span>  c.c.s.aware.SpringLifeCycleAware - SpringLifeCycleAware start<br>2019-03-21 00:40:24.867 [restartedMain] <span class="hljs-builtin-name">INFO</span>  c.c.s.service.SpringLifeCycleService - SpringLifeCycleService start<br>2019-03-21 00:40:24.887 [restartedMain] <span class="hljs-builtin-name">INFO</span>  c.c.spring.SpringLifeCycle - SpringLifeCycle start<br>2019-03-21 00:40:25.062 [restartedMain] <span class="hljs-builtin-name">INFO</span>  o.s.b.d.a.OptionalLiveReloadServer - LiveReload<span class="hljs-built_in"> server </span>is running on<span class="hljs-built_in"> port </span>35729<br>2019-03-21 00:40:25.122 [restartedMain] <span class="hljs-builtin-name">INFO</span>  o.s.j.e.a.AnnotationMBeanExporter - Registering beans <span class="hljs-keyword">for</span> JMX exposure on startup<br>2019-03-21 00:40:25.140 [restartedMain] <span class="hljs-builtin-name">INFO</span>  com.crossoverjie.Application - Started Application <span class="hljs-keyword">in</span> 2.309 seconds (JVM running <span class="hljs-keyword">for</span> 3.681)<br>2019-03-21 00:40:25.143 [restartedMain] <span class="hljs-builtin-name">INFO</span>  com.crossoverjie.Application - start ok!<br>2019-03-21 00:40:25.153 [Thread-8] <span class="hljs-builtin-name">INFO</span>  o.s.c.a.AnnotationConfigApplicationContext - Closing org.springframework.context.annotation.AnnotationConfigApplicationContext@3913adad: startup date [Wed Mar 21 00:40:23 CST 2019]; root of context hierarchy<br>2019-03-21 00:40:25.155 [Thread-8] <span class="hljs-builtin-name">INFO</span>  o.s.j.e.a.AnnotationMBeanExporter - Unregistering JMX-exposed beans on shutdown<br>2019-03-21 00:40:25.156 [Thread-8] <span class="hljs-builtin-name">INFO</span>  c.c.spring.SpringLifeCycle - SpringLifeCycle destroy<br>2019-03-21 00:40:25.156 [Thread-8] <span class="hljs-builtin-name">INFO</span>  c.c.s.service.SpringLifeCycleService - SpringLifeCycleService destroy<br>2019-03-21 00:40:25.156 [Thread-8] <span class="hljs-builtin-name">INFO</span>  c.c.spring.annotation.AnnotationBean - AnnotationBean destroy<br></code></pre></td></tr></table></figure><p>直到 Spring 上下文销毁时则会调用自定义的销毁方法以及实现了 <code>DisposableBean</code> 的 <code>destroy()</code> 方法。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Spring中Bean的生命周期如下:</p><ul><li><p>Bean容器找到配置文件中Spring Bean的定义。</p></li><li><p>Bean容器利用Java Reflection API创建一个Bean的实例。</p></li><li><p>如果涉及到一些属性值 利用set方法设置一些属性值。</p></li><li><p>如果Bean实现了BeanNameAware接口，调用setBeanName()方法，传入Bean的名字。</p></li><li><p>如果Bean实现了BeanClassLoaderAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例。</p></li><li><p>如果Bean实现了BeanFactoryAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例。</p></li><li><p>与上面的类似，如果实现了其他*Aware接口，就调用相应的方法。</p></li><li><p>如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessBeforeInitialization()方法</p></li><li><p>如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。</p></li><li><p>如果Bean在配置文件中的定义包含<code>init-method</code>属性，执行指定的方法。</p></li><li><p>如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessAfterInitialization()方法</p></li><li><p>当要销毁Bean的时候，如果Bean实现了DisposableBean接口，执行destroy()方法。</p></li><li><p>当要销毁Bean的时候，如果Bean在配置文件中的定义包含<code>destroy-method</code>属性，执行指定的方法。</p><p><img src="http://image-ericshen.test.upcdn.net/uPic/PYgpTK_image-20210321141057788" alt="image-20210321141057788"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Framework</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git archive 打包文件</title>
    <link href="/2019/03/15/git/git-archive-%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6/"/>
    <url>/2019/03/15/git/git-archive-%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>Git 中打包文件是个简单的活，不管是<strong>打包全部文件</strong>作为 release，</p><p>还是<strong>只压缩更改的文件</strong>，一个命令就能搞定。</p><p>而且，打包之后<strong>目录结构完全不变</strong>，这对于覆盖部署来说极其方便。</p><span id="more"></span><h2 id="1-打包所有文件"><a href="#1-打包所有文件" class="headerlink" title="1 打包所有文件"></a>1 打包所有文件</h2><p>打包<code>master</code>分支的所有文件：</p><blockquote><p>注：本地修改未提交的并不会打包进去</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git archive --format=zip --output master.zip master</span><br></code></pre></td></tr></table></figure><p>其中，输出格式为<code>zip</code>，输出文件为<code>master.zip</code>。git 支持 zip 和 tar 两种输出格式。</p><p>打包当前分支当前<code>HEAD</code>的所有文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git archive --format=zip --output head.zip HEAD</span><br></code></pre></td></tr></table></figure><p>打包<code>v1.2</code>标签的所有文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git archive --format=zip --output v1.2.zip v1.2</span><br></code></pre></td></tr></table></figure><h2 id="2-打包更改的文件"><a href="#2-打包更改的文件" class="headerlink" title="2 打包更改的文件"></a>2 打包更改的文件</h2><p>打包更改文件的原理是：</p><ol><li>用<code>git diff</code> 找出文件列表；</li><li>用打包命令打包。</li></ol><p>也就是说，<strong>只要能用找出文件列表，就可以 git 打包出来。</strong></p><h3 id="2-1-打包最后修改的文件"><a href="#2-1-打包最后修改的文件" class="headerlink" title="2.1 打包最后修改的文件"></a>2.1 打包最后修改的文件</h3><p>先通过<code>git diff</code>找到最新版本修改过的文件，再压缩打包这些文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git archive --format=zip -o update.zip HEAD $(git diff --name-only HEAD^)</span><br></code></pre></td></tr></table></figure><h3 id="2-2-打包最后两个版本修改的文件"><a href="#2-2-打包最后两个版本修改的文件" class="headerlink" title="2.2 打包最后两个版本修改的文件"></a>2.2 打包最后两个版本修改的文件</h3><p>总共也是 2 个版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git archive --format=zip -o update.zip HEAD $(git diff --name-only HEAD~2)</span><br></code></pre></td></tr></table></figure><h3 id="2-3-打包两个分支之间差别的文件"><a href="#2-3-打包两个分支之间差别的文件" class="headerlink" title="2.3 打包两个分支之间差别的文件"></a>2.3 打包两个分支之间差别的文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git archive --format=zip -o update.zip HEAD $(git diff --name-only master fix-error)</span><br></code></pre></td></tr></table></figure><p>如上，打包<code>master</code>和<code>fix-error</code>分支差异的文件。</p><p><strong>参考资料：</strong></p><ol><li><a href="http://tosbourn.com/using-git-to-create-an-archive-of-changed-files/">Using Git to create an archive of changed files.</a></li><li><a href="http://blog.miniasp.com/post/2014/04/01/Git-Export-Only-Added-Modified-Files.aspx">如何讓 Git 僅匯出在特定版本中新增或修改過的檔案</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标准GitFLow工作流程</title>
    <link href="/2018/10/15/git/%E6%A0%87%E5%87%86GitFLow%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
    <url>/2018/10/15/git/%E6%A0%87%E5%87%86GitFLow%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="标准GitFlow工作流程"><a href="#标准GitFlow工作流程" class="headerlink" title="标准GitFlow工作流程"></a>标准GitFlow工作流程</h1><h3 id="版本管理的挑战"><a href="#版本管理的挑战" class="headerlink" title="版本管理的挑战"></a>版本管理的挑战</h3><p>虽然有这么优秀的版本管理工具，但是我们面对版本管理的时候，依然有非常大得挑战，我们都知道大家工作在同一个仓库上，那么彼此的代码协作必然带来很多问题和挑战，如下：</p><ul><li>如何开始一个Feature的开发，而不影响别的<code>Feature</code>？</li><li>由于很容易创建新分支，分支多了如何管理，时间久了，如何知道每个分支是干什么的？</li><li>哪些分支已经合并回了主干？</li><li>如何进行<code>Release</code>的管理？开始一个<code>Release</code>的时候如何冻结Feature, 如何在<code>Prepare Release</code>的时候，开发人员可以继续开发新的功能？</li><li>线上代码出Bug了，如何快速修复？而且修复的代码要包含到开发人员的分支以及下一个<code>Release</code>?</li></ul><p>大部分开发人员现在使用<code>Git</code>就只是用三个甚至两个分支，一个是<code>Master</code>, 一个是<code>Develop</code>, 还有一个是基于<code>Develop</code>打得各种分支。这个在小项目规模的时候还勉强可以支撑，因为很多人做项目就只有一个<code>Release</code>, 但是人员一多，而且项目周期一长就会出现各种问题。</p><span id="more"></span><p>[TOC]</p><h3 id="一、Git-Flow-简介"><a href="#一、Git-Flow-简介" class="headerlink" title="一、Git Flow 简介"></a>一、Git Flow 简介</h3><p><code>Git Flow</code> 是一个围绕项目开发发布的严格 git 分支模型，用于管理多人协作的大型项目中实现高效的协作开发，大致分为三种:</p><ul><li><code>Git Flow</code>: 最原始的 <code>Git Flow</code> 分支模型</li><li><code>Github Flow</code>: <code>Git Flow</code> 的简化版，专门配合持续发布</li><li><code>GitLab Flow</code>: <code>Git Flow</code> 与 <code>Github Flow</code> 的结合版</li></ul><p>关于三种 <code>Git Flow</code> 区别详情可参考大佬阮一峰的 <a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html">Git 工作流程</a></p><h3 id="二、-Git-Flow-流程"><a href="#二、-Git-Flow-流程" class="headerlink" title="二、 Git Flow 流程"></a>二、 Git Flow 流程</h3><p>Github Flow 和 GitLab Flow 对于持续发布支持比较好，但是原始版本的 Git Flow 对于传统的按照版本发布更加友好一些，所以以下主要说明以下 Git Flow 的工作流程；Git Flow 主要分支模型如下</p><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/BkcQboiAUa7NWMS.jpg" alt=""></p><blockquote><p>上面这个官方图可能看起来不太直观，可参考下图：</p><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/3V1RbWPzZftxBOy.jpg" alt=""></p></blockquote><p>在整个分支模型中 <strong>存在两个长期分支: <code>develop</code> 和 <code>master</code></strong>，其中 <code>develop</code> 分支为开发分支，<code>master</code> 为生产分支；<strong><code>master</code> 代码始终保持随时可以部署到线上的状态；<code>develop</code> 分支用于合并最新提交的功能性代码</strong>；具体的分支定义如下</p><ul><li><code>master</code>: 生产代码，始终保持可以直接部署生产的状态</li><li><code>develop</code>: 开发分支，每次合并最新功能代码到此分支</li><li><code>feature</code>: 新功能分支，所有新开发的功能将采用 <code>feature/xxxx</code> 形式命名分支</li><li><code>hotfixe</code>: 紧急修复补丁分支，当新功能部署到了线上出现了严重 bug 需要紧急修复时，则创建 <code>hotfixe/xxxx</code> 形式命名的分支</li><li><code>release</code>: 稳定版分支，当完成大版本变动后，应该创建 <code>release/xxxx</code> 分支</li></ul><p>在整个分支模型中，<code>develop</code> 分支为最上游分支，会不断有新的 <code>feature</code> 合并入 <code>develop</code> 分支，当功能开发达到完成所有版本需求时，则从 <code>develop</code> 分支创建 <code>release</code> 分支，release 后如没有发现其他问题，最终 <code>release</code> 会被合并到 <code>master</code> 分支以完成线上部署</p><blockquote><p>Git Flow如何工作</p></blockquote><p><strong>初始分支</strong></p><ul><li>所有在<code>Master</code>分支上的<code>Commit</code>应该<code>Tag</code><br><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/iZw7FSPfLsEcyBJ.jpg" alt=""></li><li><code>Feature</code> 分支分支名 <code>feature/feature1</code>分支做完后，必须合并回<code>Develop</code>分支, 合并完分支后一般会删点这个Feature分支，但是我们也可以保留<br><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/LnGjsQtRh4l2FSo.jpg" alt=""></li><li><code>Release</code>分支分支名 <code>release/release1</code>分支基于<code>Develop</code>分支创建，打完<code>Release</code>分之后，我们可以在这个<code>Release</code>分支上测试，修改Bug等。同时，其它开发人员可以基于开发新的<code>Feature</code> (记住：一旦打了<code>Release</code>分支之后不要从<code>Develop</code>分支上合并新的改动到<code>Release</code>分支)发布<code>Release</code>分支时，合并<code>Release</code>到<code>Master</code>和Develop， 同时在<code>Master</code>分支上打个Tag记住<code>Release</code>版本号，然后可以删除<code>Release</code>分支了。<br><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/HL8TN1UfK5FShyr.jpg" alt=""></li><li>维护分支 Hotfix分支名 hotfix/hotfix1分支基于Master分支创建，开发完后需要合并回Master和Develop分支，同时在Master上打一个tag<br><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/c89z3YPqKph5j1T.png" alt="fa159868df4a416d391c6fd832851f9a.png"></li></ul><blockquote><p>Git 命令：</p></blockquote><ol><li>创建develop分支</li></ol><ul><li><code>git branch develop git push -u origin develop</code></li></ul><ol start="2"><li>开始新Feature开发</li></ol><ul><li><p><code>git checkout -b some-feature develop</code></p></li><li><p><code>git push -u origin some-feature</code> <em>可选推送至远端</em></p></li><li><p><code>git status</code></p></li><li><p><code>git add some-file</code></p></li><li><p><code>git commit</code></p></li></ul><ol start="3"><li>完成Feature</li></ol><ul><li><code>git pull origin develop</code></li><li><code>git checkout develop</code></li><li><code>git merge --no-ff some-feature</code></li><li><code>git push origin develop</code></li><li><code>git branch -d some-feature</code></li><li><code>git push origin --delete some-feature</code><em>取决于是否已将Feature提交到远端</em></li></ul><ol start="4"><li>开始Release</li></ol><ul><li><code>git checkout -b release-0.1.0 develop</code></li></ul><ol start="5"><li>完成Release</li></ol><ul><li><code>git checkout master</code></li><li><code>git merge --no-ff release-0.1.0</code></li><li><code>git push</code></li><li><code>git checkout develop</code></li><li><code>git merge --no-ff release-0.1.0</code></li><li><code>git push git branch -d release-0.1.0</code></li><li><code>git push origin --delete release-0.1.0</code> <em>取决于是否已将Release提交到远端</em></li><li><code>git tag -a v0.1.0 master</code></li><li><code>git push --tags</code></li></ul><ol start="6"><li>开始Hotfix</li></ol><ul><li><code>git checkout -b hotfix-0.1.1 master</code></li></ul><ol start="7"><li>完成Hotfix</li></ol><ul><li><code>git checkout master</code></li><li><code>git merge --no-ff hotfix-0.1.1</code></li><li><code>git push</code></li><li><code>git checkout develop</code></li><li><code>git merge --no-ff hotfix-0.1.1</code></li><li><code>git push</code></li><li><code>git branch -d hotfix-0.1.1</code></li><li><code>git tag -a v0.1.1 master</code></li><li><code>git push --tags</code></li></ul><h3 id="三、Git-Flow-工具"><a href="#三、Git-Flow-工具" class="headerlink" title="三、Git Flow 工具"></a>三、Git Flow 工具</h3><p>针对于 Git Flow，其手动操作 git 命令可能过于繁琐，所以后来有了 git-flow 工具；git-flow 是一个 git 扩展集； git-flow 安装以及使用具体请参考 <a href="https://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html">git-flow 备忘清单</a>，该文章详细描述了 git-flow 工具的使用方式<br><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/FYQLHx.png" alt="git flow"></p><ul><li>那么又有人做出了<code>GUI</code>工具，你只需要点击下一步就行，工具帮你干这些事。<br>当你用Git-<code>flow</code>初始化后，基本上你只需要点击git flow菜单选择start feature, release或者hotfix, 做完后再次选择git flow菜单，点击Done Action.</li></ul><blockquote><p>个人推荐：<a href="https://www.sourcetreeapp.com/">SourceTree</a>强大的图形化Git工作流（点点点），最主要是免费！<br><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/L5yPmrD1hfi3NOX.png" alt="image.png"></p></blockquote><p><strong>IDE集成参考</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/z7ZXnkro5bFc4Tv.png" alt=""></p><ul><li><strong>JetBrain</strong>系列开发工具(如IDEA、WebStorm、PyCharm):<ul><li><code>Settings</code>&gt;<code>Plugins</code>&gt;<code>Browse repositories</code>，搜索<strong>Git Flow Integration</strong>安装；</li><li>或访问<a href="https://plugins.jetbrains.com/plugin/7315-git-flow-integration">JetBrain官方库</a>下载，在<code>Plugins</code>&gt;<code>Install plugin from disk</code>安装。</li></ul></li><li><strong>VisualStudio</strong>系列开发工具：<ul><li><code>工具</code>&gt;<code>扩展和更新</code>，搜索<strong>GitFlow</strong>安装，详见<a href="https://marketplace.visualstudio.com/search?term=gitflow&target=VS&category=Tools&vsVersion=&subCategory=All&sortBy=Relevance">Marketplace</a></li></ul></li><li><strong>VS Code</strong>:<ul><li><code>Extensions</code>，搜索<strong>gitflow</strong>安装，完成后通过<code>Command Palettee</code>调用，建议同<code>GitLens</code>配合食用</li></ul></li></ul><h3 id="四、GitLab-整合"><a href="#四、GitLab-整合" class="headerlink" title="四、GitLab 整合"></a>四、GitLab 整合</h3><p>以上 <code>Git Flow</code> 所有操作介绍的都是在本地操作，而正常我们在工作中都是基于 <code>GitLab</code> 搭建私有 <code>Git</code> 仓库来进行协同开发的，以下简述以下 <code>Git Flow</code> 配合 <code>GitLab</code> 的流程</p><h4 id="4-1-开发-features"><a href="#4-1-开发-features" class="headerlink" title="4.1 开发 features"></a>4.1 开发 features</h4><p>当开发一个新功能时流程如下:</p><ul><li>本地 <code>git flow feature start xxxx</code> 开启一个 feature 新分支</li><li><code>git flow feature publish xxxx</code> 将此分支推送到远端以便他人获取 (可选)</li><li>完成开发后 <code>GitLab</code> 上向 <code>develop</code> 分支发起合并请求</li><li><code>CI sonar</code> 等质量检测工具扫描，其他用户 <code>review</code> 代码</li><li>确认无误后 <code>master</code> 权限用户合并其到 <code>develop</code> 分支</li><li>部署到测试环境以便测试组测试</li><li>如果测试不通过，则继续基于此分支开发，直到该功能开发完成</li></ul><h4 id="4-2-创建-release"><a href="#4-2-创建-release" class="headerlink" title="4.2 创建 release"></a>4.2 创建 release</h4><p>当一定量的 feature 开发完成并合并到 <code>develop</code> 后，如所有 <code>feature</code> 都测试通过并满足版本需求，则可以创建 <code>release</code> 版本分支；release 分支流程如下</p><ul><li>本地 <code>git flow release start xxxx</code> 开启 <code>release</code> 分支</li><li><code>git flow release publish xxxx</code> 将其推送到远端以便他人获取</li><li>继续进行完整性测试，出现问题继续修复，直到 <code>release</code> 完全稳定</li><li>从 <code>release</code> 分支向 <code>master</code>、<code>develop</code> 分支分别发起合并请求</li><li><code>master</code> 合并后创建对应的 <code>release</code> 标签，并部署生产环境</li><li><code>develop</code> 合并 <code>release</code> 的后期修改</li></ul><h4 id="4-3-紧急修复hotfix"><a href="#4-3-紧急修复hotfix" class="headerlink" title="4.3 紧急修复hotfix"></a>4.3 紧急修复hotfix</h4><p>当 <code>master</code> 某个 <code>tag</code> 部署到生产环境后，也可能出现不符合预期的问题出现；此时应该基于 <code>master</code> 创建 <code>hotfix</code> 分支进行修复，流程如下标准<code>GitFlow</code>工作流程</p><ul><li>本地 <code>git flow hotfix start xxxx</code> 创建紧急修复分支</li><li>修改代码后将其推送到远端，并向 <code>master</code>、<code>develop</code> 分支发起合并</li><li><code>develop</code> 合并紧急修复补丁，如果必要最好再做一下测试</li><li><code>master</code> 合并紧急修复补丁，创建紧急修复 <code>tag</code>，并部署生产环境</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html">Git 工作流程</a></li><li><a href="https://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html">git-flow 备忘清单</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>git-flow</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux同步系统时间</title>
    <link href="/2018/10/13/linux/Linux%E5%90%8C%E6%AD%A5%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/"/>
    <url>/2018/10/13/linux/Linux%E5%90%8C%E6%AD%A5%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<p>一、修改时区：</p><ul><li>方法 1:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp /usr/share/zoneinfo/Asia/Shanghai  /etc/localtime<br></code></pre></td></tr></table></figure><ul><li>方法 2： </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">timedatectl list-timezones <span class="hljs-comment">#列出时区</span><br>timedatectl set-timezone Asia/Shanghai <span class="hljs-comment">#设置时区为亚洲/上海</span><br></code></pre></td></tr></table></figure><ul><li>方法 3：使用  tzselect</li></ul><p>查看是否修改成功：<code>date</code></p><p>Fri Dec 14 10:48:05 CST 2018</p><p>如果显示 CST 则说明时区设置成功</p><span id="more"></span><blockquote><p>CST：中国标准时间（China Standard Time），这个解释可能是针对 RedHat Linux。</p></blockquote><blockquote><p>UTC：协调世界时，又称世界标准时间，简称 UTC，从英文国际时间 / 法文协调时间”Universal Time/Temps Cordonn&eacute;” 而来。中国大陆、香港、澳门、台湾、蒙古国、新加坡、马来西亚、菲律宾、澳洲西部的时间与 UTC 的时差均为 + 8，也就是 UTC+8。</p></blockquote><blockquote><p>GMT：格林尼治标准时间（旧译格林威治平均时间或格林威治标准时间；英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义在通过那里的经线。</p></blockquote><p>设置完系统时间后, 还需要同步到硬件时钟上</p><p>二、查看和修改时间</p><ul><li><p>显示时间: <code>date</code></p></li><li><p>修改时间: <code>date -s  时间</code><br>如：设置当前时间为：2018 年 12 月 10 点 50 分<br><code>date -s  ‘2018-12-14 10:50:00’</code></p></li><li><p>根据网络同步时间<br>使用 ntp 同步标准时间，ntp：网络时间协议（network time protol）<br>安装：<code>yum install ntp</code><br>同步：<code>ntpdate pool.ntp.org</code></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决Ubuntu 18.04 DHCP ip失效问题</title>
    <link href="/2018/07/14/linux/%E8%A7%A3%E5%86%B3Ubuntu-18-04-DHCP-ip%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/"/>
    <url>/2018/07/14/linux/%E8%A7%A3%E5%86%B3Ubuntu-18-04-DHCP-ip%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="解决Ubuntu-18-04-DHCP-ip失效问题"><a href="#解决Ubuntu-18-04-DHCP-ip失效问题" class="headerlink" title="解决Ubuntu 18.04 DHCP ip失效问题"></a>解决Ubuntu 18.04 DHCP ip失效问题</h1><p>今天在准备弄一个<code>k8s</code>虚拟机集群，自然是装好一个，然后 <code>clone</code> 成三份。但是有一个问题，clone 的时候虽然选择了更换 <code>MAC</code> 地址，但是 起来之后发现 <code>ip</code> 地址还是没变。原来是 <code>systemd-networkd</code> 的老 bug。它不是根据 <code>MAC</code> 地址来决定是否换 IP，而是根据 <code>/etc/machine-id</code> 来计算出来一个值，如果这个值发生了变化，那么就更换 IP 地址。</p><p>所以就需要把 <code>/etc/machine-id</code> 给换一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo su<br>uuidgen | sed <span class="hljs-string">&#x27;s/-//g&#x27;</span> &gt; /etc/machine-id<br>reboot<br></code></pre></td></tr></table></figure><p>即可。</p><p>参考资料：</p><ul><li><a href="https://www.freedesktop.org/software/systemd/man/networkd.conf.html">https://www.freedesktop.org/software/systemd/man/networkd.conf.html</a></li><li><a href="https://unix.stackexchange.com/questions/456763/new-ip-address-whereas-dhcp-lease-time-not-out">https://unix.stackexchange.com/questions/456763/new-ip-address-whereas-dhcp-lease-time-not-out</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS的service自启动</title>
    <link href="/2018/07/03/linux/CentOS%E7%9A%84service%E8%87%AA%E5%90%AF%E5%8A%A8/"/>
    <url>/2018/07/03/linux/CentOS%E7%9A%84service%E8%87%AA%E5%90%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="CentOS-7添加开机启动服务-脚本"><a href="#CentOS-7添加开机启动服务-脚本" class="headerlink" title="CentOS 7添加开机启动服务/脚本"></a>CentOS 7添加开机启动服务/脚本</h1><ul><li>以<code>nginx</code>为例</li></ul><h2 id="1-建立服务文件"><a href="#1-建立服务文件" class="headerlink" title="1.建立服务文件"></a>1.建立服务文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /usr/lib/systemd/system/nginx.service<br><br>[Unit]<br>Description=nginx - high performance web server<br>After=network.target remote-fs.target nss-lookup.target<br>[Service]<br>Type=forking<br>ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf<br>ExecReload=/usr/local/nginx/sbin/nginx -s reload<br>ExecStop=/usr/local/nginx/sbin/nginx -s stop<br>[Install]<br>WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><blockquote><p>service文件说明</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs shell">Type的类型有：<br>    simple(默认）：# 以ExecStart字段启动的进程为主进程<br>    forking:  # ExecStart字段以fork()方式启动，此时父进程将退出，子进程将成为主进程（后台运行）。一般都设置为forking<br>    oneshot:  # 类似于simple，但只执行一次，systemd会等它执行完，才启动其他服务<br>    dbus：    # 类似于simple, 但会等待D-Bus信号后启动<br>    notify:   # 类似于simple, 启动结束后会发出通知信号，然后systemd再启动其他服务<br>    idle：    # 类似于simple，但是要等到其他任务都执行完，才会启动该服务。<br>    <br>EnvironmentFile:<br>    指定配置文件，和连词号组合使用，可以避免配置文件不存在的异常。<br><br>Environment:<br>    后面接多个不同的shell变量。<br>    例如：<br>    Environment=DATA_DIR=/data/elk<br>    Environment=LOG_DIR=/var/log/elasticsearch<br>    Environment=PID_DIR=/var/run/elasticsearch<br>    EnvironmentFile=-/etc/sysconfig/elasticsearch<br>    <br>连词号（-）：在所有启动设置之前，添加的变量字段，都可以加上连词号<br>    表示抑制错误，即发生错误时，不影响其他命令的执行。<br>    比如`EnviromentFile=-/etc/sysconfig/xxx` 表示即使文件不存在，也不会抛异常<br>    <br>KillMode的类型：<br>    control-group(默认)：# 当前控制组里的所有子进程，都会被杀掉<br>    process: # 只杀主进程<br>    mixed:   # 主进程将收到SIGTERM信号，子进程收到SIGKILL信号<br>    none:    # 没有进程会被杀掉，只是执行服务的stop命令<br>Restart的类型：<br>    no(默认值)： # 退出后无操作<br>    on-success:  # 只有正常退出时（退出状态码为0）,才会重启<br>    on-failure:  # 非正常退出时，重启，包括被信号终止和超时等<br>    on-abnormal: # 只有被信号终止或超时，才会重启<br>    on-abort:    # 只有在收到没有捕捉到的信号终止时，才会重启<br>    on-watchdog: # 超时退出时，才会重启<br>    always:      # 不管什么退出原因，都会重启<br>    # 对于守护进程，推荐用on-failure<br>RestartSec字段：<br>    表示systemd重启服务之前，需要等待的秒数：RestartSec: 30 <br>    <br>各种Exec*字段：<br>    # Exec* 后面接的命令，仅接受“指令 参数 参数..”格式，不能接受&lt;&gt;|&amp;等特殊字符，很多bash语法也不支持。如果想支持bash语法，需要设置Tyep=oneshot<br>    ExecStart：    # 启动服务时执行的命令<br>    ExecReload：   # 重启服务时执行的命令 <br>    ExecStop：     # 停止服务时执行的命令 <br>    ExecStartPre： # 启动服务前执行的命令 <br>    ExecStartPost：# 启动服务后执行的命令 <br>    ExecStopPost： # 停止服务后执行的命令<br><br>    <br>WantedBy字段：<br>    multi-user.target: # 表示多用户命令行状态，这个设置很重要<br>    graphical.target:  # 表示图形用户状体，它依赖于multi-user.target<br></code></pre></td></tr></table></figure></blockquote><h2 id="2-保存目录"><a href="#2-保存目录" class="headerlink" title="2.保存目录"></a>2.保存目录</h2><p><code>/usr/lib/systemd/system</code></p><h2 id="3-设置开机自启动"><a href="#3-设置开机自启动" class="headerlink" title="3.设置开机自启动"></a>3.设置开机自启动</h2><p><code>systemctl enable nginx.service</code></p><h2 id="4-常用命令"><a href="#4-常用命令" class="headerlink" title="4. 常用命令"></a>4. 常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">启动nginx服务<br>systemctl start nginx.service<br>设置开机自动启动<br><br>systemctl enable nginx.service<br>停止开机自动启动<br><br>systemctl disable nginx.service<br>查看状态<br><br>systemctl status nginx.service<br>重启服务<br><br>systemctl restart nginx.service<br>查看所有服务<br><br>systemctl list-units --type=service<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx配置文件详解</title>
    <link href="/2018/02/03/linux/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <url>/2018/02/03/linux/Nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx配置文件nginx-conf"><a href="#Nginx配置文件nginx-conf" class="headerlink" title="Nginx配置文件nginx.conf"></a>Nginx配置文件nginx.conf</h1><span id="more"></span><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">######Nginx配置文件nginx.conf、#####</span><br><br><span class="hljs-comment">#定义Nginx运行的用户和用户组</span><br><span class="hljs-string">user</span> <span class="hljs-string">www</span> <span class="hljs-string">www;</span><br><br><span class="hljs-comment">#nginx进程数，建议设置为等于CPU总核心数。</span><br><span class="hljs-string">worker_processes</span> <span class="hljs-number">8</span><span class="hljs-string">;</span><br> <br><span class="hljs-comment">#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span><br><span class="hljs-string">error_log</span> <span class="hljs-string">/usr/local/nginx/logs/error.log</span> <span class="hljs-string">info;</span><br><br><span class="hljs-comment">#进程pid文件</span><br><span class="hljs-string">pid</span> <span class="hljs-string">/usr/local/nginx/logs/nginx.pid;</span><br><br><span class="hljs-comment">#指定进程可以打开的最大描述符：数目</span><br><span class="hljs-comment">#工作模式与连接数上限</span><br><span class="hljs-comment">#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。</span><br><span class="hljs-comment">#现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。</span><br><span class="hljs-comment">#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。</span><br><span class="hljs-string">worker_rlimit_nofile</span> <span class="hljs-number">65535</span><span class="hljs-string">;</span><br><br><br><span class="hljs-string">events</span><br>&#123;<br>    <span class="hljs-comment">#参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型</span><br>    <span class="hljs-comment">#是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。</span><br>    <span class="hljs-comment">#补充说明：</span><br>    <span class="hljs-comment">#与apache相类，nginx针对不同的操作系统，有不同的事件模型</span><br>    <span class="hljs-comment">#A）标准事件模型</span><br>    <span class="hljs-comment">#Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll</span><br>    <span class="hljs-comment">#B）高效事件模型</span><br>    <span class="hljs-comment">#Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。</span><br>    <span class="hljs-comment">#Epoll：使用于Linux内核2.6版本及以后的系统。</span><br>    <span class="hljs-comment">#/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。</span><br>    <span class="hljs-comment">#Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。</span><br>    <span class="hljs-string">use</span> <span class="hljs-string">epoll;</span><br><br>    <span class="hljs-comment">#单个进程最大连接数（最大连接数=连接数*进程数）</span><br>    <span class="hljs-comment">#根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。</span><br>    <span class="hljs-string">worker_connections</span> <span class="hljs-number">65535</span><span class="hljs-string">;</span><br><br>    <span class="hljs-comment">#keepalive超时时间。</span><br>    <span class="hljs-string">keepalive_timeout</span> <span class="hljs-number">60</span><span class="hljs-string">;</span><br><br>    <span class="hljs-comment">#客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。</span><br>    <span class="hljs-comment">#分页大小可以用命令getconf PAGESIZE 取得。</span><br>    <span class="hljs-comment">#[root@web001 ~]# getconf PAGESIZE</span><br>    <span class="hljs-comment">#4096</span><br>    <span class="hljs-comment">#但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。</span><br>    <span class="hljs-string">client_header_buffer_size</span> <span class="hljs-string">4k;</span><br><br>    <span class="hljs-comment">#这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。</span><br>    <span class="hljs-string">open_file_cache</span> <span class="hljs-string">max=65535</span> <span class="hljs-string">inactive=60s;</span><br><br>    <span class="hljs-comment">#这个是指多长时间检查一次缓存的有效信息。</span><br>    <span class="hljs-comment">#语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息.</span><br>    <span class="hljs-string">open_file_cache_valid</span> <span class="hljs-string">80s;</span><br><br>    <span class="hljs-comment">#open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。</span><br>    <span class="hljs-comment">#语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location  这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态.</span><br>    <span class="hljs-string">open_file_cache_min_uses</span> <span class="hljs-number">1</span><span class="hljs-string">;</span><br>    <br>    <span class="hljs-comment">#语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.</span><br>    <span class="hljs-string">open_file_cache_errors</span> <span class="hljs-string">on;</span><br>&#125;<br> <br> <br> <br><span class="hljs-comment">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span><br><span class="hljs-string">http</span><br>&#123;<br>    <span class="hljs-comment">#文件扩展名与文件类型映射表</span><br>    <span class="hljs-string">include</span> <span class="hljs-string">mime.types;</span><br><br>    <span class="hljs-comment">#默认文件类型</span><br>    <span class="hljs-string">default_type</span> <span class="hljs-string">application/octet-stream;</span><br><br>    <span class="hljs-comment">#默认编码</span><br>    <span class="hljs-comment">#charset utf-8;</span><br><br>    <span class="hljs-comment">#服务器名字的hash表大小</span><br>    <span class="hljs-comment">#保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小.</span><br>    <span class="hljs-string">server_names_hash_bucket_size</span> <span class="hljs-number">128</span><span class="hljs-string">;</span><br><br>    <span class="hljs-comment">#客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。</span><br>    <span class="hljs-string">client_header_buffer_size</span> <span class="hljs-string">32k;</span><br><br>    <span class="hljs-comment">#客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。</span><br>    <span class="hljs-string">large_client_header_buffers</span> <span class="hljs-number">4</span> <span class="hljs-string">64k;</span><br><br>    <span class="hljs-comment">#设定通过nginx上传文件的大小</span><br>    <span class="hljs-string">client_max_body_size</span> <span class="hljs-string">8m;</span><br><br>    <span class="hljs-comment">#开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span><br>    <span class="hljs-comment">#sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。</span><br>    <span class="hljs-string">sendfile</span> <span class="hljs-string">on;</span><br><br>    <span class="hljs-comment">#开启目录列表访问，合适下载服务器，默认关闭。</span><br>    <span class="hljs-string">autoindex</span> <span class="hljs-string">on;</span><br><br>    <span class="hljs-comment">#此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用</span><br>    <span class="hljs-string">tcp_nopush</span> <span class="hljs-string">on;</span><br>     <br>    <span class="hljs-string">tcp_nodelay</span> <span class="hljs-string">on;</span><br><br>    <span class="hljs-comment">#长连接超时时间，单位是秒</span><br>    <span class="hljs-string">keepalive_timeout</span> <span class="hljs-number">120</span><span class="hljs-string">;</span><br><br>    <span class="hljs-comment">#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。</span><br>    <span class="hljs-string">fastcgi_connect_timeout</span> <span class="hljs-number">300</span><span class="hljs-string">;</span><br>    <span class="hljs-string">fastcgi_send_timeout</span> <span class="hljs-number">300</span><span class="hljs-string">;</span><br>    <span class="hljs-string">fastcgi_read_timeout</span> <span class="hljs-number">300</span><span class="hljs-string">;</span><br>    <span class="hljs-string">fastcgi_buffer_size</span> <span class="hljs-string">64k;</span><br>    <span class="hljs-string">fastcgi_buffers</span> <span class="hljs-number">4</span> <span class="hljs-string">64k;</span><br>    <span class="hljs-string">fastcgi_busy_buffers_size</span> <span class="hljs-string">128k;</span><br>    <span class="hljs-string">fastcgi_temp_file_write_size</span> <span class="hljs-string">128k;</span><br><br>    <span class="hljs-comment">#gzip模块设置</span><br>    <span class="hljs-string">gzip</span> <span class="hljs-string">on;</span> <span class="hljs-comment">#开启gzip压缩输出</span><br>    <span class="hljs-string">gzip_min_length</span> <span class="hljs-string">1k;</span>    <span class="hljs-comment">#最小压缩文件大小</span><br>    <span class="hljs-string">gzip_buffers</span> <span class="hljs-number">4</span> <span class="hljs-string">16k;</span>    <span class="hljs-comment">#压缩缓冲区</span><br>    <span class="hljs-string">gzip_http_version</span> <span class="hljs-number">1.0</span><span class="hljs-string">;</span>    <span class="hljs-comment">#压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span><br>    <span class="hljs-string">gzip_comp_level</span> <span class="hljs-number">2</span><span class="hljs-string">;</span>    <span class="hljs-comment">#压缩等级</span><br>    <span class="hljs-string">gzip_types</span> <span class="hljs-string">text/plain</span> <span class="hljs-string">application/x-javascript</span> <span class="hljs-string">text/css</span> <span class="hljs-string">application/xml;</span>    <span class="hljs-comment">#压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。</span><br>    <span class="hljs-string">gzip_vary</span> <span class="hljs-string">on;</span><br><br>    <span class="hljs-comment">#开启限制IP连接数的时候需要使用</span><br>    <span class="hljs-comment">#limit_zone crawler $binary_remote_addr 10m;</span><br><br><br><br>    <span class="hljs-comment">#负载均衡配置</span><br>    <span class="hljs-string">upstream</span> <span class="hljs-string">piao.jd.com</span> &#123;<br>     <br>        <span class="hljs-comment">#upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。</span><br>        <span class="hljs-string">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.80</span><span class="hljs-number">.121</span><span class="hljs-string">:80</span> <span class="hljs-string">weight=3;</span><br>        <span class="hljs-string">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.80</span><span class="hljs-number">.122</span><span class="hljs-string">:80</span> <span class="hljs-string">weight=2;</span><br>        <span class="hljs-string">server</span> <span class="hljs-number">192.168</span><span class="hljs-number">.80</span><span class="hljs-number">.123</span><span class="hljs-string">:80</span> <span class="hljs-string">weight=3;</span><br><br>        <span class="hljs-comment">#nginx的upstream目前支持4种方式的分配</span><br>        <span class="hljs-comment">#1、轮询（默认）</span><br>        <span class="hljs-comment">#每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</span><br>        <span class="hljs-comment">#2、weight</span><br>        <span class="hljs-comment">#指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</span><br>        <span class="hljs-comment">#例如：</span><br>        <span class="hljs-comment">#upstream bakend &#123;</span><br>        <span class="hljs-comment">#    server 192.168.0.14 weight=10;</span><br>        <span class="hljs-comment">#    server 192.168.0.15 weight=10;</span><br>        <span class="hljs-comment">#&#125;</span><br>        <span class="hljs-comment">#2、ip_hash</span><br>        <span class="hljs-comment">#每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</span><br>        <span class="hljs-comment">#例如：</span><br>        <span class="hljs-comment">#upstream bakend &#123;</span><br>        <span class="hljs-comment">#    ip_hash;</span><br>        <span class="hljs-comment">#    server 192.168.0.14:88;</span><br>        <span class="hljs-comment">#    server 192.168.0.15:80;</span><br>        <span class="hljs-comment">#&#125;</span><br>        <span class="hljs-comment">#3、fair（第三方）</span><br>        <span class="hljs-comment">#按后端服务器的响应时间来分配请求，响应时间短的优先分配。</span><br>        <span class="hljs-comment">#upstream backend &#123;</span><br>        <span class="hljs-comment">#    server server1;</span><br>        <span class="hljs-comment">#    server server2;</span><br>        <span class="hljs-comment">#    fair;</span><br>        <span class="hljs-comment">#&#125;</span><br>        <span class="hljs-comment">#4、url_hash（第三方）</span><br>        <span class="hljs-comment">#按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</span><br>        <span class="hljs-comment">#例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</span><br>        <span class="hljs-comment">#upstream backend &#123;</span><br>        <span class="hljs-comment">#    server squid1:3128;</span><br>        <span class="hljs-comment">#    server squid2:3128;</span><br>        <span class="hljs-comment">#    hash $request_uri;</span><br>        <span class="hljs-comment">#    hash_method crc32;</span><br>        <span class="hljs-comment">#&#125;</span><br><br>        <span class="hljs-comment">#tips:</span><br>        <span class="hljs-comment">#upstream bakend&#123;#定义负载均衡设备的Ip及设备状态&#125;&#123;</span><br>        <span class="hljs-comment">#    ip_hash;</span><br>        <span class="hljs-comment">#    server 127.0.0.1:9090 down;</span><br>        <span class="hljs-comment">#    server 127.0.0.1:8080 weight=2;</span><br>        <span class="hljs-comment">#    server 127.0.0.1:6060;</span><br>        <span class="hljs-comment">#    server 127.0.0.1:7070 backup;</span><br>        <span class="hljs-comment">#&#125;</span><br>        <span class="hljs-comment">#在需要使用负载均衡的server中增加 proxy_pass http://bakend/;</span><br><br>        <span class="hljs-comment">#每个设备的状态设置为:</span><br>        <span class="hljs-comment">#1.down表示单前的server暂时不参与负载</span><br>        <span class="hljs-comment">#2.weight为weight越大，负载的权重就越大。</span><br>        <span class="hljs-comment">#3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误</span><br>        <span class="hljs-comment">#4.fail_timeout:max_fails次失败后，暂停的时间。</span><br>        <span class="hljs-comment">#5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</span><br><br>        <span class="hljs-comment">#nginx支持同时设置多组的负载均衡，用来给不用的server来使用。</span><br>        <span class="hljs-comment">#client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug</span><br>        <span class="hljs-comment">#client_body_temp_path设置记录文件的目录 可以设置最多3层目录</span><br>        <span class="hljs-comment">#location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡</span><br>    &#125;<br>     <br>     <br>     <br>    <span class="hljs-comment">#虚拟主机的配置</span><br>    <span class="hljs-string">server</span><br>    &#123;<br>        <span class="hljs-comment">#监听端口</span><br>        <span class="hljs-string">listen</span> <span class="hljs-number">80</span><span class="hljs-string">;</span><br><br>        <span class="hljs-comment">#域名可以有多个，用空格隔开</span><br>        <span class="hljs-string">server_name</span> <span class="hljs-string">www.jd.com</span> <span class="hljs-string">jd.com;</span><br>        <span class="hljs-string">index</span> <span class="hljs-string">index.html</span> <span class="hljs-string">index.htm</span> <span class="hljs-string">index.php;</span><br>        <span class="hljs-string">root</span> <span class="hljs-string">/data/www/jd;</span><br><br>        <span class="hljs-comment">#对******进行负载均衡</span><br>        <span class="hljs-string">location</span> <span class="hljs-string">~</span> <span class="hljs-string">.*.(php|php5)?$</span><br>        &#123;<br>            <span class="hljs-string">fastcgi_pass</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:9000;</span><br>            <span class="hljs-string">fastcgi_index</span> <span class="hljs-string">index.php;</span><br>            <span class="hljs-string">include</span> <span class="hljs-string">fastcgi.conf;</span><br>        &#125;<br>         <br>        <span class="hljs-comment">#图片缓存时间设置</span><br>        <span class="hljs-string">location</span> <span class="hljs-string">~</span> <span class="hljs-string">.*.(gif|jpg|jpeg|png|bmp|swf)$</span><br>        &#123;<br>            <span class="hljs-string">expires</span> <span class="hljs-string">10d;</span><br>        &#125;<br>         <br>        <span class="hljs-comment">#JS和CSS缓存时间设置</span><br>        <span class="hljs-string">location</span> <span class="hljs-string">~</span> <span class="hljs-string">.*.(js|css)?$</span><br>        &#123;<br>            <span class="hljs-string">expires</span> <span class="hljs-string">1h;</span><br>        &#125;<br>         <br>        <span class="hljs-comment">#日志格式设定</span><br>        <span class="hljs-comment">#$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；</span><br>        <span class="hljs-comment">#$remote_user：用来记录客户端用户名称；</span><br>        <span class="hljs-comment">#$time_local： 用来记录访问时间与时区；</span><br>        <span class="hljs-comment">#$request： 用来记录请求的url与http协议；</span><br>        <span class="hljs-comment">#$status： 用来记录请求状态；成功是200，</span><br>        <span class="hljs-comment">#$body_bytes_sent ：记录发送给客户端文件主体内容大小；</span><br>        <span class="hljs-comment">#$http_referer：用来记录从那个页面链接访问过来的；</span><br>        <span class="hljs-comment">#$http_user_agent：记录客户浏览器的相关信息；</span><br>        <span class="hljs-comment">#通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。</span><br>        <span class="hljs-string">log_format</span> <span class="hljs-string">access</span> <span class="hljs-string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br>        <span class="hljs-string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br>        <span class="hljs-string">&#x27;&quot;$http_user_agent&quot; $http_x_forwarded_for&#x27;</span><span class="hljs-string">;</span><br>         <br>        <span class="hljs-comment">#定义本虚拟主机的访问日志</span><br>        <span class="hljs-string">access_log</span>  <span class="hljs-string">/usr/local/nginx/logs/host.access.log</span>  <span class="hljs-string">main;</span><br>        <span class="hljs-string">access_log</span>  <span class="hljs-string">/usr/local/nginx/logs/host.access.404.log</span>  <span class="hljs-string">log404;</span><br>         <br>        <span class="hljs-comment">#对 &quot;/&quot; 启用反向代理</span><br>        <span class="hljs-string">location</span> <span class="hljs-string">/</span> &#123;<br>            <span class="hljs-string">proxy_pass</span> <span class="hljs-string">http://127.0.0.1:88;</span><br>            <span class="hljs-string">proxy_redirect</span> <span class="hljs-string">off;</span><br>            <span class="hljs-string">proxy_set_header</span> <span class="hljs-string">X-Real-IP</span> <span class="hljs-string">$remote_addr;</span><br>             <br>            <span class="hljs-comment">#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br>            <span class="hljs-string">proxy_set_header</span> <span class="hljs-string">X-Forwarded-For</span> <span class="hljs-string">$proxy_add_x_forwarded_for;</span><br>             <br>            <span class="hljs-comment">#以下是一些反向代理的配置，可选。</span><br>            <span class="hljs-string">proxy_set_header</span> <span class="hljs-string">Host</span> <span class="hljs-string">$host;</span><br><br>            <span class="hljs-comment">#允许客户端请求的最大单文件字节数</span><br>            <span class="hljs-string">client_max_body_size</span> <span class="hljs-string">10m;</span><br><br>            <span class="hljs-comment">#缓冲区代理缓冲用户端请求的最大字节数，</span><br>            <span class="hljs-comment">#如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。</span><br>            <span class="hljs-comment">#无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误</span><br>            <span class="hljs-string">client_body_buffer_size</span> <span class="hljs-string">128k;</span><br><br>            <span class="hljs-comment">#表示使nginx阻止HTTP应答代码为400或者更高的应答。</span><br>            <span class="hljs-string">proxy_intercept_errors</span> <span class="hljs-string">on;</span><br><br>            <span class="hljs-comment">#后端服务器连接的超时时间_发起握手等候响应超时时间</span><br>            <span class="hljs-comment">#nginx跟后端服务器连接超时时间(代理连接超时)</span><br>            <span class="hljs-string">proxy_connect_timeout</span> <span class="hljs-number">90</span><span class="hljs-string">;</span><br><br>            <span class="hljs-comment">#后端服务器数据回传时间(代理发送超时)</span><br>            <span class="hljs-comment">#后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据</span><br>            <span class="hljs-string">proxy_send_timeout</span> <span class="hljs-number">90</span><span class="hljs-string">;</span><br><br>            <span class="hljs-comment">#连接成功后，后端服务器响应时间(代理接收超时)</span><br>            <span class="hljs-comment">#连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）</span><br>            <span class="hljs-string">proxy_read_timeout</span> <span class="hljs-number">90</span><span class="hljs-string">;</span><br><br>            <span class="hljs-comment">#设置代理服务器（nginx）保存用户头信息的缓冲区大小</span><br>            <span class="hljs-comment">#设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小</span><br>            <span class="hljs-string">proxy_buffer_size</span> <span class="hljs-string">4k;</span><br><br>            <span class="hljs-comment">#proxy_buffers缓冲区，网页平均在32k以下的设置</span><br>            <span class="hljs-comment">#设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k</span><br>            <span class="hljs-string">proxy_buffers</span> <span class="hljs-number">4</span> <span class="hljs-string">32k;</span><br><br>            <span class="hljs-comment">#高负荷下缓冲大小（proxy_buffers*2）</span><br>            <span class="hljs-string">proxy_busy_buffers_size</span> <span class="hljs-string">64k;</span><br><br>            <span class="hljs-comment">#设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长</span><br>            <span class="hljs-comment">#设定缓存文件夹大小，大于这个值，将从upstream服务器传</span><br>            <span class="hljs-string">proxy_temp_file_write_size</span> <span class="hljs-string">64k;</span><br>        &#125;<br>         <br>         <br>        <span class="hljs-comment">#设定查看Nginx状态的地址</span><br>        <span class="hljs-string">location</span> <span class="hljs-string">/NginxStatus</span> &#123;<br>            <span class="hljs-string">stub_status</span> <span class="hljs-string">on;</span><br>            <span class="hljs-string">access_log</span> <span class="hljs-string">on;</span><br>            <span class="hljs-string">auth_basic</span> <span class="hljs-string">&quot;NginxStatus&quot;</span><span class="hljs-string">;</span><br>            <span class="hljs-string">auth_basic_user_file</span> <span class="hljs-string">confpasswd;</span><br>            <span class="hljs-comment">#htpasswd文件的内容可以用apache提供的htpasswd工具来产生。</span><br>        &#125;<br>         <br>        <span class="hljs-comment">#本地动静分离反向代理配置</span><br>        <span class="hljs-comment">#所有jsp的页面均交由tomcat或resin处理</span><br>        <span class="hljs-string">location</span> <span class="hljs-string">~</span> <span class="hljs-string">.(jsp|jspx|do)?$</span> &#123;<br>            <span class="hljs-string">proxy_set_header</span> <span class="hljs-string">Host</span> <span class="hljs-string">$host;</span><br>            <span class="hljs-string">proxy_set_header</span> <span class="hljs-string">X-Real-IP</span> <span class="hljs-string">$remote_addr;</span><br>            <span class="hljs-string">proxy_set_header</span> <span class="hljs-string">X-Forwarded-For</span> <span class="hljs-string">$proxy_add_x_forwarded_for;</span><br>            <span class="hljs-string">proxy_pass</span> <span class="hljs-string">http://127.0.0.1:8080;</span><br>        &#125;<br>         <br>        <span class="hljs-comment">#所有静态文件由nginx直接读取不经过tomcat或resin</span><br>        <span class="hljs-string">location</span> <span class="hljs-string">~</span> <span class="hljs-string">.*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|</span><br>        <span class="hljs-string">pdf|xls|mp3|wma)$</span><br>        &#123;<br>            <span class="hljs-string">expires</span> <span class="hljs-string">15d;</span> <br>        &#125;<br>         <br>        <span class="hljs-string">location</span> <span class="hljs-string">~</span> <span class="hljs-string">.*.(js|css)?$</span><br>        &#123;<br>            <span class="hljs-string">expires</span> <span class="hljs-string">1h;</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">######Nginx配置文件nginx.conf#####</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2015/05/01/hello-world/"/>
    <url>/2015/05/01/hello-world/</url>
    
    <content type="html"><![CDATA[<h2 id="title-Hello-World"><a href="#title-Hello-World" class="headerlink" title="title: Hello World"></a>title: Hello World</h2><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
