

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  
    <meta name="description" content="Fake Geeker, Hoops Lover!">
  
  <meta name="author" content="Eric Shen">
  <meta name="keywords" content="">
  
  <title>thinking-in-spirng - Eric Shen Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/solarized-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"ericshen.xyz","root":"/","version":"1.8.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Eric Shen Blog" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Eric Shen Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="thinking-in-spirng">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Eric Shen
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-01-27 16:22" pubdate>
        星期三, 一月 27日 2021
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      18.3k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      243
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">thinking-in-spirng</h1>
            
            <div class="markdown-body">
              <h2 id="第一章：Spring-Framework-总览（Overview）"><a href="#第一章：Spring-Framework-总览（Overview）" class="headerlink" title="第一章：Spring Framework 总览（Overview）"></a>第一章：Spring Framework 总览（Overview）</h2><table><thead><tr><th>Spring Framework 版本</th><th>Java 标准版</th><th>Java 企业版</th></tr></thead><tbody><tr><td>1.x</td><td>1.3+</td><td>J2EE 1.3 +</td></tr><tr><td>2.x</td><td>1.4.2+</td><td>J2EE 1.3 +</td></tr><tr><td>3.x</td><td>5+</td><td>J2EE 1.4 和 Java EE 5</td></tr><tr><td>4.x</td><td>6+</td><td>Java EE 6 和 7</td></tr><tr><td>5.x</td><td>8+</td><td>Java EE 7</td></tr></tbody></table>

<h3 id="Spring-编程模型："><a href="#Spring-编程模型：" class="headerlink" title="Spring 编程模型："></a>Spring 编程模型：</h3><ul>
<li><p>面向对象编程</p>
<ul>
<li><p>契约接口：Aware、BeanPostProcessor …</p>
</li>
<li><p>设计模式：观察者模式、组合模式、模板模式 …</p>
</li>
<li><p>对象继承：Abstract* 类</p>
</li>
</ul>
</li>
<li><p>面向切面编程</p>
<ul>
<li>动态代理：JdkDynamicAopProxy</li>
<li>字节码提升：ASM、CGLib、AspectJ…</li>
</ul>
</li>
<li><p>面向元编程</p>
<ul>
<li>注解：模式注解（@Component、@Service、@Respository …）</li>
<li>配置：Environment 抽象、PropertySources、BeanDefinition …</li>
<li>泛型：GenericTypeResolver、ResolvableType …</li>
</ul>
</li>
<li><p>函数驱动</p>
<ul>
<li>函数接口：ApplicationEventPublisher</li>
<li>Reactive：Spring WebFlux</li>
</ul>
</li>
<li><p>模块驱动</p>
<ul>
<li>Maven Artifacts</li>
<li><del>OSGI Bundles</del></li>
<li>Java 9 Automatic Modules</li>
<li>Spring @Enable*</li>
</ul>
</li>
</ul>
<h2 id="第二章：重新认识-IoC"><a href="#第二章：重新认识-IoC" class="headerlink" title="第二章：重新认识 IoC"></a>第二章：重新认识 IoC</h2><h3 id="2-1-IoC-容器的职责："><a href="#2-1-IoC-容器的职责：" class="headerlink" title="2.1 IoC 容器的职责："></a>2.1 IoC 容器的职责：</h3><ul>
<li>通用职责<ul>
<li>依赖处理<ul>
<li>依赖查找</li>
<li>依赖注入</li>
</ul>
</li>
<li>生命周期管理<ul>
<li>容器    </li>
<li>托管的资源（Java Beans 或其他资源）</li>
</ul>
</li>
<li>配置<ul>
<li>容器</li>
<li>外部化配置</li>
<li>托管的资源（Java Beans 或其他资源）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-Spring-作为-IoC-容器的优势："><a href="#2-2-Spring-作为-IoC-容器的优势：" class="headerlink" title="2.2 Spring 作为 IoC 容器的优势："></a>2.2 Spring 作为 IoC 容器的优势：</h3><ul>
<li>典型的 IoC 管理，依赖查找和依赖注入</li>
<li>AOP 抽象</li>
<li>事务抽象</li>
<li>事件机制</li>
<li>SPI 扩展</li>
<li>强大的第三方整合</li>
<li>易测试性</li>
<li>更好的面向对象</li>
</ul>
<h2 id="第三章：Spring-IoC-容器概述"><a href="#第三章：Spring-IoC-容器概述" class="headerlink" title="第三章：Spring IoC 容器概述"></a>第三章：Spring IoC 容器概述</h2><h3 id="3-1-Spring-IoC-依赖查找："><a href="#3-1-Spring-IoC-依赖查找：" class="headerlink" title="3.1 Spring IoC 依赖查找："></a>3.1 Spring IoC 依赖查找：</h3><p><code>BeanFactory beanFactory = new ClassPathXmlApplicationContext(&quot;...&quot;)</code></p>
<ul>
<li>根据 Bean 名称查找<ul>
<li>实时查找 <code>(User) beanFactory.getBean(&quot;user&quot;)</code></li>
<li>延迟查找 <code>org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean</code></li>
</ul>
</li>
<li>根据 Bean 类型查找<ul>
<li>单个 Bean 对象 <code>beanFactory.getBean(User.class);</code></li>
<li>集合 Bean 对象 </li>
</ul>
</li>
<li>根据 Bean 名称 + 类型查找 <code>beanFactory.getBean(&quot;user&quot;, User.class);</code></li>
<li>根据 Java 注解查找</li>
<li>单个 Bean 对象<ul>
<li>集合 Bean 对象</li>
</ul>
</li>
</ul>
<h3 id="3-2-Spring-IoC-依赖注入："><a href="#3-2-Spring-IoC-依赖注入：" class="headerlink" title="3.2 Spring IoC 依赖注入："></a>3.2 Spring IoC 依赖注入：</h3><ul>
<li>根据 Bean 名称注入</li>
<li>根据 Bean 类型注入<ul>
<li>单个 Bean 对象</li>
<li>集合 Bean 对象</li>
</ul>
</li>
<li>注入容器內建 Bean 对象</li>
<li>注入非 Bean 对象</li>
<li>注入类型<ul>
<li>实时注入</li>
<li>延迟注入</li>
</ul>
</li>
</ul>
<p>延迟查找和延迟注入，使用到接口 <code>org.springframework.beans.factory.ObjectProvider</code> 和 <code>org.springframework.beans.factory.ObjectFactory</code> ，<code>ObjectProvider</code> 继承 <code>ObjectFactory</code></p>
<p><code>BeanFactory</code> 和 <code>ApplicationContext</code> 谁才是 Spring IoC 容器？</p>
<ul>
<li><code>BeanFactory</code> 是 Spring 底层 IoC 容器</li>
<li><code>ApplicationContext</code> 是具备应用特性的 <code>BeanFactory</code> 超集</li>
<li><code>BeanFactory</code> 是基本的 IoC 容器，<code>ApplicationContext</code> 实现 <code>BeanFactory</code> 接口，并在内部使用 <code>ConfigurableListableBeanFactory</code> 实现接口方法。</li>
</ul>
<h3 id="3-3-ApplicationContext-除了-IoC-容器角色，还有提供："><a href="#3-3-ApplicationContext-除了-IoC-容器角色，还有提供：" class="headerlink" title="3.3 ApplicationContext 除了 IoC 容器角色，还有提供："></a>3.3 ApplicationContext 除了 IoC 容器角色，还有提供：</h3><ul>
<li>面向切面（AOP）</li>
<li>配置元信息（Configuration Metadata）</li>
<li>资源管理（Resources）</li>
<li>事件（Events）</li>
<li>国际化（i18n）</li>
<li>注解（Annotations）</li>
<li>Environment 抽象（Environment Abstraction）</li>
</ul>
<h2 id="第四章：Spring-Bean-基础"><a href="#第四章：Spring-Bean-基础" class="headerlink" title="第四章：Spring Bean 基础"></a>第四章：Spring Bean 基础</h2><p>什么是 <code>BeanDefinition</code>？</p>
<ul>
<li><code>org.springframework.beans.factory.config.BeanDefinition</code></li>
<li><code>BeanDefinition</code> 是 Spring Framework 中定义 Bean 的配置元信息接口，包含：<ul>
<li>Bean 的类名</li>
<li>Bean 行为配置元素，如作用域、自动绑定的模式，生命周期回调等</li>
<li>其他 Bean 引用，又可称作合作者（collaborators）或者依赖（dependencies）</li>
<li>配置设置，比如 Bean 属性（Properties）</li>
</ul>
</li>
<li>BeanDefinition 构建<ul>
<li>通过 <code>BeanDefinitionBuilder</code></li>
<li>通过 <code>AbstractBeanDefinition</code> 以及派生类</li>
</ul>
</li>
</ul>
<p>Bean 名称生成器：<code>org.springframework.beans.factory.support.BeanNameGenerator</code></p>
<p>注册 Spring Bean：</p>
<ul>
<li>BeanDefinition 注册<ul>
<li>XML 配置元信息<ul>
<li><code>&lt;bean ... /&gt;</code></li>
</ul>
</li>
<li>Java 注解配置元信息<ul>
<li><code>@Bean</code></li>
<li><code>@Component</code></li>
<li><code>@Import</code></li>
</ul>
</li>
<li>Java API 配置元信息<ul>
<li>命名方式：<code>BeanDefinitionRegistry#registerBeanDefinition(String,BeanDefinition)</code></li>
<li>非命名方式：<code>BeanDefinitionReaderUtils#registerWithGeneratedName(AbstractBeanDefinition,Be</code><br><code>anDefinitionRegistry)</code></li>
<li>配置类方式：<code>AnnotatedBeanDefinitionReader#register(Class...)</code></li>
</ul>
</li>
</ul>
</li>
<li>外部单例对象注册<ul>
<li>Java API 配置元信息<ul>
<li><code>SingletonBeanRegistry#registerSingleton</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Bean 实例化（Instantiation）</p>
<ul>
<li>常规方式<ul>
<li>通过构造器（配置元信息：XML、Java 注解和 Java API ）</li>
<li>通过静态工厂方法（配置元信息：XML 和 Java API ）</li>
<li>通过 Bean 工厂方法（配置元信息：XML 和 Java API ）</li>
<li>通过 <code>FactoryBean</code>（配置元信息：XML、Java 注解和 Java API ）</li>
</ul>
</li>
<li>特殊方式<ul>
<li>通过 <code>ServiceLoaderFactoryBean</code>（配置元信息：XML、Java 注解和 Java API ）</li>
<li>通过 <code>AutowireCapableBeanFactory#createBean(java.lang.Class, int, boolean)</code></li>
<li>通过 <code>BeanDefinitionRegistry#registerBeanDefinition(String,BeanDefinition)</code></li>
</ul>
</li>
</ul>
<p>Bean 初始化（Initialization），同时存在时，顺序从上到下：</p>
<ul>
<li><code>@PostConstruct</code> 标注方法</li>
<li>实现 <code>InitializingBean</code> 接口的 <code>afterPropertiesSet()</code> 方法</li>
<li>自定义初始化方法（<code>BeanDefinition</code>）<ul>
<li>XML 配置：<code>&lt;bean init-method=”init” ... /&gt;</code></li>
<li>Java 注解：<code>@Bean(initMethod=”init”)</code></li>
<li>Java API：<code>AbstractBeanDefinition#setInitMethodName(String)</code></li>
</ul>
</li>
</ul>
<p>Bean 延迟初始化（Lazy Initialization）</p>
<ul>
<li>XML 配置：<code>&lt;bean lazy-init=”true” ... /&gt;</code></li>
<li>Java 注解：<code>@Lazy(true)</code></li>
</ul>
<p>Bean 销毁（Destroy），同时存在时，顺序从上到下：</p>
<ul>
<li><code>@PreDestroy</code> 标注方法</li>
<li>实现 <code>DisposableBean</code> 接口的 <code>destroy()</code> 方法</li>
<li>自定义销毁方法<ul>
<li>XML 配置：<code>&lt;bean destroy=”destroy” ... /&gt;</code></li>
<li>Java 注解：<code>@Bean(destroy=”destroy”)</code></li>
<li>Java API：<code>AbstractBeanDefinition#setDestroyMethodName(String)</code></li>
</ul>
</li>
</ul>
<h2 id="第五章：Spring-IoC-依赖查找"><a href="#第五章：Spring-IoC-依赖查找" class="headerlink" title="第五章：Spring IoC 依赖查找"></a>第五章：Spring IoC 依赖查找</h2><p>单一类型依赖查找接口 - <code>BeanFactory</code></p>
<ul>
<li>根据 Bean 名称查找<ul>
<li><code>getBean(String)</code></li>
<li>Spring 2.5 覆盖默认参数：<code>getBean(String,Object...)</code></li>
</ul>
</li>
<li>根据 Bean 类型查找<ul>
<li>Bean 实时查找<ul>
<li>Spring 3.0 ： <code>getBean(Class)</code></li>
<li>Spring 4.1 覆盖默认参数：<code>getBean(Class,Object...)</code></li>
</ul>
</li>
<li>Spring 5.1 Bean 延迟查找<ul>
<li><code>getBeanProvider(Class)</code></li>
<li><code>getBeanProvider(ResolvableType)</code></li>
</ul>
</li>
</ul>
</li>
<li>根据 Bean 名称 + 类型查找：<code>getBean(String,Class)</code></li>
</ul>
<p>集合类型依赖查找接口 - <code>ListableBeanFactory</code></p>
<ul>
<li>根据 Bean 类型查找<ul>
<li>获取同类型 Bean 名称列表<ul>
<li><code>getBeanNamesForType(Class)</code></li>
<li>Spring 4.2 <code>getBeanNamesForType(ResolvableType)</code></li>
</ul>
</li>
<li>获取同类型 Bean 实例列表<ul>
<li><code>getBeansOfType(Class)</code> 以及重载方法</li>
</ul>
</li>
</ul>
</li>
<li>通过注解类型查找<ul>
<li>Spring 3.0 获取标注类型 Bean 名称列表<ul>
<li><code>getBeanNamesForAnnotation(Class&lt;? extends Annotation&gt;)</code></li>
</ul>
</li>
<li>Spring 3.0 获取标注类型 Bean 实例列表<ul>
<li><code>getBeansWithAnnotation(Class&lt;? extends Annotation&gt;)</code></li>
</ul>
</li>
<li>Spring 3.0 获取指定名称 + 标注类型 Bean 实例<ul>
<li><code>findAnnotationOnBean(String,Class&lt;? extends Annotation&gt;)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>层次性依赖查找接口 - <code>HierarchicalBeanFactory</code></p>
<ul>
<li>双亲 BeanFactory：<code>getParentBeanFactory()</code></li>
<li>层次性查找<ul>
<li>根据 Bean 名称查找<ul>
<li>基于 <code>containsLocalBean</code> 方法实现</li>
</ul>
</li>
<li>根据 Bean 类型查找实例列表<ul>
<li>单一类型：<code>BeanFactoryUtils#beanOfType</code></li>
<li>集合类型：<code>BeanFactoryUtils#beansOfTypeIncludingAncestors</code></li>
</ul>
</li>
<li>根据 Java 注解查找名称列表<ul>
<li><code>BeanFactoryUtils#beanNamesForTypeIncludingAncestors</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Bean 延迟依赖查找接口</p>
<ul>
<li><code>org.springframework.beans.factory.ObjectFactory</code></li>
<li><code>org.springframework.beans.factory.ObjectProvider</code><ul>
<li>Spring 5 对 Java 8 特性扩展<ul>
<li>函数式接口<ul>
<li><code>getIfAvailable(Supplier)</code></li>
<li><code>ifAvailable(Consumer)</code></li>
</ul>
</li>
<li>Stream 扩展 - <code>stream()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>依赖查找安全性对比：</p>
<table><thead><tr><th>依赖查找类型</th><th>代表实现</th><th>是否安全</th></tr></thead><tbody><tr><td>单一类型查找</td><td><code>BeanFactory#getBean</code></td><td>否</td></tr><tr><td></td><td><code>ObjectFactory#getObject</code></td><td>否</td></tr><tr><td></td><td><code>ObjectProvider#getIfAvailable</code></td><td>是</td></tr><tr><td>集合类型查找</td><td><code>ListableBeanFactory#getBeansOfType</code></td><td>是</td></tr><tr><td></td><td><code>ObjectProvider#stream</code></td><td>是</td></tr></tbody></table>

<p>注意：层次性依赖查找的安全性取决于其扩展的单一或集合类型的 BeanFactory 接口</p>
<p>AbstractApplicationContext 内建可查找的依赖</p>
<table><thead><tr><th>Bean 名称</th><th>Bean 实例</th><th>使用场景</th></tr></thead><tbody><tr><td>environment</td><td>Environment 对象</td><td>外部化配置以及 Profiles</td></tr><tr><td>systemProperties</td><td>java.util.Properties 对象</td><td>Java 系统属性</td></tr><tr><td>systemEnvironment</td><td>java.util.Map 对象</td><td>操作系统环境变量</td></tr><tr><td>messageSource</td><td>MessageSource 对象</td><td>国际化文案</td></tr><tr><td>lifecycleProcessor</td><td>LifecycleProcessor 对象</td><td>Lifecycle Bean 处理器</td></tr><tr><td>applicationEventMulticaster</td><td>ApplicationEventMulticaster 对 象</td><td>Spring 事件广播器</td></tr></tbody></table>

<p>注解驱动 Spring 应用上下文内建可查找的依赖</p>
<table><thead><tr><th>Bean 名称</th><th>Bean 实例</th><th>使用场景</th></tr></thead><tbody><tr><td>org.springframework.context.annotation.internalConfigurationAnnotationProcessor</td><td>ConfigurationClassPostProcesso</td><td>处理 Spring 配置类</td></tr><tr><td>org.springframework.context.annotation.internalAutowiredAnnotationProcessor</td><td>AutowiredAnnotationBeanPostProcessor 对象</td><td>处理 @Autowired 以及 @Value 注解</td></tr><tr><td>org.springframework.context.annotation.internalCommonAnnotationProcessor</td><td>CommonAnnotationBeanPostProcessor 对象</td><td>（条件激活）处理 JSR-250 注解，如 @PostConstruct 等</td></tr><tr><td>org.springframework.context.event.internalEventListenerProcessor</td><td>EventListenerMethodProcessor 对象</td><td>处理标注 @EventListener 的 Spring 事件监听方法</td></tr><tr><td>org.springframework.context.event.internalEventListenerFactory</td><td>DefaultEventListenerFactory 对象</td><td>@EventListener 事件监听方法适配为 ApplicationListener</td></tr><tr><td>org.springframework.context.annotation.internalPersistenceAnnotationProcessor</td><td>PersistenceAnnotationBeanPostProcessor 对象</td><td>（条件激活）处理 JPA 注解场景</td></tr></tbody></table>

<p>依赖查找中的经典异常，<code>BeansException</code> 子类型</p>
<table><thead><tr><th>异常类型</th><th>触发条件（举例）</th><th>场景举例</th></tr></thead><tbody><tr><td>NoSuchBeanDefinitionException</td><td>当查找 Bean 不存在于 IoC 容器时 BeanFactory#getBean</td><td>ObjectFactory#getObject</td></tr><tr><td>NoUniqueBeanDefinitionException</td><td>类型依赖查找时，IoC 容器存在多个 Bean 实例</td><td>BeanFactory#getBean(Class)</td></tr><tr><td>BeanInstantiationException</td><td>当 Bean 所对应的类型非具体类时</td><td>BeanFactory#getBean</td></tr><tr><td>BeanCreationException</td><td>当 Bean 初始化过程中</td><td>Bean 初始化方法执行异常时</td></tr><tr><td>BeanDefinitionStoreException</td><td>当 BeanDefinition 配置元信息非法时</td><td>XML 配置资源无法打开时</td></tr></tbody></table>

<p><code>BeanFactory.getBean</code> 方法的执行是<strong>线程安全</strong>的，超过过程中会增加互斥锁</p>
<h2 id="第六章：Spring-IoC-依赖注入（Dependency-Injection）"><a href="#第六章：Spring-IoC-依赖注入（Dependency-Injection）" class="headerlink" title="第六章：Spring IoC 依赖注入（Dependency Injection）"></a>第六章：Spring IoC 依赖注入（Dependency Injection）</h2><p>依赖注入的模式和类型</p>
<ul>
<li>手动模式 - 配置或者编程的方式，提前安排注入规则<ul>
<li>XML 资源配置元信息</li>
<li>Java 注解配置元信息</li>
<li>API 配置元信息</li>
</ul>
</li>
<li>自动模式 - 实现方提供依赖自动关联的方式，按照內建的注入规则<ul>
<li>Autowiring（自动绑定）</li>
</ul>
</li>
</ul>
<p>依赖注入类型</p>
<table><thead><tr><th>依赖注入类型</th><th>配置元数据举例</th></tr></thead><tbody><tr><td>Setter 方法</td><td><code>&lt;proeprty /&gt;</code></td></tr><tr><td>构造器</td><td><code>&lt;constructor-arg /&gt;</code></td></tr><tr><td>字段</td><td><code>@Autowired User user;</code></td></tr><tr><td>方法</td><td><code>@Autowired public void user(User user) &#123; ... &#125;</code></td></tr><tr><td>接口回调</td><td><code>class MyBean implements BeanFactoryAware &#123; ... &#125;</code></td></tr></tbody></table>

<p>自动绑定（Autowiring）模式，Autowiring modes</p>
<p>参考枚举：<code>org.springframework.beans.factory.annotation.Autowire</code></p>
<table><thead><tr><th>模式</th><th>说明</th></tr></thead><tbody><tr><td>no</td><td>默认值，未激活 Autowiring，需要手动指定依赖注入对象。</td></tr><tr><td>byName</td><td>根据被注入属性的名称作为 Bean 名称进行依赖查找，并将对象设置到该属性。</td></tr><tr><td>byType</td><td>根据被注入属性的类型作为依赖类型进行查找，并将对象设置到该属性。</td></tr><tr><td>constructor</td><td>特殊 byType 类型，用于构造器参数。</td></tr></tbody></table>

<p>Java 注解配置元信息</p>
<ul>
<li><p><code>@Autowired</code></p>
</li>
<li><p><code>@Resource</code></p>
</li>
<li><p><code>@Inject</code></p>
<p>可选，需要环境中存在 JSR-330 依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.inject<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.inject<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><code>@Bean</code></p>
</li>
</ul>
<p>Aware 系列接口回调</p>
<table><thead><tr><th>內建接口</th><th>说明</th></tr></thead><tbody><tr><td>BeanFactoryAware</td><td>获取 IoC 容器 - BeanFactory</td></tr><tr><td>ApplicationContextAware</td><td>获取 Spring 应用上下文 - ApplicationContext 对象</td></tr><tr><td>EnvironmentAware</td><td>获取 Environment 对象</td></tr><tr><td>ResourceLoaderAware</td><td>获取资源加载器 对象 - ResourceLoader</td></tr><tr><td>BeanClassLoaderAware</td><td>获取加载当前 Bean Class 的 ClassLoader</td></tr><tr><td>BeanNameAware</td><td>获取当前 Bean 的名称</td></tr><tr><td>MessageSourceAware</td><td>获取 MessageSource 对象，用于 Spring 国际化</td></tr><tr><td>ApplicationEventPublisherAware</td><td>获取 ApplicationEventPublishAware 对象，用于 Spring 事件</td></tr><tr><td>EmbeddedValueResolverAware</td><td>获取 StringValueResolver 对象，用于占位符处理</td></tr></tbody></table>

<p>依赖注入类型选择</p>
<ul>
<li>低依赖：构造器注入</li>
<li>多依赖：Setter 方法注入</li>
<li>便利性：字段注入</li>
<li>声明类：方法注入</li>
</ul>
<p>各种类型注入：</p>
<ul>
<li><p>基础类型</p>
<ul>
<li>原生类型（Primitive）：boolean、byte、char、short、int、float、long、double</li>
<li>标量类型（Scalar）：Number、Character、Boolean、Enum、Locale、Charset、Currency、Properties、UUID</li>
<li>常规类型（General）：Object、String、TimeZone、Calendar、Optional 等</li>
<li>Spring 类型：Resource、InputSource、Formatter 等</li>
</ul>
</li>
<li><p>集合类型</p>
<ul>
<li>数组类型（Array）：原生类型、标量类型、常规类型、Spring 类型</li>
<li>集合类型（Collection）<ul>
<li>Collection：List、Set（SortedSet、NavigableSet、EnumSet）</li>
<li>Map：Properties</li>
</ul>
</li>
</ul>
</li>
<li><p>限定注入</p>
<ul>
<li>使用注解 @Qualifier 限定<ul>
<li>通过 Bean 名称限定</li>
<li>通过分组限定</li>
</ul>
</li>
<li>基于注解 @Qualifier 扩展限定<ul>
<li>自定义注解，如 Spring Cloud @LoadBalanced</li>
</ul>
</li>
</ul>
</li>
<li><p>延迟依赖注入</p>
</li>
<li><p>使用 API ObjectFactory 延迟注入</p>
<ul>
<li>单一类型</li>
<li>集合类型</li>
</ul>
</li>
<li><p>使用 API ObjectProvider 延迟注入（推荐）</p>
<ul>
<li>单一类型</li>
<li>集合类型</li>
</ul>
</li>
</ul>
<p>依赖处理过程</p>
<ul>
<li>入口 - <code>DefaultListableBeanFactory#resolveDependency</code></li>
<li>依赖描述符 - DependencyDescriptor</li>
<li>自定绑定候选对象处理器 - AutowireCandidateResolver</li>
</ul>
<p>@Autowired、@Inject 注入，参考 <code>AutowiredAnnotationBeanPostProcessor</code></p>
<p>Java 通用注解注入原理：</p>
<ul>
<li><code>CommonAnnotationBeanPostProcessor</code></li>
<li>注入注解<ul>
<li>javax.xml.ws.WebServiceRef</li>
<li>javax.ejb.EJB</li>
<li>javax.annotation.Resource</li>
</ul>
</li>
<li>生命周期注解<ul>
<li>javax.annotation.PostConstruct</li>
<li>javax.annotation.PreDestroy</li>
</ul>
</li>
</ul>
<p>自定义依赖注入注解</p>
<ul>
<li><p>基于 <code>AutowiredAnnotationBeanPostProcessor</code> 实现</p>
</li>
<li><p>自定义实现</p>
<ul>
<li>生命周期处理<ul>
<li>InstantiationAwareBeanPostProcessor</li>
<li>MergedBeanDefinitionPostProcessor</li>
</ul>
</li>
<li>元数据<ul>
<li>InjectedElement</li>
<li>InjectionMetadata</li>
</ul>
</li>
</ul>
</li>
<li><p><code>org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor</code></p>
<ul>
<li><code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor</code><ul>
<li><code>@Autowired</code></li>
<li><code>@Value</code></li>
<li><code>@Inject</code></li>
</ul>
</li>
<li><code>org.springframework.context.annotation.CommonAnnotationBeanPostProcessor</code><ul>
<li><code>@PostConstruct</code></li>
<li><code>@PreDestroy</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>初始化 Bean 时，<code>AutowiredAnnotationBeanPostProcessor</code> 先解析 Bean 中的依赖（<code>@Autowire</code>，<code>@Value</code>），然后 <code>CommonAnnotationBeanPostProcessor</code> 调用初始化方法 <code>@@PostConstruct</code></p>
<p>将 <code>@Bean</code> 方法设置为 <code>static</code> ，可以让 Bean 提前初始化。</p>
<ul>
<li><p>依赖查找：<code>ApplicationContext#getBean</code></p>
</li>
<li><p>依赖处理过程：<code>org.springframework.beans.factory.support.DefaultListableBeanFactory#resolveDependency</code></p>
</li>
</ul>
<h2 id="第七章：Spring-IoC-依赖来源（Dependency-Sources）"><a href="#第七章：Spring-IoC-依赖来源（Dependency-Sources）" class="headerlink" title="第七章：Spring IoC 依赖来源（Dependency Sources）"></a>第七章：Spring IoC 依赖来源（Dependency Sources）</h2><h3 id="Spring-IoC-依赖来源"><a href="#Spring-IoC-依赖来源" class="headerlink" title="Spring IoC 依赖来源"></a>Spring IoC 依赖来源</h3><table><thead><tr><th>来源</th><th>配置元数据</th><th>注册 API</th><th>Spring Bean 对象</th><th>生命周期管理</th><th>配置元信息</th><th>使用场景</th></tr></thead><tbody><tr><td>Spring BeanDefinition</td><td><code>&lt;bean&gt;</code><br><code>@Bean public User user()&#123;...&#125;</code><br>BeanDefinitionBuilder</td><td>BeanDefinitionRegistry#registerBeanDefinition</td><td>是</td><td>是</td><td>有</td><td>依赖查找、依赖注入</td></tr><tr><td>单例对象</td><td>API 实现</td><td>SingletonBeanRegistry#registerSingleton</td><td>是</td><td>否</td><td>无</td><td>依赖查找、依赖注入</td></tr><tr><td>非 Spring 容器管理对象</td><td>Resolvable Dependency</td><td>ConfigurableListableBeanFactory#registerResolvableDependency</td><td>否</td><td>否</td><td>无</td><td>依赖注入</td></tr><tr><td>外部化配置</td><td>@Value</td><td>Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);</td><td>否</td><td>否</td><td>无</td><td>依赖注入</td></tr></tbody></table>

<p>依赖注入比依赖查找多一个来源，Resolvable Dependency。也就是说，可以通过注入的方式获取这类对象，但不能通过 <code>BeanFactory#getBean</code> 方法从容器中获取。</p>
<h3 id="Spring-內建-BeanDefintion"><a href="#Spring-內建-BeanDefintion" class="headerlink" title="Spring 內建 BeanDefintion"></a>Spring 內建 BeanDefintion</h3><p>在使用 <code>AnnotationConfigApplicationContext</code> 或者在 XML 配置中配置了注解驱动 <code>&lt;context:annotation-config/&gt;</code> ，或组件扫描 <code>&lt;context:component-scan base-package=&quot;org.acme&quot; /&gt;</code> ，会触发<code>org.springframework.context.annotation.AnnotationConfigUtils#registerAnnotationConfigProcessors</code> 注入一些 Spring 内建的 Bean：</p>
<ul>
<li><p><code>org.springframework.context.annotation.ConfigurationClassPostProcessor</code></p>
</li>
<li><p><code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor</code></p>
</li>
<li><p><code>org.springframework.context.annotation.CommonAnnotationBeanPostProcessor</code></p>
</li>
<li><p><code>org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor</code></p>
<p>需要环境中有 JPA 依赖</p>
</li>
<li><p><code>org.springframework.context.event.EventListenerMethodProcessor</code></p>
</li>
<li><p><code>org.springframework.context.event.DefaultEventListenerFactory</code></p>
</li>
</ul>
<h3 id="Spring-內建单例对象"><a href="#Spring-內建单例对象" class="headerlink" title="Spring 內建单例对象"></a>Spring 內建单例对象</h3><p>Spring 启动时，<code>refresh()</code> 方法会调用 <code>org.springframework.context.support.AbstractApplicationContext#prepareBeanFactory</code> ，会注入一些单例对象，名称为：</p>
<ul>
<li><code>environment</code></li>
<li><code>systemProperties</code></li>
<li><code>systemEnvironment</code></li>
</ul>
<p>单例对象由 <code>org.springframework.beans.factory.config.SingletonBeanRegistry</code> 注册，<code>org.springframework.beans.factory.support.AbstractBeanFactory</code> 实现了这个接口，从容器中获取 Bean 的方法 <code>org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</code> 中，会先从单例对象中查找，如果查找到，直接返回；查找不到，则从 Spring BeanDefinition 中获取，并<strong>执行生命周期函数</strong></p>
<h3 id="Resolvable-Dependency-非-Spring-容器管理对象-可解析依赖"><a href="#Resolvable-Dependency-非-Spring-容器管理对象-可解析依赖" class="headerlink" title="Resolvable Dependency / 非 Spring 容器管理对象 / 可解析依赖"></a>Resolvable Dependency / 非 Spring 容器管理对象 / 可解析依赖</h3><p><code>org.springframework.context.support.AbstractApplicationContext#prepareBeanFactory</code></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// BeanFactory interface not registered as resolvable type in a plain factory.</span><br><span class="hljs-comment">// MessageSource registered (and found for autowiring) as a bean.</span><br>beanFactory.register<span class="hljs-constructor">ResolvableDependency(BeanFactory.<span class="hljs-params">class</span>, <span class="hljs-params">beanFactory</span>)</span>;<br>beanFactory.register<span class="hljs-constructor">ResolvableDependency(ResourceLoader.<span class="hljs-params">class</span>, <span class="hljs-params">this</span>)</span>;<br>beanFactory.register<span class="hljs-constructor">ResolvableDependency(ApplicationEventPublisher.<span class="hljs-params">class</span>, <span class="hljs-params">this</span>)</span>;<br>beanFactory.register<span class="hljs-constructor">ResolvableDependency(ApplicationContext.<span class="hljs-params">class</span>, <span class="hljs-params">this</span>)</span>;<br></code></pre></td></tr></table></figure>

<p>后三个实际上都是同一个 <code>ApplicationContext</code></p>
<p><strong>order 值越大，优先级越小</strong></p>
<h2 id="第八章：Spring-Bean-作用域"><a href="#第八章：Spring-Bean-作用域" class="headerlink" title="第八章：Spring Bean 作用域"></a>第八章：Spring Bean 作用域</h2><table><thead><tr><th>作用域</th><th>说明</th></tr></thead><tbody><tr><td><strong>singleton</strong></td><td>默认 Spring Bean 作用域，一个 BeanFactory 有且仅有一个实例</td></tr><tr><td><strong>prototype</strong></td><td>原型作用域，每次依赖查找和依赖注入生成新 Bean 对象</td></tr><tr><td>request</td><td>将 Spring Bean 存储在 ServletRequest 上下文中</td></tr><tr><td>session</td><td>将 Spring Bean 存储在 HttpSession 中</td></tr><tr><td>application</td><td>将 Spring Bean 存储在 ServletContext 中</td></tr></tbody></table>

<p><strong>注意事项</strong>：</p>
<ul>
<li>Spring 容器没有办法管理 prototype Bean 的完整生命周期，也没有办法记录示例的存<br>在。销毁回调方法将不会执行，可以利用 BeanPostProcessor 进行清扫工作。</li>
<li><strong>无论是 Singleton 还是 Prototype Bean 均会执行初始化方法回调，不过仅 Singleton Bean 会执行销毁方法回调</strong></li>
</ul>
<p><code>@Scope</code> 注解定义原型 Bean ：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Bean</span><br><span class="hljs-variable">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)<br>public static User prototypeUser() &#123;<br>	<span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">createUser</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="“request”-Bean-作用域"><a href="#“request”-Bean-作用域" class="headerlink" title="“request” Bean 作用域"></a>“request” Bean 作用域</h3><ul>
<li>XML - <code>&lt;bean class= &quot;...&quot; scope = &quot;request&quot; /&gt;</code></li>
<li>Java 注解 - <code>@RequestScope</code> 或 <code>@Scope(WebApplicationContext.SCOPE_REQUEST)</code></li>
</ul>
<p>每次使用的 CGLIB 代理对象是同一个，但是被代理的对象每次都会重新生成。</p>
<p>使用 IDEA 进行远程调试：</p>
<ul>
<li>在 Edit Configurations 中新增一个 Remote ，使用命令启动 jar 时，在启动命令中增加 Remote 里的内容，启动 jar 以及 Remote，打断点进行调试。</li>
</ul>
<p>实现 API</p>
<ul>
<li><code>@RequestScope</code></li>
<li><code>RequestScope</code></li>
</ul>
<h3 id="“session”-Bean-作用域"><a href="#“session”-Bean-作用域" class="headerlink" title="“session” Bean 作用域"></a>“session” Bean 作用域</h3><p>配置</p>
<ul>
<li>XML - <code>&lt;bean class= &quot;...&quot; scope = &quot;session&quot; /&gt;</code></li>
<li>Java 注解 - <code>@RequestScope</code> 或 <code>@Scope(WebApplicationContext.SCOPE_REQUEST)</code></li>
</ul>
<p>实现 API</p>
<ul>
<li><code>@SessionScope</code></li>
<li><code>SessionScope</code></li>
</ul>
<h3 id="“application”-Bean-作用域"><a href="#“application”-Bean-作用域" class="headerlink" title="“application” Bean 作用域"></a>“application” Bean 作用域</h3><p>配置</p>
<ul>
<li>XML - <code>&lt;bean class= &quot;...&quot; scope = &quot;application&quot; /&gt;</code></li>
<li>Java 注解 - <code>@ApplicationScope</code> 或 <code>@Scope(WebApplicationContext.SCOPE_APPLICATION)</code></li>
</ul>
<p>实现 API</p>
<ul>
<li><code>@ApplicationScope</code></li>
<li><code>ServletContextScope</code></li>
</ul>
<p>实现方式与 request 和 session 不同，这里直接将 Bean 放入 <code>ServletContext</code> 中</p>
<h3 id="自定义-Bean-作用域"><a href="#自定义-Bean-作用域" class="headerlink" title="自定义 Bean 作用域"></a>自定义 Bean 作用域</h3><p>实现 Scope</p>
<ul>
<li><code>org.springframework.beans.factory.config.Scope</code></li>
</ul>
<p>注册 Scope</p>
<ul>
<li><p>API</p>
<p><code>org.springframework.beans.factory.config.ConfigurableBeanFactory#registerScope</code></p>
</li>
<li><p>配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.beans.factory.config.CustomScopeConfigurer&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;...&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">entry</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="第九章：Spring-Bean-生命周期（Bean-Lifecycle）"><a href="#第九章：Spring-Bean-生命周期（Bean-Lifecycle）" class="headerlink" title="第九章：Spring Bean 生命周期（Bean Lifecycle）"></a>第九章：Spring Bean 生命周期（Bean Lifecycle）</h2><h3 id="Spring-Bean-元信息配置阶段"><a href="#Spring-Bean-元信息配置阶段" class="headerlink" title="Spring Bean 元信息配置阶段"></a>Spring Bean 元信息配置阶段</h3><p>BeanDefinition 配置</p>
<ul>
<li>面向资源<ul>
<li>XML 配置</li>
<li>Properties 资源配置</li>
</ul>
</li>
<li>面向注解</li>
<li>面向 API</li>
</ul>
<h3 id="Spring-Bean-元信息解析阶段"><a href="#Spring-Bean-元信息解析阶段" class="headerlink" title="Spring Bean 元信息解析阶段"></a>Spring Bean 元信息解析阶段</h3><p>BeanDefinition 解析</p>
<ul>
<li>面向资源 BeanDefinition 解析 - <code>BeanDefinitionReader</code><ul>
<li>XML 解析器 - <code>XmlBeanDefinitionReader</code></li>
<li>Properties 解析器 - <code>PropertiesBeanDefinitionReader</code></li>
</ul>
</li>
<li>面向注解 BeanDefinition 解析 - <code>AnnotatedBeanDefinitionReader</code></li>
</ul>
<h3 id="Spring-Bean-注册阶段"><a href="#Spring-Bean-注册阶段" class="headerlink" title="Spring Bean 注册阶段"></a>Spring Bean 注册阶段</h3><p>BeanDefinition 注册接口</p>
<p><code>BeanDefinitionRegistry</code></p>
<h3 id="Spring-BeanDefinition-合并阶段"><a href="#Spring-BeanDefinition-合并阶段" class="headerlink" title="Spring BeanDefinition 合并阶段"></a>Spring BeanDefinition 合并阶段</h3><p>BeanDefinition 合并</p>
<p>父子 BeanDefinition 合并</p>
<ul>
<li>当前 BeanFactory 查找</li>
<li>层次性 BeanFactory 查找</li>
</ul>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;org.geekbang.thinking.in.spring.ioc.overview.domain.User&quot;</span>&gt;<br>    &lt;<span class="hljs-keyword">property</span> /&gt;<br>    ...<br>&lt;/bean&gt;<br><br>&lt;bean <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;superUser&quot;</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">&quot;org.geekbang.thinking.in.spring.ioc.overview.domain.SuperUser&quot;</span> parent=<span class="hljs-string">&quot;user&quot;</span><br>      primary=<span class="hljs-string">&quot;true&quot;</span>&gt;<br>    &lt;<span class="hljs-keyword">property</span> /&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure>

<p><code>XmlBeanDefinitionReader#loadBeanDefinitions</code> 加载 XML 文件时，赋值 <code>DefaultListableBeanFactory#beanDefinitionMap</code>，这个 Map 中的 <code>BeanDefinition</code> 还没有合并，也就是说 superUser 的属性值还没有从 user 中继承过来。</p>
<p><code>AbstractBeanFactory#getBean</code> 获取 bean 时，执行 <code>AbstractBeanFactory#getMergedBeanDefinition</code> ，对 superUser 进行合并，放入 <code>AbstractBeanFactory#mergedBeanDefinitions</code> 中。</p>
<h3 id="Spring-Bean-Class-加载阶段"><a href="#Spring-Bean-Class-加载阶段" class="headerlink" title="Spring Bean Class 加载阶段"></a>Spring Bean Class 加载阶段</h3><ul>
<li>ClassLoader 类加载</li>
<li>Java Security 安全控制</li>
<li>ConfigurableBeanFactory 临时 ClassLoader</li>
</ul>
<p><code>AbstractBeanDefinition#beanClass</code> 被定义为 Object ，有两种形式，一种是 全类名 的 String，另一种是 Class 对象</p>
<p>Java Security 安全控制 相关</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>get<span class="hljs-constructor">SecurityManager()</span> != null) &#123;<br>	return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AccessController</span>.</span></span><span class="hljs-keyword">do</span><span class="hljs-constructor">Privileged((PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;)</span> <span class="hljs-literal">()</span> -&gt;<br><span class="hljs-keyword">do</span><span class="hljs-constructor">ResolveBeanClass(<span class="hljs-params">mbd</span>, <span class="hljs-params">typesToMatch</span>)</span>, get<span class="hljs-constructor">AccessControlContext()</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>临时 ClassLoader 与 load-time weaving 技术有关，用于进行类型检查时（即尚未创建实际实例）</p>
<h3 id="Spring-Bean-实例化阶段"><a href="#Spring-Bean-实例化阶段" class="headerlink" title="Spring Bean 实例化阶段"></a>Spring Bean 实例化阶段</h3><ul>
<li><p>传统实例化方式</p>
<ul>
<li>实例化策略 - InstantiationStrategy</li>
</ul>
</li>
<li><p>构造器依赖注入</p>
<p><strong>实例化阶段，如果使用构造器注入，将解析构造器注入的依赖</strong></p>
</li>
</ul>
<p><code>AbstractAutowireCapableBeanFactory#createBeanInstance</code></p>
<h4 id="Spring-Bean-实例化前阶段"><a href="#Spring-Bean-实例化前阶段" class="headerlink" title="Spring Bean 实例化前阶段"></a>Spring Bean 实例化前阶段</h4><ul>
<li>非主流生命周期 - Bean 实例化前阶段<ul>
<li><code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</code></li>
</ul>
</li>
</ul>
<p>返回非 null 时，阻止 bean 的默认实例化过程及以下生命周期</p>
<p>唯一可以进一步生命周期处理的是 <code>BeanPostProcessor#postProcessAfterInitialization</code></p>
<h4 id="Spring-Bean-实例化后阶段"><a href="#Spring-Bean-实例化后阶段" class="headerlink" title="Spring Bean 实例化后阶段"></a>Spring Bean 实例化后阶段</h4><ul>
<li>Bean 属性赋值（Populate）判断<ul>
<li><code>InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation</code></li>
</ul>
</li>
</ul>
<p>在给 bean 实例做属性赋值的方法 <code>AbstractAutowireCapableBeanFactory#populateBean</code> 的最开始调用，如果返回 false ，阻止 bean 的属性赋值及以下生命周期</p>
<h3 id="Spring-Bean-属性赋值前阶段"><a href="#Spring-Bean-属性赋值前阶段" class="headerlink" title="Spring Bean 属性赋值前阶段"></a>Spring Bean 属性赋值前阶段</h3><ul>
<li><p>Bean 属性值元信息</p>
<ul>
<li>PropertyValues</li>
</ul>
</li>
<li><p>Bean 属性赋值前回调</p>
<ul>
<li><p>Spring 1.2 - 5.0：<code>InstantiationAwareBeanPostProcessor#postProcessPropertyValues</code></p>
<p>此方法已过期，使用 <code>postProcessProperties</code> 替代，为了兼容，只有在 <code>postProcessProperties</code> 返回 null 时（默认实现），才会调用此方法</p>
</li>
<li><p>Spring 5.1：<code>InstantiationAwareBeanPostProcessor#postProcessProperties</code></p>
</li>
</ul>
</li>
</ul>
<p>在工厂将给定属性值应用于给定 bean 之前，对它们进行处理。</p>
<p>在依赖注入（ <code>byName</code> 或 <code>byType</code> ）之后，在将配置的属性赋值给 bean 实例 <code>AbstractAutowireCapableBeanFactory#applyPropertyValues</code> 之前执行此阶段方法</p>
<h3 id="Spring-Bean-初始化阶段"><a href="#Spring-Bean-初始化阶段" class="headerlink" title="Spring Bean 初始化阶段"></a>Spring Bean 初始化阶段</h3><p><code>AbstractAutowireCapableBeanFactory#initializeBean</code></p>
<h4 id="Spring-Bean-Aware-接口回调阶段"><a href="#Spring-Bean-Aware-接口回调阶段" class="headerlink" title="Spring Bean Aware 接口回调阶段"></a>Spring Bean Aware 接口回调阶段</h4><p>Spring Aware 接口，执行顺序从上到下</p>
<ul>
<li><code>BeanNameAware</code></li>
<li><code>BeanClassLoaderAware</code></li>
<li><code>BeanFactoryAware</code></li>
</ul>
<p>依赖于 <code>ApplicationContext</code> ：</p>
<ul>
<li><code>EnvironmentAware</code></li>
<li><code>EmbeddedValueResolverAware</code></li>
<li><code>ResourceLoaderAware</code></li>
<li><code>ApplicationEventPublisherAware</code></li>
<li><code>MessageSourceAware</code></li>
<li><code>ApplicationContextAware</code></li>
</ul>
<p>在初始化 Bean 实例 <code>AbstractAutowireCapableBeanFactory#initializeBean</code> 的最开始执行此阶段，前三个接口直接调用，而依赖于 ApplicationContext 的几个 Aware 接口，在 ApplicationContext 的生命周期中，会在 beanFactory 中加入 <code>ApplicationContextAwareProcessor</code> ，在其 <code>postProcessBeforeInitialization</code> 方法中执行调用</p>
<p><code>ApplicationContextAwareProcessor</code> 是包权限的</p>
<h4 id="Spring-Bean-初始化前阶段"><a href="#Spring-Bean-初始化前阶段" class="headerlink" title="Spring Bean 初始化前阶段"></a>Spring Bean 初始化前阶段</h4><p>已完成</p>
<ul>
<li><p>Bean 实例化</p>
</li>
<li><p>Bean 属性赋值</p>
</li>
<li><p>Bean Aware 接口回调</p>
</li>
</ul>
<p>方法回调</p>
<ul>
<li><code>BeanPostProcessor#postProcessBeforeInitialization</code></li>
</ul>
<h4 id="Spring-Bean-初始化阶段-1"><a href="#Spring-Bean-初始化阶段-1" class="headerlink" title="Spring Bean 初始化阶段"></a>Spring Bean 初始化阶段</h4><p>Bean 初始化（Initialization）</p>
<ul>
<li><code>@PostConstruct</code> 标注方法</li>
<li>实现 <code>InitializingBean</code> 接口的 <code>afterPropertiesSet()</code> 方法</li>
<li>自定义初始化方法</li>
</ul>
<p>对 <code>@PostConstruct</code> 的处理需要依赖于注解驱动，<code>CommonAnnotationBeanPostProcessor#postProcessBeforeInitialization</code></p>
<h4 id="Spring-Bean-初始化后阶段"><a href="#Spring-Bean-初始化后阶段" class="headerlink" title="Spring Bean 初始化后阶段"></a>Spring Bean 初始化后阶段</h4><p>方法回调</p>
<ul>
<li><code>BeanPostProcessor#postProcessAfterInitialization</code></li>
</ul>
<h4 id="Spring-Bean-初始化完成阶段"><a href="#Spring-Bean-初始化完成阶段" class="headerlink" title="Spring Bean 初始化完成阶段"></a>Spring Bean 初始化完成阶段</h4><p>方法回调</p>
<ul>
<li>Spring 4.1 +：<code>SmartInitializingSingleton#afterSingletonsInstantiated</code></li>
</ul>
<p><code>SmartInitializingSingleton</code> 通常在 Spring ApplicationContext 场景使用</p>
<p>使用 <code>BeanFactory</code> 时，需要显式的调用此方法；在 <code>ApplicationContext</code> 启动时，调用了此方法 <code>AbstractApplicationContext#finishBeanFactoryInitialization</code> ，这个方法做了两件事情：</p>
<ol>
<li>将已注册的 <code>BeanDefinition</code> 初始化成 Spring Bean</li>
<li>调用所有 <code>SmartInitializingSingleton#afterSingletonsInstantiated</code></li>
</ol>
<h3 id="Spring-Bean-销毁前阶段"><a href="#Spring-Bean-销毁前阶段" class="headerlink" title="Spring Bean 销毁前阶段"></a>Spring Bean 销毁前阶段</h3><ul>
<li>方法回调<ul>
<li><code>DestructionAwareBeanPostProcessor#postProcessBeforeDestruction</code></li>
</ul>
</li>
</ul>
<p>执行 <code>ConfigurableBeanFactory#destroyBean</code> 时，触发 Bean 前销毁阶段</p>
<p>对 <code>@PreDestroy</code> 的处理需要依赖于注解驱动，<code>CommonAnnotationBeanPostProcessor#postProcessBeforeDestruction</code></p>
<h3 id="Spring-Bean-销毁阶段"><a href="#Spring-Bean-销毁阶段" class="headerlink" title="Spring Bean 销毁阶段"></a>Spring Bean 销毁阶段</h3><p>Bean 销毁（Destroy）</p>
<ul>
<li><code>@PreDestroy</code> 标注方法</li>
<li>实现 <code>DisposableBean</code> 接口的 <code>destroy()</code> 方法</li>
<li>自定义销毁方法</li>
</ul>
<p>对 <code>@PreDestroy</code> 的处理需要依赖于注解驱动，<code>CommonAnnotationBeanPostProcessor#postProcessBeforeDestruction</code></p>
<p><code>CommonAnnotationBeanPostProcessor</code> 是 <code>DestructionAwareBeanPostProcessor</code> 的实现类之一</p>
<p>如果其他 <code>DestructionAwareBeanPostProcessor</code> 排序在 <code>CommonAnnotationBeanPostProcessor</code> 后，会先执行 <code>@PreDestroy</code> 标注方法，后执行其他 <code>DestructionAwareBeanPostProcessor</code> 销毁前阶段方法</p>
<h3 id="Spring-Bean-垃圾收集"><a href="#Spring-Bean-垃圾收集" class="headerlink" title="Spring Bean 垃圾收集"></a>Spring Bean 垃圾收集</h3><p>Bean 垃圾回收（GC）</p>
<ul>
<li>关闭 Spring 容器（应用上下文）</li>
<li>执行 GC</li>
<li>Spring Bean 覆盖的 <code>finalize()</code> 方法被回调</li>
</ul>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="BeanPostProcessor-的使用场景有哪些？"><a href="#BeanPostProcessor-的使用场景有哪些？" class="headerlink" title="BeanPostProcessor 的使用场景有哪些？"></a>BeanPostProcessor 的使用场景有哪些？</h3><p>答：<code>BeanPostProcessor</code> 提供 Spring Bean 初始化前和初始化后的生命周期回调，分别对应 <code>postProcessBeforeInitialization</code> 以及 <code>postProcessAfterInitialization</code> 方法，允许对关心的 Bean 进行扩展，甚至是替换。</p>
<p>加分项：其中，<code>ApplicationContext</code> 相关的 <code>Aware</code> 回调也是基于 <code>BeanPostProcessor</code> 实现，即 <code>ApplicationContextAwareProcessor</code> 。</p>
<h3 id="BeanFactoryPostProcessor-与-BeanPostProcessor-的区别"><a href="#BeanFactoryPostProcessor-与-BeanPostProcessor-的区别" class="headerlink" title="BeanFactoryPostProcessor 与 BeanPostProcessor 的区别"></a>BeanFactoryPostProcessor 与 BeanPostProcessor 的区别</h3><p>答：<code>BeanFactoryPostProcessor</code> 是 Spring <code>BeanFactory</code>（实际为 <code>ConfigurableListableBeanFactory</code>） 的后置处理器，用于扩展 <code>BeanFactory</code>，或通过 <code>BeanFactory</code> 进行依赖查找和依赖注入。</p>
<p>加分项：<code>BeanFactoryPostProcessor</code> 必须有 Spring <code>ApplicationContext</code> 执行，<code>BeanFactory</code> 无法与其直接交互。而 <code>BeanPostProcessor</code> 则直接与 <code>BeanFactory</code> 关联，属于 N 对 1 的关系。</p>
<h3 id="BeanFactory-是怎样处理-Bean-生命周期？"><a href="#BeanFactory-是怎样处理-Bean-生命周期？" class="headerlink" title="BeanFactory 是怎样处理 Bean 生命周期？"></a>BeanFactory 是怎样处理 Bean 生命周期？</h3><p><code>BeanFactory</code> 的默认实现为 <code>DefaultListableBeanFactory</code>，其中 Bean 生命周期与方法映射如下：</p>
<ul>
<li>BeanDefinition 注册阶段 - <code>registerBeanDefinition</code></li>
<li>BeanDefinition 合并阶段 - <code>getMergedBeanDefinition</code></li>
<li>Bean 实例化前阶段 - <code>resolveBeforeInstantiation</code></li>
<li>Bean 实例化阶段 - <code>createBeanInstance</code></li>
<li>Bean 实例化后阶段 - <code>populateBean</code></li>
<li>Bean 属性赋值前阶段 - <code>populateBean</code></li>
<li>Bean 属性赋值阶段 - <code>populateBean</code></li>
<li>Bean Aware 接口回调阶段 - <code>initializeBean</code></li>
<li>Bean 初始化前阶段 - <code>initializeBean</code></li>
<li>Bean 初始化阶段 - <code>initializeBean</code></li>
<li>Bean 初始化后阶段 - <code>initializeBean</code></li>
<li>Bean 初始化完成阶段 - <code>preInstantiateSingletons</code></li>
<li>Bean 销毁前阶段 - <code>destroyBean</code></li>
<li>Bean 销毁阶段 - <code>destroyBean</code></li>
</ul>
<h2 id="第十章：Spring-配置元信息（Configuration-Metadata）"><a href="#第十章：Spring-配置元信息（Configuration-Metadata）" class="headerlink" title="第十章：Spring 配置元信息（Configuration Metadata）"></a>第十章：Spring 配置元信息（Configuration Metadata）</h2><h3 id="Spring-配置元信息"><a href="#Spring-配置元信息" class="headerlink" title="Spring 配置元信息"></a>Spring 配置元信息</h3><ul>
<li>Spring Bean 配置元信息 - <code>BeanDefinition</code></li>
<li>Spring Bean 属性元信息 - <code>PropertyValues</code></li>
<li>Spring 容器配置元信息</li>
<li>Spring 外部化配置元信息 - <code>PropertySource</code></li>
<li>Spring Profile 元信息 - <code>@Profile</code></li>
</ul>
<h3 id="Spring-Bean-配置元信息"><a href="#Spring-Bean-配置元信息" class="headerlink" title="Spring Bean 配置元信息"></a>Spring Bean 配置元信息</h3><p>Bean 配置元信息 - <code>BeanDefinition</code></p>
<ul>
<li><code>GenericBeanDefinition</code>：通用型 <code>BeanDefinition</code></li>
<li><code>RootBeanDefinition</code>：无 Parent 的 <code>BeanDefinition</code> 或者合并后 <code>BeanDefinition</code></li>
<li><code>AnnotatedBeanDefinition</code>：注解标注的 <code>BeanDefinition</code></li>
</ul>
<h3 id="Spring-Bean-属性元信息"><a href="#Spring-Bean-属性元信息" class="headerlink" title="Spring Bean 属性元信息"></a>Spring Bean 属性元信息</h3><ul>
<li>Bean 属性元信息 - <code>PropertyValues</code><ul>
<li>可修改实现 - <code>MutablePropertyValues</code></li>
<li>元素成员 - <code>PropertyValue</code></li>
</ul>
</li>
<li>Bean 属性上下文存储 - <code>AttributeAccessor</code></li>
<li>Bean 元信息元素 - <code>BeanMetadataElement</code></li>
</ul>
<p><code>AttributeAccessorSupport#attributes</code> 是附加属性（不影响 Bean populate、initialize）</p>
<p><code>BeanMetadataAttributeAccessor#source</code> 存储当前 BeanDefinition 来自于何方（辅助作用）</p>
<h3 id="Spring-容器配置元信息"><a href="#Spring-容器配置元信息" class="headerlink" title="Spring 容器配置元信息"></a>Spring 容器配置元信息</h3><h4 id="Spring-XML-配置元信息-beans-元素相关"><a href="#Spring-XML-配置元信息-beans-元素相关" class="headerlink" title="Spring XML 配置元信息 - beans 元素相关"></a>Spring XML 配置元信息 - beans 元素相关</h4><table><thead><tr><th>beans 元素属性</th><th>默认值</th><th>使用场景</th></tr></thead><tbody><tr><td>profile</td><td>null（留空）</td><td>Spring Profiles 配置值</td></tr><tr><td>default-lazy-init</td><td>default</td><td>当 outter beans “default-lazy-init” 属性存在时，继承该值，否则为 “false”</td></tr><tr><td>default-merge</td><td>default</td><td>当 outter beans “default-merge” 属性存在时，继承该值，否则为 “false”</td></tr><tr><td>default-autowire</td><td>default</td><td>当 outter beans “default-autowire” 属性存在时，继承该值，否则为 “no”</td></tr><tr><td>default-autowire-candidates</td><td>null（留空）</td><td>默认 Spring Beans 名称 pattern</td></tr><tr><td>default-init-method</td><td>null（留空）</td><td>默认 Spring Beans 自定义初始化方法</td></tr><tr><td>default-destroy-method</td><td>null（留空）</td><td>默认 Spring Beans 自定义销毁方法</td></tr></tbody></table>

<h4 id="Spring-XML-配置元信息-应用上下文相关"><a href="#Spring-XML-配置元信息-应用上下文相关" class="headerlink" title="Spring XML 配置元信息 - 应用上下文相关"></a>Spring XML 配置元信息 - 应用上下文相关</h4><table><thead><tr><th>XML 元素</th><th>使用场景</th></tr></thead><tbody><tr><td>&lt;context:annotation-config /&gt;</td><td>激活 Spring 注解驱动</td></tr><tr><td>&lt;context:component-scan /&gt;</td><td>Spring @Component 以及自定义注解扫描</td></tr><tr><td>&lt;context:load-time-weaver /&gt;</td><td>激活 Spring LoadTimeWeaver</td></tr><tr><td>&lt;context:mbean-export /&gt;</td><td>暴露 Spring Beans 作为 JMX Beans</td></tr><tr><td>&lt;context:mbean-server /&gt;</td><td>将当前平台作为 MBeanServer</td></tr><tr><td>&lt;context:property-placeholder /&gt;</td><td>加载外部化配置资源作为 Spring 属性配置</td></tr><tr><td>&lt;context:property-override /&gt;</td><td>利用外部化配置资源覆盖 Spring 属性值</td></tr></tbody></table>

<p><code>org.springframework.beans.factory.xml.BeanDefinitionParserDelegate</code></p>
<p><code>populateDefaults</code></p>
<h3 id="基于-XML-资源装载-Spring-Bean-配置元信息"><a href="#基于-XML-资源装载-Spring-Bean-配置元信息" class="headerlink" title="基于 XML 资源装载 Spring Bean 配置元信息"></a>基于 XML 资源装载 Spring Bean 配置元信息</h3><table><thead><tr><th>XML 元素</th><th>使用场景</th></tr></thead><tbody><tr><td>&lt;beans:beans /&gt;</td><td>单 XML 资源下的多个 Spring Beans 配置</td></tr><tr><td>&lt;beans:bean /&gt;</td><td>单个 Spring Bean 定义（BeanDefinition）配置</td></tr><tr><td>&lt;beans:alias /&gt;</td><td>为 Spring Bean 定义（BeanDefinition）映射别名</td></tr><tr><td>&lt;beans:import /&gt;</td><td>加载外部 Spring XML 配置资源</td></tr></tbody></table>

<p>底层实现 - <code>XmlBeanDefinitionReader</code></p>
<p>加载 BeanDefinition 入口方法 <code>loadBeanDefinitions</code></p>
<p>使用 DOM 来解析 XML 文件，实现为 <code>BeanDefinitionDocumentReader</code></p>
<p>解析方法：<code>XmlBeanDefinitionReader#parseBeanDefinitions</code></p>
<ol>
<li>判断 beans 标签的 profile 属性，如果不在激活状态，直接返回，不再向下解析</li>
<li>如果是 beans 标签下的特殊元素，进行特殊处理，方法为 <code>DefaultBeanDefinitionDocumentReader#parseDefaultElement</code><ul>
<li>beans</li>
<li>bean</li>
<li>alias</li>
<li>import</li>
</ul>
</li>
<li>否则，<code>BeanDefinitionParserDelegate#parseCustomElement</code></li>
</ol>
<h3 id="基于-Properties-资源装载-Spring-Bean-配置元信息"><a href="#基于-Properties-资源装载-Spring-Bean-配置元信息" class="headerlink" title="基于 Properties 资源装载 Spring Bean 配置元信息"></a>基于 Properties 资源装载 Spring Bean 配置元信息</h3><table><thead><tr><th>Properties 属性名</th><th>使用场景</th></tr></thead><tbody><tr><td>(class)</td><td>Bean 类全称限定名</td></tr><tr><td>(abstract)</td><td>是否为抽象的 BeanDefinition</td></tr><tr><td>(parent)</td><td>指定 parent BeanDefinition 名称</td></tr><tr><td>(lazy-init)</td><td>是否为延迟初始化</td></tr><tr><td>(ref)</td><td>引用其他 Bean 的名称</td></tr><tr><td>(scope)</td><td>设置 Bean 的 scope 属性</td></tr><tr><td>${n}</td><td>n 表示第 n+1 个构造器参数</td></tr></tbody></table>

<p>底层实现 - <code>PropertiesBeanDefinitionReader</code></p>
<p>如果出现重复的 Bean 定义，后者不会被注册进 <code>BeanFactory</code> 中</p>
<h3 id="基于-Java-注解装载-Spring-Bean-配置元信息"><a href="#基于-Java-注解装载-Spring-Bean-配置元信息" class="headerlink" title="基于 Java 注解装载 Spring Bean 配置元信息"></a>基于 Java 注解装载 Spring Bean 配置元信息</h3><h4 id="Spring-模式注解"><a href="#Spring-模式注解" class="headerlink" title="Spring 模式注解"></a>Spring 模式注解</h4><table><thead><tr><th>Spring 注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td>@Repository</td><td>数据仓储模式注解</td><td>2.0</td></tr><tr><td>@Component</td><td>通用组件模式注解</td><td>2.5</td></tr><tr><td>@Service</td><td>服务模式注解</td><td>2.5</td></tr><tr><td>@Controller</td><td>Web 控制器模式注解</td><td>2.5</td></tr><tr><td>@Configuration</td><td>配置类模式注解</td><td>3.0</td></tr></tbody></table>

<p><code>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#registerDefaultFilters</code> 将 <code>@Component</code> 及其派生注解加入筛选</p>
<h4 id="Spring-Bean-定义注解"><a href="#Spring-Bean-定义注解" class="headerlink" title="Spring Bean 定义注解"></a>Spring Bean 定义注解</h4><table><thead><tr><th>Spring 注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td>@Bean</td><td>替换 XML 元素 <code>&lt;bean&gt;</code></td><td>3.0</td></tr><tr><td>@DependsOn</td><td>替代 XML 属性 <code>&lt;bean depends-on="..."/&gt;</code></td><td>3.0</td></tr><tr><td>@Lazy</td><td>替代 XML 属性 <code>&lt;bean lazy-init="true|falses" /&gt;</code></td><td>3.0</td></tr><tr><td>@Primary</td><td>替换 XML 元素 <code>&lt;bean primary="true|false" /&gt;</code></td><td>3.0</td></tr><tr><td>@Role</td><td>替换 XML 元素 <code>&lt;bean role="..." /&gt;</code></td><td>3.1</td></tr><tr><td>@Lookup</td><td>替代 XML 属性 <code>&lt;bean lookup-method="..."&gt;</code></td><td>4.1</td></tr></tbody></table>

<h4 id="Spring-Bean-依赖注入注解"><a href="#Spring-Bean-依赖注入注解" class="headerlink" title="Spring Bean 依赖注入注解"></a>Spring Bean 依赖注入注解</h4><table><thead><tr><th>Spring 注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td>@Autowired</td><td>Bean 依赖注入，支持多种依赖查找方式</td><td>2.5</td></tr><tr><td>@Qualifier</td><td>细粒度的 @Autowired 依赖查找</td><td>2.5</td></tr></tbody></table>

<p><code>AutowiredAnnotationBeanPostProcessor</code> 与 <code>@Autowired</code> 相关</p>
<table><thead><tr><th>Java 注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td>@Resource</td><td>类似于 @Autowired</td><td>2.5</td></tr><tr><td>@Inject</td><td>类似于 @Autowired</td><td>2.5</td></tr></tbody></table>

<p><code>CommonAnnotationBeanPostProcessor</code> 与 <code>@Resource</code> 相关</p>
<p><code>AutowiredAnnotationBeanPostProcessor</code> 与 <code>@Inject</code> 相关</p>
<h4 id="Spring-Bean-条件装配注解"><a href="#Spring-Bean-条件装配注解" class="headerlink" title="Spring Bean 条件装配注解"></a>Spring Bean 条件装配注解</h4><table><thead><tr><th>Spring 注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td>@Profile</td><td>配置化条件装配</td><td>3.1</td></tr><tr><td>@Conditional</td><td>编程条件装配</td><td>4.0</td></tr></tbody></table>

<p><code>@Profile</code> 基于 <code>@Conditional</code> 实现</p>
<p><code>@Conditional</code> 相关 API，<code>ConditionEvaluator</code> ，用于判断 Bean 是否满足条件，满足则注册</p>
<h4 id="Spring-Bean-生命周期回调注解"><a href="#Spring-Bean-生命周期回调注解" class="headerlink" title="Spring Bean 生命周期回调注解"></a>Spring Bean 生命周期回调注解</h4><table><thead><tr><th>Spring 注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td>@PostConstruct</td><td>替换 XML 元素 <code>&lt;bean init-method="..." /&gt;</code> 或 <code>InitializingBean</code></td><td>2.5</td></tr><tr><td>@PreDestroy</td><td>替换 XML 元素 <code>&lt;bean destroy-method="..." /&gt;</code> 或 <code>DisposableBean</code></td><td>2.5</td></tr></tbody></table>

<p><code>CommonAnnotationBeanPostProcessor</code></p>
<h3 id="Spring-Bean-配置元信息底层实现"><a href="#Spring-Bean-配置元信息底层实现" class="headerlink" title="Spring Bean 配置元信息底层实现"></a>Spring Bean 配置元信息底层实现</h3><h4 id="Spring-BeanDefinition-解析与注册"><a href="#Spring-BeanDefinition-解析与注册" class="headerlink" title="Spring BeanDefinition 解析与注册"></a>Spring BeanDefinition 解析与注册</h4><table><thead><tr><th>实现场景</th><th>实现类</th><th>起始版本</th></tr></thead><tbody><tr><td>XML 资源</td><td>XmlBeanDefinitionReader</td><td>1.0</td></tr><tr><td>Properties 资源</td><td>PropertiesBeanDefinitionReader</td><td>1.0</td></tr><tr><td>Java 注解</td><td>AnnotatedBeanDefinitionReader</td><td>3.0</td></tr></tbody></table>

<ul>
<li><p><code>XmlBeanDefinitionReader</code> 和 <code>PropertiesBeanDefinitionReader</code> 都继承自 <code>AbstractBeanDefinitionReader</code>，实现了 <code>BeanDefinitionReader</code> 接口，与资源（Resource）相关联</p>
</li>
<li><p><code>AnnotatedBeanDefinitionReader</code> 是独立的类，与 <code>Resource</code> 无关</p>
</li>
<li><p>Spring XML 资源 BeanDefinition 解析与注册</p>
<ul>
<li>核心 API - <code>XmlBeanDefinitionReader</code><ul>
<li>资源 - Resource</li>
<li>底层 - <code>BeanDefinitionDocumentReader</code><ul>
<li>XML 解析 - Java DOM Level 3 API</li>
<li>BeanDefinition 解析 - <code>BeanDefinitionParserDelegate</code></li>
<li>BeanDefinition 注册 - <code>BeanDefinitionRegistry</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Spring Properties 资源 BeanDefinition 解析与注册</p>
<ul>
<li>核心 API - <code>PropertiesBeanDefinitionReader</code><ul>
<li>资源<ul>
<li>字节流 - <code>Resource</code></li>
<li>字符流 - <code>EncodedResouce</code></li>
</ul>
</li>
<li>底层<ul>
<li>存储 - <code>java.util.Properties</code></li>
<li>BeanDefinition 解析 - API 内部实现</li>
<li>BeanDefinition 注册 - <code>BeanDefinitionRegistry</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Spring Java 注册 BeanDefinition 解析与注册</p>
<ul>
<li>核心 API - <code>AnnotatedBeanDefinitionReader</code><ul>
<li>资源<ul>
<li>类对象 - <code>java.lang.Class</code></li>
</ul>
</li>
<li>底层<ul>
<li>条件评估 - <code>ConditionEvaluator</code></li>
<li>Bean 范围解析 - <code>ScopeMetadataResolver</code></li>
<li>BeanDefinition 解析 - 内部 API 实现</li>
<li>BeanDefinition 处理 - <code>AnnotationConfigUtils.processCommonDefinitionAnnotations</code></li>
<li>BeanDefinition 注册 - <code>BeanDefinitionRegistry</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>Properties</code> 资源加载默认编码是 <code>ISO-8859-1</code></p>
<p><code>AnnotatedBeanDefinitionReader</code> 使用 <code>ConditionEvaluator</code> 判断 Bean 的元信息，如果其中存在 <code>@Conditional</code> 条件，判断此条件通过才会将 Bean 加入容器</p>
<h3 id="基于-XML-资源装载-Spring-IoC-容器配置元信息"><a href="#基于-XML-资源装载-Spring-IoC-容器配置元信息" class="headerlink" title="基于 XML 资源装载 Spring IoC 容器配置元信息"></a>基于 XML 资源装载 Spring IoC 容器配置元信息</h3><p>Spring IoC 容器相关 XML 配置</p>
<table><thead><tr><th>命名空间</th><th>所属模块</th><th>Schema 资源 URL</th></tr></thead><tbody><tr><td>beans</td><td>spring-beans</td><td><a href="https://www.springframework.org/schema/beans/spring-beans.xsd" target="_blank">https://www.springframework.org/schema/beans/spring-beans.xsd</a></td></tr><tr><td>context</td><td>spring-context</td><td><a href="https://www.springframework.org/schema/context/spring-context.xsd" target="_blank">https://www.springframework.org/schema/context/spring-context.xsd</a></td></tr><tr><td>aop</td><td>spring-aop</td><td><a href="https://www.springframework.org/schema/aop/spring-aop.xsd" target="_blank">https://www.springframework.org/schema/aop/spring-aop.xsd</a></td></tr><tr><td>tx</td><td>spring-tx</td><td><a href="https://www.springframework.org/schema/tx/spring-tx.xsd" target="_blank">https://www.springframework.org/schema/tx/spring-tx.xsd</a></td></tr><tr><td>util</td><td>spring-beans</td><td><a href="https://www.springframework.org/schema/util/spring-util.xsd" target="_blank">https://www.springframework.org/schema/util/spring-util.xsd</a></td></tr><tr><td>tool</td><td>spring-beans</td><td><a href="https://www.springframework.org/schema/tool/spring-tool.xsd" target="_blank">https://www.springframework.org/schema/tool/spring-tool.xsd</a></td></tr></tbody></table>

<h3 id="基于-Java-注解装载-Spring-IoC-容器配置元信息"><a href="#基于-Java-注解装载-Spring-IoC-容器配置元信息" class="headerlink" title="基于 Java 注解装载 Spring IoC 容器配置元信息"></a>基于 Java 注解装载 Spring IoC 容器配置元信息</h3><p>Spring IoC 容器装配注解</p>
<table><thead><tr><th>Spring 注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td>@ImportResource</td><td>替换 XML 元素 <code>&lt;import&gt;</code></td><td>3.0</td></tr><tr><td>@Import</td><td>导入 Configuration Class</td><td>3.0</td></tr><tr><td>@ComponentScan</td><td>扫描指定 package 下标注 Spring 模式注解的类</td><td>3.1</td></tr></tbody></table>

<p>Spring IoC 配属属性注</p>
<table><thead><tr><th>Spring 注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td>@PropertySource</td><td>配置属性抽象 PropertySource 注解</td><td>3.1</td></tr><tr><td>@PropertySources</td><td>@PropertySource 集合注解</td><td>4.0</td></tr></tbody></table>

<h3 id="基于-Extensible-XML-authoring-扩展-Spring-XML-元素"><a href="#基于-Extensible-XML-authoring-扩展-Spring-XML-元素" class="headerlink" title="基于 Extensible XML authoring 扩展 Spring XML 元素"></a>基于 Extensible XML authoring 扩展 Spring XML 元素</h3><p>Spring XML 扩展</p>
<ul>
<li>编写 XML Schema 文件：定义 XML 结构<ul>
<li>users.xsd</li>
</ul>
</li>
<li>自定义 <code>NamespaceHandler</code> 实现：命名空间绑定<ul>
<li>spring.handlers</li>
<li><code>org.geekbang.thinking.in.spring.configuration.metadata.UsersNamespaceHandler</code></li>
</ul>
</li>
<li>自定义 <code>BeanDefinitionParser</code> 实现：XML 元素与 <code>BeanDefinition</code> 解析<ul>
<li><code>org.geekbang.thinking.in.spring.configuration.metadata.UserBeanDefinitionParser</code></li>
</ul>
</li>
<li>注册 XML 扩展：命名空间与 XML Schema 映射<ul>
<li>spring.schemas</li>
<li>users-context.xml</li>
</ul>
</li>
</ul>
<p>触发时机：<code>BeanDefinitionParserDelegate#parseCustomElement</code></p>
<ul>
<li>获取 namespace</li>
<li>通过 namespace 解析 <code>NamespaceHandler</code></li>
<li>构造 <code>ParserContext</code></li>
<li>解析元素，获取 <code>BeanDefinintion</code></li>
</ul>
<h3 id="基于-Properties-资源装载外部化配置"><a href="#基于-Properties-资源装载外部化配置" class="headerlink" title="基于 Properties 资源装载外部化配置"></a>基于 Properties 资源装载外部化配置</h3><ul>
<li>注解驱动<ul>
<li><code>@org.springframework.context.annotation.PropertySource</code></li>
<li><code>@org.springframework.context.annotation.PropertySources</code></li>
</ul>
</li>
<li>API 编程<ul>
<li><code>org.springframework.core.env.PropertySource</code></li>
<li><code>org.springframework.core.env.PropertySources</code></li>
</ul>
</li>
</ul>
<h3 id="基于-YAML-资源装载外部化配置"><a href="#基于-YAML-资源装载外部化配置" class="headerlink" title="基于 YAML 资源装载外部化配置"></a>基于 YAML 资源装载外部化配置</h3><p>API 编程</p>
<ul>
<li><code>org.springframework.beans.factory.config.YamlProcessor</code><ul>
<li><code>org.springframework.beans.factory.config.YamlMapFactoryBean</code></li>
<li><code>org.springframework.beans.factory.config.YamlPropertiesFactoryBean</code></li>
</ul>
</li>
</ul>
<p>Requires SnakeYAML 1.18 or higher, as of Spring Framework 5.0.6</p>
<h4 id="通过-PropertySourceFactory-接口，引入-PropertySource"><a href="#通过-PropertySourceFactory-接口，引入-PropertySource" class="headerlink" title="通过 PropertySourceFactory 接口，引入 PropertySource"></a>通过 PropertySourceFactory 接口，引入 PropertySource</h4><p><code>org.springframework.core.io.support.PropertySourceFactory</code></p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@PropertySource</span>(<br>        name = <span class="hljs-string">&quot;yamlPropertySource&quot;</span>,<br>        value = <span class="hljs-string">&quot;classpath:/META-INF/user.yaml&quot;</span>,<br>        <span class="hljs-keyword">factory</span> = YamlPropertySourceFactory.<span class="hljs-keyword">class</span>)<br></code></pre></td></tr></table></figure>

<h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><h4 id="Spring-內建-XML-Schema-常见有哪些？"><a href="#Spring-內建-XML-Schema-常见有哪些？" class="headerlink" title="Spring 內建 XML Schema 常见有哪些？"></a>Spring 內建 XML Schema 常见有哪些？</h4><table><thead><tr><th>命名空间</th><th>所属模块</th><th>Schema 资源 URL</th></tr></thead><tbody><tr><td>beans</td><td>spring-beans</td><td><a href="https://www.springframework.org/schema/beans/spring-beans.xsd" target="_blank">https://www.springframework.org/schema/beans/spring-beans.xsd</a></td></tr><tr><td>context</td><td>spring-context</td><td><a href="https://www.springframework.org/schema/context/spring-context.xsd" target="_blank">https://www.springframework.org/schema/context/spring-context.xsd</a></td></tr><tr><td>aop</td><td>spring-aop</td><td><a href="https://www.springframework.org/schema/aop/spring-aop.xsd" target="_blank">https://www.springframework.org/schema/aop/spring-aop.xsd</a></td></tr><tr><td>tx</td><td>spring-tx</td><td><a href="https://www.springframework.org/schema/tx/spring-tx.xsd" target="_blank">https://www.springframework.org/schema/tx/spring-tx.xsd</a></td></tr><tr><td>util</td><td>spring-beans</td><td><a href="https://www.springframework.org/schema/util/spring-util.xsd" target="_blank">https://www.springframework.org/schema/util/spring-util.xsd</a></td></tr><tr><td>tool</td><td>spring-beans</td><td><a href="https://www.springframework.org/schema/tool/spring-tool.xsd" target="_blank">https://www.springframework.org/schema/tool/spring-tool.xsd</a></td></tr></tbody></table>

<h4 id="Spring-配置元信息具体有哪些？"><a href="#Spring-配置元信息具体有哪些？" class="headerlink" title="Spring 配置元信息具体有哪些？"></a>Spring 配置元信息具体有哪些？</h4><ul>
<li>Bean 配置元信息：通过媒介（如 XML、Proeprties 等），解析 BeanDefinition</li>
<li>IoC 容器配置元信息：通过媒介（如 XML、Proeprties 等），控制 IoC 容器行为，比如注解驱动、AOP 等</li>
<li>外部化配置：通过资源抽象（如 Proeprties、YAML 等），控制 PropertySource</li>
<li>Spring Profile：通过外部化配置，提供条件分支流程</li>
</ul>
<h4 id="Extensible-XML-authoring-的缺点？"><a href="#Extensible-XML-authoring-的缺点？" class="headerlink" title="Extensible XML authoring 的缺点？"></a>Extensible XML authoring 的缺点？</h4><ul>
<li>高复杂度：开发人员需要熟悉 XML Schema，spring.handlers，spring.schemas 以及 Spring API 。</li>
<li>嵌套元素支持较弱：通常需要使用方法递归或者其嵌套解析的方式处理嵌套（子）元素。</li>
<li>XML 处理性能较差：Spring XML 基于 DOM Level 3 API 实现，该 API 便于理解，然而性能较差。</li>
<li>XML 框架移植性差：很难适配高性能和便利性的 XML 框架，如 JAXB。</li>
</ul>
<h2 id="第十一章：Spring-资源管理"><a href="#第十一章：Spring-资源管理" class="headerlink" title="第十一章：Spring 资源管理"></a>第十一章：Spring 资源管理</h2><h3 id="引入动机"><a href="#引入动机" class="headerlink" title="引入动机"></a>引入动机</h3><p>为什么 Spring 不使用 Java 标准资源管理，而选择重新发明轮子？</p>
<ul>
<li>Java 标准资源管理强大，然而扩展复杂，资源存储方式并不统一</li>
<li>Spring 要自立门户（重要的话，要讲三遍）</li>
<li>Spring “抄”、“超” 和 “潮”</li>
</ul>
<h3 id="Java-标准资源管理"><a href="#Java-标准资源管理" class="headerlink" title="Java 标准资源管理"></a>Java 标准资源管理</h3><h4 id="Java-标准资源定位"><a href="#Java-标准资源定位" class="headerlink" title="Java 标准资源定位"></a>Java 标准资源定位</h4><table><thead><tr><th>职责</th><th>说明</th></tr></thead><tbody><tr><td>面向资源</td><td>文件系统、artifact（jar、war、ear 文件）以及远程资源（HTTP、FTP 等）</td></tr><tr><td>API 整合</td><td>java.lang.ClassLoader#getResource、java.io.File 或 java.net.URL</td></tr><tr><td>资源定位</td><td>java.net.URL 或 java.net.URI</td></tr><tr><td>面向流式存储</td><td>java.net.URLConnection</td></tr><tr><td>协议扩展</td><td>java.net.URLStreamHandler 或 java.net.URLStreamHandlerFactory</td></tr></tbody></table>

<h4 id="Java-URL-协议扩展"><a href="#Java-URL-协议扩展" class="headerlink" title="Java URL 协议扩展"></a>Java URL 协议扩展</h4><ul>
<li>基于 <code>java.net.URLStreamHandlerFactory</code></li>
<li>基于 <code>java.net.URLStreamHandler</code></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/F7gVJwfHGQ8ZWo6.png" srcset="/img/loading.gif" alt=""></p>
<h4 id="基于-java-net-URLStreamHandler-扩展协议"><a href="#基于-java-net-URLStreamHandler-扩展协议" class="headerlink" title="基于 java.net.URLStreamHandler 扩展协议"></a>基于 java.net.URLStreamHandler 扩展协议</h4><p>JDK 1.8 內建协议实现</p>
<table><thead><tr><th>协议</th><th>实现类</th></tr></thead><tbody><tr><td>file</td><td><code>sun.net.www.protocol.file.Handler</code></td></tr><tr><td>ftp</td><td><code>sun.net.www.protocol.ftp.Handler</code></td></tr><tr><td>http</td><td><code>sun.net.www.protocol.http.Handler</code></td></tr><tr><td>https</td><td><code>sun.net.www.protocol.https.Handler</code></td></tr><tr><td>jar</td><td><code>sun.net.www.protocol.jar.Handler</code></td></tr><tr><td>mailto</td><td><code>sun.net.www.protocol.mailto.Handler</code></td></tr><tr><td>netdoc</td><td><code>sun.net.www.protocol.netdoc.Handler</code></td></tr></tbody></table>

<p>实现类名必须为 <code>Handler</code></p>
<table><thead><tr><th>实现类命名规则</th><th>说明</th></tr></thead><tbody><tr><td>默认</td><td><code>sun.net.www.protocol.$&#123;protocol&#125;.Handler</code></td></tr><tr><td>自定义</td><td>通过 Java Properties <code>java.protocol.handler.pkgs</code> 指定实现类包名，实现类名必须为 <code>Handler</code>。如果存在多包名指定，通过分隔符 <code>|</code></td></tr></tbody></table>

<h3 id="Spring-资源接口"><a href="#Spring-资源接口" class="headerlink" title="Spring 资源接口"></a>Spring 资源接口</h3><table><thead><tr><th>类型</th><th>接口</th></tr></thead><tbody><tr><td>输入流</td><td><code>org.springframework.core.io.InputStreamSource</code></td></tr><tr><td>只读资源</td><td><code>org.springframework.core.io.Resource</code></td></tr><tr><td>可写资源</td><td><code>org.springframework.core.io.WritableResource</code></td></tr><tr><td>编码资源</td><td><code>org.springframework.core.io.support.EncodedResource</code></td></tr><tr><td>上下文资源</td><td><code>org.springframework.core.io.ContextResource</code></td></tr></tbody></table>

<h3 id="Spring-内建-Resource-实现"><a href="#Spring-内建-Resource-实现" class="headerlink" title="Spring 内建 Resource 实现"></a>Spring 内建 Resource 实现</h3><table><thead><tr><th>资源来源</th><th>资源协议</th><th>实现类</th></tr></thead><tbody><tr><td>Bean 定义</td><td>无</td><td><code>org.springframework.beans.factory.support.BeanDefinitionResource</code></td></tr><tr><td>数组</td><td>无</td><td><code>org.springframework.core.io.ByteArrayResource</code></td></tr><tr><td>类路径</td><td><code>classpath:/</code></td><td><code>org.springframework.core.io.ClassPathResource</code></td></tr><tr><td>文件系统</td><td><code>file:/</code></td><td><code>org.springframework.core.io.FileSystemResource</code></td></tr><tr><td>URL</td><td>URL 支持的协议</td><td><code>org.springframework.core.io.UrlResource</code></td></tr><tr><td>ServletContext</td><td>无</td><td><code>org.springframework.web.context.support.ServletContextResource</code></td></tr></tbody></table>

<h3 id="Spring-Resource-接口扩展"><a href="#Spring-Resource-接口扩展" class="headerlink" title="Spring Resource 接口扩展"></a>Spring Resource 接口扩展</h3><ul>
<li>可写资源接口<ul>
<li><code>org.springframework.core.io.WritableResource</code><ul>
<li><code>org.springframework.core.io.FileSystemResource</code></li>
<li><code>org.springframework.core.io.FileUrlResource</code>（@since 5.0.2）</li>
<li><code>org.springframework.core.io.PathResource</code>（@since 4.0 &amp; @Deprecated）</li>
</ul>
</li>
</ul>
</li>
<li>编码资源接口<ul>
<li><code>org.springframework.core.io.support.EncodedResource</code></li>
</ul>
</li>
</ul>
<h3 id="Spring-资源加载器"><a href="#Spring-资源加载器" class="headerlink" title="Spring 资源加载器"></a>Spring 资源加载器</h3><p>Resource 加载器</p>
<ul>
<li><code>org.springframework.core.io.ResourceLoader</code><ul>
<li><code>org.springframework.core.io.DefaultResourceLoader</code><ul>
<li><code>org.springframework.core.io.FileSystemResourceLoader</code></li>
<li><code>org.springframework.core.io.ClassRelativeResourceLoader</code></li>
<li><code>org.springframework.context.support.AbstractApplicationContext</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Spring-通配路径资源加载器"><a href="#Spring-通配路径资源加载器" class="headerlink" title="Spring 通配路径资源加载器"></a>Spring 通配路径资源加载器</h3><ul>
<li>通配路径 ResourceLoader<ul>
<li><code>org.springframework.core.io.support.ResourcePatternResolver</code></li>
<li><code>org.springframework.core.io.support.PathMatchingResourcePatternResolver</code></li>
</ul>
</li>
<li>路径匹配器<ul>
<li><code>org.springframework.util.PathMatcher</code><ul>
<li>Ant 模式匹配实现 - <code>org.springframework.util.AntPathMatcher</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Spring-通配路径资源扩展"><a href="#Spring-通配路径资源扩展" class="headerlink" title="Spring 通配路径资源扩展"></a>Spring 通配路径资源扩展</h3><ol>
<li>实现 <code>org.springframework.util.PathMatcher</code></li>
<li>重置 PathMatcher<ul>
<li><code>PathMatchingResourcePatternResolver#setPathMatcher</code></li>
</ul>
</li>
</ol>
<h3 id="依赖注入-Spring-Resource"><a href="#依赖注入-Spring-Resource" class="headerlink" title="依赖注入 Spring Resource"></a>依赖注入 Spring Resource</h3><p>基于 <code>@Value</code> 实现</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Value(<span class="hljs-meta-string">&quot;classpath:/...&quot;</span>)</span> <br><span class="hljs-keyword">private</span> Resource resource;<br><br><span class="hljs-meta">@Value(<span class="hljs-meta-string">&quot;classpath*:/META-INF/*.properties&quot;</span>)</span><br><span class="hljs-keyword">private</span> Resource[] propertiesResources;<br></code></pre></td></tr></table></figure>

<h3 id="依赖注入-ResourceLoader"><a href="#依赖注入-ResourceLoader" class="headerlink" title="依赖注入 ResourceLoader"></a>依赖注入 ResourceLoader</h3><ul>
<li>方法一：实现 <code>ResourceLoaderAware</code> 回调</li>
<li>方法二：<code>@Autowired</code> 注入 <code>ResourceLoader</code></li>
<li>方法三：注入 <code>ApplicationContext</code> 作为 <code>ResourceLoader</code></li>
</ul>
<p><code>ApplicationContext</code> 接口继承 <code>ResourcePatternResolver</code> 继承 <code>ResourceLoader</code></p>
<p><code>ResourceLoaderAware</code> 回调在 实例初始化（<code>@PostConstruct</code> 等）之前</p>
<h3 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h3><h4 id="Spring-配置资源中有哪些常见类型？"><a href="#Spring-配置资源中有哪些常见类型？" class="headerlink" title="Spring 配置资源中有哪些常见类型？"></a>Spring 配置资源中有哪些常见类型？</h4><ul>
<li>XML 资源</li>
<li>Properties 资源</li>
<li>YAML 资源</li>
</ul>
<h4 id="请例举不同类型-Spring-配置资源？"><a href="#请例举不同类型-Spring-配置资源？" class="headerlink" title="请例举不同类型 Spring 配置资源？"></a>请例举不同类型 Spring 配置资源？</h4><ul>
<li>XML 资源<ul>
<li>普通 Bean Definition XML 配置资源 - <code>*.xml</code></li>
<li>Spring Schema 资源 - <code>*.xsd</code></li>
</ul>
</li>
<li>Properties 资源<ul>
<li>普通 Properties 格式资源 - <code>*.properties</code></li>
<li>Spring Handler 实现类映射文件 - <code>META-INF/spring.handlers</code></li>
<li>Spring Schema 资源映射文件 - <code>META-INF/spring.schemas</code></li>
</ul>
</li>
<li>YAML 资源<ul>
<li>普通 YAML 配置资源 - <code>*.yaml</code> 或 <code>*.yml</code></li>
</ul>
</li>
</ul>
<h4 id="Java-标准资源管理扩展的步骤？"><a href="#Java-标准资源管理扩展的步骤？" class="headerlink" title="Java 标准资源管理扩展的步骤？"></a>Java 标准资源管理扩展的步骤？</h4><ul>
<li>简易实现<ul>
<li>实现 <code>URLStreamHandler</code> 并放置在 <code>sun.net.www.protocol.$&#123;protocol&#125;.Handler</code> 包下</li>
</ul>
</li>
<li>自定义实现<ul>
<li>实现 <code>URLStreamHandler</code></li>
<li>添加 <code>-Djava.protocol.handler.pkgs</code> 启动参数，指向 <code>URLStreamHandler</code> 实现类的包下</li>
</ul>
</li>
<li>高级实现<ul>
<li>实现 <code>URLStreamHandlerFactory</code> 并传递到 URL 之中</li>
</ul>
</li>
</ul>
<h5 id="简易实现实例"><a href="#简易实现实例" class="headerlink" title="简易实现实例"></a>简易实现实例</h5><ol>
<li><p>扩展 x 协议，新建类 <code>sun.net.www.protocol.x.Handler</code>，类名格式必须符合规范</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">URLStreamHandler</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">URLConnection</span> openConnection(<span class="hljs-type">URL</span> u) <span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">XURLConnection</span>(u);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>新建类 <code>XURLConnection</code> ，实现 <code>java.net.URLConnection</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XURLConnection</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">URLConnection</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ClassPathResource</span> resource;<br><br>    <span class="hljs-comment">// URL = x:///META-INF/default.properties</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">XURLConnection</span>(<span class="hljs-type">URL</span> url) &#123;<br>        <span class="hljs-keyword">super</span>(url);<br>        <span class="hljs-keyword">this</span>.resource = <span class="hljs-keyword">new</span> <span class="hljs-type">ClassPathResource</span>(url.getPath());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    public void connect() <span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span> &#123;<br><br>    &#125;<br><br>    public <span class="hljs-type">InputStream</span> getInputStream() <span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span> &#123;<br>        <span class="hljs-keyword">return</span> resource.getInputStream();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>测试使用</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> HandlerTest &#123;<br><br>    public static void main(String<span class="hljs-literal">[]</span> args) throws IOException &#123;<br>        URL url = <span class="hljs-keyword">new</span> <span class="hljs-constructor">URL(<span class="hljs-string">&quot;x:///META-INF/default.properties&quot;</span>)</span>; <span class="hljs-comment">// 类似于 classpath:/META-INF/default.properties</span><br>        InputStream inputStream = url.<span class="hljs-keyword">open</span><span class="hljs-constructor">Stream()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StreamUtils</span>.</span></span>copy<span class="hljs-constructor">ToString(<span class="hljs-params">inputStream</span>, Charset.<span class="hljs-params">forName</span>(<span class="hljs-string">&quot;UTF-8&quot;</span>)</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
</ol>
<h5 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h5><ol>
<li><p>新建类 <code>Handler</code>，继承 <code>sun.net.www.protocol.x.Handle</code>，类名必须为 <code>Handler</code>，包名无限制</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">sun</span>.<span class="hljs-title">net</span>.<span class="hljs-title">www</span>.<span class="hljs-title">protocol</span>.<span class="hljs-title">x</span>.<span class="hljs-title">Handler</span> </span>&#123;<br><br>    <span class="hljs-comment">// -Djava.protocol.handler.pkgs=org.geekbang.thinking.in.spring.resource</span><br>    public static void main(<span class="hljs-type">String</span>[] args) <span class="hljs-keyword">throws</span> <span class="hljs-type">IOException</span> &#123;<br>        <span class="hljs-comment">// springx 协议</span><br>        <span class="hljs-type">URL</span> url = <span class="hljs-keyword">new</span> <span class="hljs-type">URL</span>(<span class="hljs-string">&quot;springx:///META-INF/production.properties&quot;</span>); <span class="hljs-comment">// 类似于 classpath:/META-INF/default.properties</span><br>        <span class="hljs-type">InputStream</span> inputStream = url.openStream();<br>        <span class="hljs-type">System</span>.out.println(<span class="hljs-type">StreamUtils</span>.copyToString(inputStream, <span class="hljs-type">Charset</span>.forName(<span class="hljs-string">&quot;UTF-8&quot;</span>)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>运行时增加 VM 参数，<code>-Djava.protocol.handler.pkgs=org.geekbang.thinking.in.spring.resource</code></p>
</li>
</ol>
<h5 id="高级实现"><a href="#高级实现" class="headerlink" title="高级实现"></a>高级实现</h5><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> MyURLStreamHandlerFactory implements URLStreamHandlerFactory &#123;<br>    @Override<br>    public URLStreamHandler create<span class="hljs-constructor">URLStreamHandler(String <span class="hljs-params">protocol</span>)</span> &#123;<br>        return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Handler()</span>;<br>    &#125;<br><br>    public static void main(String<span class="hljs-literal">[]</span> args) throws IOException &#123;<br>        <span class="hljs-comment">// URL 设置 URLStreamHandlerFactory，必须在创建 URL 实例之前</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">URL</span>.</span></span>set<span class="hljs-constructor">URLStreamHandlerFactory(<span class="hljs-params">new</span> MyURLStreamHandlerFactory()</span>);<br>        <span class="hljs-comment">// springx 协议</span><br>        URL url = <span class="hljs-keyword">new</span> <span class="hljs-constructor">URL(<span class="hljs-string">&quot;springx:///META-INF/production.properties&quot;</span>)</span>; <span class="hljs-comment">// 类似于 classpath:/META-INF/default.properties</span><br>        <br>        InputStream inputStream = url.<span class="hljs-keyword">open</span><span class="hljs-constructor">Stream()</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StreamUtils</span>.</span></span>copy<span class="hljs-constructor">ToString(<span class="hljs-params">inputStream</span>, Charset.<span class="hljs-params">forName</span>(<span class="hljs-string">&quot;UTF-8&quot;</span>)</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>本文由 <a target="_blank" rel="noopener" href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/huangwenjie/p/13946003.html">www.cnblogs.com</a></p>
</blockquote>
<h2 id="第十二章：Spring-国际化"><a href="#第十二章：Spring-国际化" class="headerlink" title="第十二章：Spring 国际化"></a>第十二章：Spring 国际化</h2><h3 id="Spring-国际化使用场景"><a href="#Spring-国际化使用场景" class="headerlink" title="Spring 国际化使用场景"></a>Spring 国际化使用场景</h3><ul>
<li>普通国际化文案</li>
<li>Bean Validation 校验国际化文案</li>
<li>Web 站点页面渲染</li>
<li>Web MVC 错误消息提示</li>
</ul>
<h3 id="Spring-国际化接口"><a href="#Spring-国际化接口" class="headerlink" title="Spring 国际化接口"></a>Spring 国际化接口</h3><ul>
<li>核心接口 - <code>org.springframework.context.MessageSource</code></li>
<li>主要概念<ul>
<li>文案模板编码（code）</li>
<li>文案模板参数（args）</li>
<li>区域（Locale）</li>
</ul>
</li>
</ul>
<h3 id="层次性-MessageSource"><a href="#层次性-MessageSource" class="headerlink" title="层次性 MessageSource"></a>层次性 MessageSource</h3><ul>
<li>Spring 层次性接口回顾<ul>
<li><code>org.springframework.beans.factory.HierarchicalBeanFactory</code></li>
<li><code>org.springframework.context.ApplicationContext</code></li>
<li><code>org.springframework.beans.factory.config.BeanDefinition</code></li>
</ul>
</li>
<li>Spring 层次性国际化接口<ul>
<li><code>org.springframework.context.HierarchicalMessageSource</code></li>
</ul>
</li>
</ul>
<h3 id="Java-国际化标准实现"><a href="#Java-国际化标准实现" class="headerlink" title="Java 国际化标准实现"></a>Java 国际化标准实现</h3><p>核心接口</p>
<ul>
<li>抽象类实现 - <code>java.util.ResourceBundle</code><ul>
<li>Properties 资源实现 - <code>java.util.PropertyResourceBundle</code></li>
<li>例举实现 - <code>java.util.ListResourceBundle</code></li>
</ul>
</li>
</ul>
<p><code>ResourceBundle</code> 核心特性</p>
<ul>
<li>Key-Value 设计<ul>
<li>键唯一地标识了包中特定于语言环境的对象</li>
<li>value 就是 文案模板编码（code）</li>
</ul>
</li>
<li>层次性设计</li>
<li>缓存设计</li>
<li>字符编码控制 - <code>java.util.ResourceBundle.Control</code>（@since 1.6）</li>
<li>Control SPI 扩展 - <code>java.util.spi.ResourceBundleControlProvider</code>（@since 1.8）</li>
</ul>
<h3 id="Java-文本格式化"><a href="#Java-文本格式化" class="headerlink" title="Java 文本格式化"></a>Java 文本格式化</h3><p>核心接口 - <code>java.text.MessageFormat</code></p>
<ul>
<li>基本用法<ul>
<li>设置消息格式模式 - <code>new MessageFormat(...)</code></li>
<li>格式化 - <code>format(new Object[]&#123;...&#125;)</code></li>
</ul>
</li>
<li>消息格式模式<ul>
<li>格式元素：<code>&#123;ArgumentIndex (,FormatType,(FormatStyle))&#125;</code></li>
<li><code>FormatType</code>：消息格式类型，可选项，每种类型在 <code>number</code>、<code>date</code>、<code>time</code> 和 <code>choice</code> 类型选其一</li>
<li><code>FormatStyle</code>：消息格式风格，可选项，包括：<code>short</code>、<code>medium</code>、<code>long</code>、<code>full</code>、<code>integer</code>、<code>currency</code>、<code>percent</code></li>
</ul>
</li>
</ul>
<p>高级特性</p>
<ul>
<li>重置消息格式模式</li>
<li>重置 <code>java.util.Locale</code></li>
<li>重置 <code>java.text.Format</code></li>
</ul>
<h3 id="MessageSource-开箱即用实现"><a href="#MessageSource-开箱即用实现" class="headerlink" title="MessageSource 开箱即用实现"></a>MessageSource 开箱即用实现</h3><ul>
<li>基于 <code>ResourceBundle</code> + <code>MessageFormat</code> 组合 <code>MessageSource</code> 实现<ul>
<li><code>org.springframework.context.support.ResourceBundleMessageSource</code></li>
</ul>
</li>
<li>可重载 <code>Properties</code> + <code>MessageFormat</code> 组合 <code>MessageSource</code> 实现<ul>
<li><code>org.springframework.context.support.ReloadableResourceBundleMessageSource</code></li>
</ul>
</li>
</ul>
<h3 id="MessageSource-內建依赖"><a href="#MessageSource-內建依赖" class="headerlink" title="MessageSource 內建依赖"></a>MessageSource 內建依赖</h3><p><code>MessageSource</code> 內建 Bean 可能来源</p>
<ul>
<li>预注册 Bean 名称为：<code>messageSource</code>，类型为：<code>MessageSource</code></li>
<li>默认內建实现 - <code>DelegatingMessageSource</code><ul>
<li>层次性查找 <code>MessageSource</code> 对象</li>
</ul>
</li>
</ul>
<h3 id="课外资料"><a href="#课外资料" class="headerlink" title="课外资料"></a>课外资料</h3><p>Spring Boot 为什么要新建 MessageSource Bean？</p>
<ul>
<li><code>AbstractApplicationContext</code> 的实现决定了 <code>MessageSource</code> 內建实现</li>
<li>Spring Boot 通过外部化配置简化 <code>MessageSource</code> Bean 构建</li>
<li>Spring Boot 基于 Bean Validation 校验非常普遍</li>
</ul>
<p>SpringBoot 中关于 <code>MessageSource</code> 的自动配置类</p>
<ul>
<li><code>org.springframework.context.support.ResourceBundleMessageSource</code></li>
</ul>
<h3 id="面试题-3"><a href="#面试题-3" class="headerlink" title="面试题"></a>面试题</h3><h4 id="Spring-国际化接口有哪些？"><a href="#Spring-国际化接口有哪些？" class="headerlink" title="Spring 国际化接口有哪些？"></a>Spring 国际化接口有哪些？</h4><ul>
<li>核心接口 - <code>MessageSource</code></li>
<li>层次性接口 - <code>org.springframework.context.HierarchicalMessageSource</code></li>
</ul>
<h4 id="Spring-有哪些-MessageSource-內建实现？"><a href="#Spring-有哪些-MessageSource-內建实现？" class="headerlink" title="Spring 有哪些 MessageSource 內建实现？"></a>Spring 有哪些 MessageSource 內建实现？</h4><ul>
<li><code>org.springframework.context.support.ResourceBundleMessageSource</code></li>
<li><code>org.springframework.context.support.ReloadableResourceBundleMessageSource</code></li>
<li><code>org.springframework.context.support.StaticMessageSource</code></li>
<li><code>org.springframework.context.support.DelegatingMessageSource</code></li>
</ul>
<h4 id="如何实现配置自动更新-MessageSource？"><a href="#如何实现配置自动更新-MessageSource？" class="headerlink" title="如何实现配置自动更新 MessageSource？"></a>如何实现配置自动更新 MessageSource？</h4><p>主要技术</p>
<ul>
<li>Java NIO 2：<code>java.nio.file.WatchService</code></li>
<li>Java Concurrency : <code>java.util.concurrent.ExecutorService</code></li>
<li>Spring：<code>org.springframework.context.support.AbstractMessageSource</code></li>
</ul>
<h2 id="第十三章：Spring-校验"><a href="#第十三章：Spring-校验" class="headerlink" title="第十三章：Spring 校验"></a>第十三章：Spring 校验</h2><h3 id="Spring-校验使用场景"><a href="#Spring-校验使用场景" class="headerlink" title="Spring 校验使用场景"></a>Spring 校验使用场景</h3><ul>
<li>Spring 常规校验（Validator）</li>
<li>Spring 数据绑定（DataBinder）</li>
<li>Spring Web 参数绑定（WebDataBinder）</li>
<li>Spring Web MVC / Spring WebFlux 处理方法参数校验</li>
</ul>
<h3 id="Validator-接口设计"><a href="#Validator-接口设计" class="headerlink" title="Validator 接口设计"></a>Validator 接口设计</h3><ul>
<li><p><code>org.springframework.validation.Validator</code></p>
</li>
<li><p>接口职责</p>
<ul>
<li>Spring 内部校验器接口，通过编程的方式校验目标对象</li>
</ul>
</li>
<li><p>核心方法</p>
<ul>
<li><code>supports(Class)</code>：校验目标类能否校验</li>
<li><code>validate(Object,Errors)</code>：校验目标对象，并将校验失败的内容输出至 <code>Errors</code> 对象</li>
</ul>
</li>
<li><p>配套组件</p>
<ul>
<li>错误收集器：<code>org.springframework.validation.Errors</code></li>
<li>Validator 工具类：<code>org.springframework.validation.ValidationUtils</code></li>
</ul>
</li>
</ul>
<h3 id="Errors-接口设计"><a href="#Errors-接口设计" class="headerlink" title="Errors 接口设计"></a>Errors 接口设计</h3><ul>
<li><code>org.springframework.validation.Errors</code></li>
<li>接口职责<ul>
<li>数据绑定和校验错误收集接口，与 Java Bean 和其属性有强关联性</li>
</ul>
</li>
<li>核心方法<ul>
<li><code>reject</code> 方法（重载）：收集错误文案</li>
<li><code>rejectValue</code> 方法（重载）：收集对象字段中的错误文案</li>
</ul>
</li>
<li>配套组件<ul>
<li>Java Bean 错误描述：<code>org.springframework.validation.ObjectError</code></li>
<li>Java Bean 属性错误描述：<code>org.springframework.validation.FieldError</code></li>
</ul>
</li>
</ul>
<h3 id="Errors-文案来源"><a href="#Errors-文案来源" class="headerlink" title="Errors 文案来源"></a>Errors 文案来源</h3><p><code>Errors</code> 文案生成步骤</p>
<ul>
<li>选择 <code>Errors</code> 实现（如：<code>org.springframework.validation.BeanPropertyBindingResult</code>）</li>
<li>调用 <code>reject</code> 或 <code>rejectValue</code> 方法</li>
<li>获取 <code>Errors</code> 对象中 <code>ObjectError</code> 或 <code>FieldError</code></li>
<li>将 <code>ObjectError</code> 或 <code>FieldError</code> 中的 <code>code</code> 和 <code>args</code>，关联 <code>MessageSource</code> 实现（如：<code>ResourceBundleMessageSource</code>）</li>
</ul>
<p><code>Errors</code> 不能直接生成文案，但是可以提供国际化接口 <code>MessageSource</code> 所需要的 <code>code</code> 和 <code>args</code></p>
<h3 id="自定义-Validator"><a href="#自定义-Validator" class="headerlink" title="自定义 Validator"></a>自定义 Validator</h3><p>实现 <code>org.springframework.validation.Validator</code> 接口</p>
<ul>
<li>实现 <code>supports</code> 方法</li>
<li>实现 <code>validate</code> 方法<ul>
<li>通过 <code>Errors</code> 对象收集错误<ul>
<li><code>ObjectError</code>：对象（Bean）错误：</li>
<li><code>FieldError</code>：对象（Bean）属性（Property）错误</li>
</ul>
</li>
<li>通过 <code>ObjectError</code> 和 <code>FieldError</code> 关联 <code>MessageSource</code> 实现获取最终文案</li>
</ul>
</li>
</ul>
<h3 id="Validator-的救赎"><a href="#Validator-的救赎" class="headerlink" title="Validator 的救赎"></a>Validator 的救赎</h3><p>Bean Validation 与 Validator 适配</p>
<ul>
<li>核心组件 - <code>org.springframework.validation.beanvalidation.LocalValidatorFactoryBean</code></li>
<li>依赖 Bean Validation - JSR-303 or JSR-349 provider</li>
<li>Bean 方法参数校验 - <code>org.springframework.validation.beanvalidation.MethodValidationPostProcessor</code></li>
</ul>
<p>关联注解：</p>
<ul>
<li><code>org.springframework.validation.annotation.Validated</code></li>
<li><code>javax.validation.Valid</code></li>
</ul>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> SpringBeanValidationDemo &#123;<br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        // 配置 <span class="hljs-type">XML</span> 配置文件<br>        // 启动 Spring 应用上下文<br>        ConfigurableApplicationContext applicationContext = <span class="hljs-built_in">new</span> ClassPathXmlApplicationContext(&quot;classpath:/META-INF/bean-validation-context.xml&quot;);<br><br>//        <span class="hljs-keyword">Validator</span> <span class="hljs-keyword">validator</span> = applicationContext.getBean(<span class="hljs-keyword">Validator</span>.<span class="hljs-keyword">class</span>);<br>//        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">validator</span> instanceof LocalValidatorFactoryBean);<br><br>        UserProcessor userProcessor = applicationContext.getBean(UserProcessor.<span class="hljs-keyword">class</span>);<br>        userProcessor.process(<span class="hljs-built_in">new</span> <span class="hljs-keyword">User</span>());<br><br>        // 关闭应用上下文<br>        applicationContext.<span class="hljs-keyword">close</span>();<br>    &#125;<br><br>    @Component<br>    @Validated<br>    static <span class="hljs-keyword">class</span> UserProcessor &#123;<br><br>        <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> process(@<span class="hljs-keyword">Valid</span> <span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span>) &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">user</span>);<br>        &#125;<br><br>    &#125;<br><br>    static <span class="hljs-keyword">class</span> <span class="hljs-keyword">User</span> &#123;<br><br>        @<span class="hljs-keyword">NotNull</span><br>        private String <span class="hljs-type">name</span>;<br><br>        <span class="hljs-built_in">public</span> String getName() &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-type">name</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> setName(String <span class="hljs-type">name</span>) &#123;<br>            this.name = <span class="hljs-type">name</span>;<br>        &#125;<br><br>        @Override<br>        <span class="hljs-built_in">public</span> String toString() &#123;<br>            <span class="hljs-keyword">return</span> &quot;User&#123;&quot; +<br>                    &quot; + name + &#x27;\&#x27;&#x27; +<br>                    &#x27;&#125;&#x27;;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.geekbang.thinking.in.spring.validation&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;validator&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;</span>/&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.validation.beanvalidation.MethodValidationPostProcessor&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">property</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="面试题-4"><a href="#面试题-4" class="headerlink" title="面试题"></a>面试题</h3><h4 id="Spring-校验接口是哪个？"><a href="#Spring-校验接口是哪个？" class="headerlink" title="Spring 校验接口是哪个？"></a>Spring 校验接口是哪个？</h4><p><code>org.springframework.validation.Validator</code></p>
<h4 id="Spring-有哪些校验核心组件？"><a href="#Spring-有哪些校验核心组件？" class="headerlink" title="Spring 有哪些校验核心组件？"></a>Spring 有哪些校验核心组件？</h4><ul>
<li>检验器：<code>org.springframework.validation.Validator</code></li>
<li>错误收集器：<code>org.springframework.validation.Errors</code></li>
<li>Java Bean 错误描述：<code>org.springframework.validation.ObjectError</code></li>
<li>Java Bean 属性错误描述：<code>org.springframework.validation.FieldError</code></li>
<li>Bean Validation 适配：<code>org.springframework.validation.beanvalidation.LocalValidatorFactoryBean</code></li>
</ul>
<h2 id="第十四章：Spring-数据绑定"><a href="#第十四章：Spring-数据绑定" class="headerlink" title="第十四章：Spring 数据绑定"></a>第十四章：Spring 数据绑定</h2><h3 id="Spring-数据绑定使用场景"><a href="#Spring-数据绑定使用场景" class="headerlink" title="Spring 数据绑定使用场景"></a>Spring 数据绑定使用场景</h3><ul>
<li>Spring BeanDefinition 到 Bean 实例创建</li>
<li>Spring 数据绑定（DataBinder）</li>
<li>Spring Web 参数绑定（WebDataBinder）</li>
</ul>
<h3 id="Spring-数据绑定组件"><a href="#Spring-数据绑定组件" class="headerlink" title="Spring 数据绑定组件"></a>Spring 数据绑定组件</h3><ul>
<li>标准组件<ul>
<li><code>org.springframework.validation.DataBinder</code></li>
</ul>
</li>
<li>Web 组件<ul>
<li><code>org.springframework.web.bind.WebDataBinder</code></li>
<li><code>org.springframework.web.bind.ServletRequestDataBinder</code></li>
<li><code>org.springframework.web.bind.support.WebRequestDataBinder</code></li>
<li><code>org.springframework.web.bind.support.WebExchangeDataBinder</code>（since 5.0）</li>
</ul>
</li>
</ul>
<h4 id="DataBinder-核心属性"><a href="#DataBinder-核心属性" class="headerlink" title="DataBinder 核心属性"></a>DataBinder 核心属性</h4><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>target</td><td>关联目标 Bean</td></tr><tr><td>objectName</td><td>目标 Bean 名称</td></tr><tr><td>bindingResult</td><td>属性绑定结果</td></tr><tr><td>typeConverter</td><td>类型转换器</td></tr><tr><td>conversionService</td><td>类型转换服务</td></tr><tr><td>messageCodesResolver</td><td>校验错误文案 Code 处理器</td></tr><tr><td>validators</td><td>关联的 Bean Validator 实例集合</td></tr></tbody></table>

<h4 id="DataBinder-绑定方法"><a href="#DataBinder-绑定方法" class="headerlink" title="DataBinder 绑定方法"></a>DataBinder 绑定方法</h4><ul>
<li><code>bind(PropertyValues)</code>：将 <code>PropertyValues</code> Key-Value 内容映射到关联 Bean（target）中的属性上</li>
<li>假设 <code>PropertyValues</code> 中包含 “name = 小马哥” 的键值对，同时 Bean 对象 User 中存在 name 属性，当 bind 方法执行时，User 对象中的 name 属性值将被绑定为 “小马哥”</li>
</ul>
<h3 id="Spring-数据绑定元数据"><a href="#Spring-数据绑定元数据" class="headerlink" title="Spring 数据绑定元数据"></a>Spring 数据绑定元数据</h3><p><code>DataBinder</code> 元数据 - <code>PropertyValues</code></p>
<table><thead><tr><th>特征</th><th>说明</th></tr></thead><tbody><tr><td>数据来源</td><td>BeanDefinition，主要来源 XML 资源配置 BeanDefinition</td></tr><tr><td>数据结构</td><td>由一个或多个 PropertyValue 组成</td></tr><tr><td>成员结构</td><td>PropertyValue 包含属性名称，以及属性值（包括原始值、类型转换后的值）</td></tr><tr><td>常见实现</td><td>MutablePropertyValues</td></tr><tr><td>Web 扩展实现</td><td>ServletConfigPropertyValues、ServletRequestParameterPropertyValues</td></tr><tr><td>相关生命周期</td><td>InstantiationAwareBeanPostProcessor#postProcessProperties</td></tr></tbody></table>

<h3 id="Spring-数据绑定控制参数"><a href="#Spring-数据绑定控制参数" class="headerlink" title="Spring 数据绑定控制参数"></a>Spring 数据绑定控制参数</h3><h4 id="DataBinder-绑定特殊场景分析"><a href="#DataBinder-绑定特殊场景分析" class="headerlink" title="DataBinder 绑定特殊场景分析"></a>DataBinder 绑定特殊场景分析</h4><ul>
<li>当 <code>PropertyValues</code> 中包含名称 x 的 <code>PropertyValue</code>，目标对象 B 不存在 x 属性，当 bind 方法执行时，会发生什么？<ul>
<li>默认忽略未知的属性，<code>ignoreUnknownFields</code></li>
</ul>
</li>
<li>当 <code>PropertyValues</code> 中包含名称 x 的 <code>PropertyValue</code>，目标对象 B 中存在 x 属性，当 bind 方法执行时，如何避免 B 属性 x 不被绑定？<ul>
<li>设置 <code>disallowedFields</code> 属性</li>
</ul>
</li>
<li>当 <code>PropertyValues</code> 中包含名称 x.y 的 <code>PropertyValue</code>，目标对象 B 中存在 x 属性（嵌套 y 属性），当 bind 方法执行时，会发生什么？<ul>
<li>默认支持嵌套属性，<code>autoGrowNestedPaths</code></li>
</ul>
</li>
</ul>
<h4 id="DataBinder-绑定控制参数"><a href="#DataBinder-绑定控制参数" class="headerlink" title="DataBinder 绑定控制参数"></a>DataBinder 绑定控制参数</h4><table><thead><tr><th>参数名称</th><th>说明</th></tr></thead><tbody><tr><td>ignoreUnknownFields</td><td>是否忽略未知字段，默认值：true</td></tr><tr><td>ignoreInvalidFields</td><td>是否忽略非法字段，默认值：false</td></tr><tr><td>autoGrowNestedPaths</td><td>是否自动增加嵌套路径，默认值：true</td></tr><tr><td>allowedFields</td><td>绑定字段白名单</td></tr><tr><td>disallowedFields</td><td>绑定字段黑名单</td></tr><tr><td>requiredFields</td><td>必须绑定字段</td></tr></tbody></table>

<h3 id="BeanWrapper-的使用场景"><a href="#BeanWrapper-的使用场景" class="headerlink" title="BeanWrapper 的使用场景"></a>BeanWrapper 的使用场景</h3><p>BeanWrapper</p>
<ul>
<li>Spring 底层 JavaBeans 基础设施的中心化接口</li>
<li>通常不会直接使用，间接用于 <code>BeanFactory</code> 和 <code>DataBinder</code></li>
<li>提供标准 JavaBeans 分析和操作，能够单独或批量存储 Java Bean 的属性（properties）</li>
<li>支持嵌套属性路径（nested path）</li>
<li>实现类 <code>org.springframework.beans.BeanWrapperImpl</code></li>
</ul>
<h3 id="Spring-底层-Java-Beans-替换实现"><a href="#Spring-底层-Java-Beans-替换实现" class="headerlink" title="Spring 底层 Java Beans 替换实现"></a>Spring 底层 Java Beans 替换实现</h3><ul>
<li>JavaBeans 核心实现 - <code>java.beans.BeanInfo</code><ul>
<li>属性（Property）<ul>
<li><code>java.beans.PropertyEditor</code></li>
</ul>
</li>
<li>方法（Method）</li>
<li>事件（Event）</li>
<li>表达式（Expression）</li>
</ul>
</li>
<li>Spring 替代实现 - <code>org.springframework.beans.BeanWrapper</code><ul>
<li>属性（Property）<ul>
<li><code>java.beans.PropertyEditor</code></li>
</ul>
</li>
<li>嵌套属性路径（nested path）</li>
</ul>
</li>
</ul>
<h3 id="课外资料-1"><a href="#课外资料-1" class="headerlink" title="课外资料"></a>课外资料</h3><p>标准 JavaBeans 是如何操作属性的？</p>
<table><thead><tr><th>API</th><th>说明</th></tr></thead><tbody><tr><td>java.beans.Introspector</td><td>JavaBeans 内省 API</td></tr><tr><td>java.beans.BeanInfo</td><td>JavaBeans 元信息 API</td></tr><tr><td>java.beans.BeanDescriptor JavaBeans</td><td>信息描述符</td></tr><tr><td>java.beans.PropertyDescriptor</td><td>JavaBeans 属性描述符</td></tr><tr><td>java.beans.MethodDescriptor</td><td>JavaBeans 方法描述符</td></tr><tr><td>java.beans.EventSetDescriptor</td><td>JavaBeans 事件集合描述符</td></tr></tbody></table>

<h3 id="DataBinder-数据校验"><a href="#DataBinder-数据校验" class="headerlink" title="DataBinder 数据校验"></a>DataBinder 数据校验</h3><ul>
<li><code>DataBinder</code> 与 <code>BeanWrapper</code><ul>
<li><code>bind</code> 方法生成 <code>BeanPropertyBindingResult</code></li>
<li><code>BeanPropertyBindingResult</code> 关联 <code>BeanWrapper</code></li>
</ul>
</li>
</ul>
<h3 id="面试题-5"><a href="#面试题-5" class="headerlink" title="面试题"></a>面试题</h3><h4 id="Spring-数据绑定-API-是什么？"><a href="#Spring-数据绑定-API-是什么？" class="headerlink" title="Spring 数据绑定 API 是什么？"></a>Spring 数据绑定 API 是什么？</h4><p><code>org.springframework.validation.DataBinder</code></p>
<h4 id="BeanWrapper-与-JavaBeans-之间关系是？"><a href="#BeanWrapper-与-JavaBeans-之间关系是？" class="headerlink" title="BeanWrapper 与 JavaBeans 之间关系是？"></a>BeanWrapper 与 JavaBeans 之间关系是？</h4><p>Spring 底层 JavaBeans 基础设施的中心化接口</p>
<h2 id="第十五章：Spring-类型转换"><a href="#第十五章：Spring-类型转换" class="headerlink" title="第十五章：Spring 类型转换"></a>第十五章：Spring 类型转换</h2><h3 id="Spring-类型转换的实现"><a href="#Spring-类型转换的实现" class="headerlink" title="Spring 类型转换的实现"></a>Spring 类型转换的实现</h3><ul>
<li>基于 JavaBeans 接口的类型转换实现<ul>
<li>基于 <code>java.beans.PropertyEditor</code> 接口扩展</li>
</ul>
</li>
<li>Spring 3.0+ 通用类型转换实现<ul>
<li><code>org.springframework.core.convert.converter.Converter</code></li>
<li><code>org.springframework.core.convert.converter.ConverterFactory</code></li>
<li><code>org.springframework.core.convert.ConversionService</code></li>
</ul>
</li>
</ul>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><table><thead><tr><th>场景</th><th>基于 JavaBeans 接口的类型转换实现</th><th>Spring 3.0+ 通用类型转换实现</th></tr></thead><tbody><tr><td>数据绑定</td><td>YES</td><td>YES</td></tr><tr><td>BeanWrapper</td><td>YES</td><td>YES</td></tr><tr><td>Bean 属性类型装换</td><td>YES</td><td>YES</td></tr><tr><td>外部化属性类型转换</td><td>NO</td><td>YES</td></tr></tbody></table>

<h3 id="基于-JavaBeans-接口的类型转换"><a href="#基于-JavaBeans-接口的类型转换" class="headerlink" title="基于 JavaBeans 接口的类型转换"></a>基于 JavaBeans 接口的类型转换</h3><ul>
<li>核心职责<ul>
<li>将 String 类型的内容转化为目标类型的对象</li>
</ul>
</li>
<li>扩展原理<ol>
<li>Spring 框架将文本内容传递到 <code>PropertyEditor</code> 实现的 <code>setAsText(String)</code> 方法</li>
<li><code>PropertyEditor#setAsText(String)</code> 方法实现将 String 类型转化为目标类型的对象</li>
<li>将目标类型的对象传入 <code>PropertyEditor#setValue(Object)</code> 方法</li>
<li><code>PropertyEditor#setValue(Object)</code> 方法实现需要临时存储传入对象</li>
<li>Spring 框架将通过 <code>PropertyEditor#getValue()</code> 获取类型转换后的对象</li>
</ol>
</li>
</ul>
<h3 id="Spring-內建-PropertyEditor-扩展"><a href="#Spring-內建-PropertyEditor-扩展" class="headerlink" title="Spring 內建 PropertyEditor 扩展"></a>Spring 內建 PropertyEditor 扩展</h3><p>內建扩展（<code>org.springframework.beans.propertyeditors</code> 包下）</p>
<table><thead><tr><th>转换场景</th><th>实现类</th></tr></thead><tbody><tr><td>String -&gt; Byte 数组</td><td><code>org.springframework.beans.propertyeditors.ByteArrayPropertyEditor</code></td></tr><tr><td>String -&gt; Char</td><td><code>org.springframework.beans.propertyeditors.CharacterEditor</code></td></tr><tr><td>String -&gt; Char 数组</td><td><code>org.springframework.beans.propertyeditors.CharArrayPropertyEditor</code></td></tr><tr><td>String -&gt; Charset</td><td><code>org.springframework.beans.propertyeditors.CharsetEditor</code></td></tr><tr><td>String -&gt; Class</td><td><code>org.springframework.beans.propertyeditors.ClassEditor</code></td></tr><tr><td>String -&gt; Currency</td><td><code>org.springframework.beans.propertyeditors.CurrencyEditor</code></td></tr></tbody></table>

<h3 id="自定义-PropertyEditor-扩展"><a href="#自定义-PropertyEditor-扩展" class="headerlink" title="自定义 PropertyEditor 扩展"></a>自定义 PropertyEditor 扩展</h3><ol>
<li>扩展模式<ul>
<li>扩展 <code>java.beans.PropertyEditorSupport</code> 类</li>
</ul>
</li>
<li>实现 <code>org.springframework.beans.PropertyEditorRegistrar</code><ul>
<li>实现 <code>registerCustomEditors(org.springframework.beans.PropertyEditorRegistry)</code> 方法</li>
<li>将 <code>PropertyEditorRegistrar</code> 实现注册为 Spring Bean</li>
<li>声明 <code>org.springframework.beans.factory.config.CustomEditorConfigurer</code>，并将自定义 <code>PropertyEditorRegistrar</code> 加入属性 <code>propertyEditorRegistrars</code></li>
</ul>
</li>
<li>向 <code>org.springframework.beans.PropertyEditorRegistry</code> 注册自定义 <code>PropertyEditor</code> 实现<ul>
<li>通用类型实现 <code>registerCustomEditor(Class&lt;?&gt;, PropertyEditor)</code></li>
<li>Java Bean 属性类型实现：<code>registerCustomEditor(Class&lt;?&gt;, String, PropertyEditor)</code></li>
</ul>
</li>
</ol>
<p>注意两个接口的不同：</p>
<ul>
<li><code>org.springframework.beans.PropertyEditorRegistrar</code></li>
<li><code>org.springframework.beans.PropertyEditorRegistry</code></li>
</ul>
<p>相关的两个类：</p>
<ul>
<li><code>java.beans.PropertyEditor</code></li>
<li><code>java.beans.PropertyEditorSupport</code></li>
</ul>
<h3 id="Spring-PropertyEditor-的设计缺陷"><a href="#Spring-PropertyEditor-的设计缺陷" class="headerlink" title="Spring PropertyEditor 的设计缺陷"></a>Spring PropertyEditor 的设计缺陷</h3><ul>
<li>违反职责单一原则<ul>
<li><code>java.beans.PropertyEditor</code> 接口职责太多，除了类型转换，还包括 Java Beans 事件和 Java GUI 交互</li>
</ul>
</li>
<li><code>java.beans.PropertyEditor</code> 实现类型局限<ul>
<li>来源类型只能为 <code>java.lang.String</code> 类型</li>
</ul>
</li>
<li><code>java.beans.PropertyEditor</code> 实现缺少类型安全<ul>
<li>除了实现类命名可以表达语义，实现类无法感知目标转换类型</li>
</ul>
</li>
</ul>
<h3 id="Spring-3-通用类型转换接口"><a href="#Spring-3-通用类型转换接口" class="headerlink" title="Spring 3 通用类型转换接口"></a>Spring 3 通用类型转换接口</h3><ul>
<li>类型转换接口 - <code>org.springframework.core.convert.converter.Converter&lt;S,T&gt;</code><ul>
<li>泛型参数 S：来源类型，参数 T：目标类型</li>
<li>核心方法：T convert(S)</li>
</ul>
</li>
<li>通用类型转换接口 - <code>org.springframework.core.convert.converter.GenericConverter</code><ul>
<li>核心方法：<code>convert(Object,TypeDescriptor,TypeDescriptor)</code></li>
<li>配对类型：<code>org.springframework.core.convert.converter.GenericConverter.ConvertiblePair</code></li>
<li>类型描述：<code>org.springframework.core.convert.TypeDescriptor</code></li>
</ul>
</li>
</ul>
<h3 id="Spring-內建类型转换器"><a href="#Spring-內建类型转换器" class="headerlink" title="Spring 內建类型转换器"></a>Spring 內建类型转换器</h3><table><thead><tr><th>转换场景</th><th>实现类所在包名（package）</th></tr></thead><tbody><tr><td>日期 / 时间相关</td><td><code>org.springframework.format.datetime</code></td></tr><tr><td>Java 8 日期 / 时间相关</td><td><code>org.springframework.format.datetime.standard</code></td></tr><tr><td>通用实现</td><td><code>org.springframework.core.convert.support</code></td></tr></tbody></table>

<h3 id="Converter-接口的局限性"><a href="#Converter-接口的局限性" class="headerlink" title="Converter 接口的局限性"></a>Converter 接口的局限性</h3><ul>
<li>局限一：缺少 Source Type 和 Target Type 前置判断<ul>
<li>应对：增加 <code>org.springframework.core.convert.converter.ConditionalConverter</code> 实现<ul>
<li>判断泛型相关的类<ul>
<li><code>org.springframework.core.convert.TypeDescriptor</code></li>
<li><code>org.springframework.core.ResolvableType</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>局限二：仅能转换单一的 Source Type 和 Target Type，不支持复合类型（比如 Collection、Map、数组等）<ul>
<li>应对：使用 <code>org.springframework.core.convert.converter.GenericConverter</code> 代替</li>
</ul>
</li>
</ul>
<h3 id="GenericConverter-接口"><a href="#GenericConverter-接口" class="headerlink" title="GenericConverter 接口"></a>GenericConverter 接口</h3><p><code>org.springframework.core.convert.converter.GenericConverter</code></p>
<table><thead><tr><th>核心要素</th><th>说明</th></tr></thead><tbody><tr><td>使用场景</td><td>用于 “复合” 类型转换场景，比如 Collection、Map、数组等</td></tr><tr><td>转换范围</td><td><code>Set&lt;ConvertiblePair&gt; getConvertibleTypes()</code></td></tr><tr><td>配对类型</td><td><code>org.springframework.core.convert.converter.GenericConverter.ConvertiblePair</code></td></tr><tr><td>转换方法</td><td><code>convert(Object,TypeDescriptor,TypeDescriptor)</code></td></tr><tr><td>类型描述</td><td><code>org.springframework.core.convert.TypeDescriptor</code></td></tr></tbody></table>

<p><code>GenericConverter</code> 接口处理复合类型，<code>Converter</code> 接口处理简单类型，两者可以相互配合</p>
<h3 id="优化-GenericConverter-接口"><a href="#优化-GenericConverter-接口" class="headerlink" title="优化 GenericConverter 接口"></a>优化 GenericConverter 接口</h3><ul>
<li><code>GenericConverter</code> 局限性<ul>
<li>缺少 Source Type 和 Target Type 前置判断</li>
<li>单一类型转换实现复杂</li>
</ul>
</li>
<li>GenericConverter 优化接口 - <code>ConditionalGenericConverter</code><ul>
<li>复合类型转换：<code>org.springframework.core.convert.converter.GenericConverter</code></li>
<li>类型条件判断：<code>org.springframework.core.convert.converter.ConditionalConverter</code></li>
</ul>
</li>
</ul>
<h3 id="扩展-Spring-类型转换器"><a href="#扩展-Spring-类型转换器" class="headerlink" title="扩展 Spring 类型转换器"></a>扩展 Spring 类型转换器</h3><ul>
<li>实现转换器接口<ul>
<li><code>org.springframework.core.convert.converter.Converter</code></li>
<li><code>org.springframework.core.convert.converter.ConverterFactory</code></li>
<li><code>org.springframework.core.convert.converter.GenericConverter</code></li>
</ul>
</li>
<li>注册转换器实现<ul>
<li>通过 <code>ConversionServiceFactoryBean</code> Spring Bean<ul>
<li>声明名称为 <code>conversionService</code> 的 <code>ConversionServiceFactoryBean</code></li>
<li>将自定义 <code>Converter</code> 传入属性 <code>converters</code></li>
</ul>
</li>
<li>通过 <code>org.springframework.core.convert.ConversionService</code> API</li>
</ul>
</li>
</ul>
<h3 id="统一类型转换服务"><a href="#统一类型转换服务" class="headerlink" title="统一类型转换服务"></a>统一类型转换服务</h3><ul>
<li><code>org.springframework.core.convert.ConversionService</code></li>
</ul>
<table><thead><tr><th>实现类型</th><th>说明</th></tr></thead><tbody><tr><td><code>GenericConversionService</code></td><td>通用 <code>ConversionService</code> 模板实现，不内置转化器实现</td></tr><tr><td><code>DefaultConversionService</code></td><td>基础 <code>ConversionService</code> 实现，内置常用转化器实现</td></tr><tr><td><code>FormattingConversionService</code></td><td>通用 <code>Formatter</code> + <code>GenericConversionService</code> 实现，不内置转化器和 <code>Formatter</code> 实现</td></tr><tr><td><code>DefaultFormattingConversionService</code></td><td><code>DefaultConversionService</code> + 格式化 实现（如：JSR-354 Money &amp; Currency, JSR-310 Date-Time）</td></tr></tbody></table>

<h3 id="ConversionService-作为依赖"><a href="#ConversionService-作为依赖" class="headerlink" title="ConversionService 作为依赖"></a>ConversionService 作为依赖</h3><ul>
<li><p>类型转换器底层接口 - <code>org.springframework.beans.TypeConverter</code></p>
<ul>
<li>起始版本：Spring 2.0</li>
<li>核心方法 - <code>convertIfNecessary</code> 重载方法</li>
<li>抽象实现 - <code>org.springframework.beans.TypeConverterSupport</code></li>
<li>简单实现 - <code>org.springframework.beans.SimpleTypeConverter</code></li>
</ul>
</li>
<li><p>类型转换器底层抽象实现 - <code>org.springframework.beans.TypeConverterSupport</code></p>
<ul>
<li>实现接口 - <code>org.springframework.beans.TypeConverter</code></li>
<li>扩展实现 - <code>org.springframework.beans.PropertyEditorRegistrySupport</code></li>
<li>委派实现 - <code>org.springframework.beans.TypeConverterDelegate</code></li>
</ul>
</li>
<li><p>类型转换器底层委派实现 - <code>org.springframework.beans.TypeConverterDelegate</code></p>
<ul>
<li>构造来源 - <code>org.springframework.beans.AbstractNestablePropertyAccessor</code> 实现<ul>
<li><code>org.springframework.beans.BeanWrapperImpl</code></li>
</ul>
</li>
<li>依赖 - <code>java.beans.PropertyEditor</code> 实现<ul>
<li>默认內建实现 - <code>PropertyEditorRegistrySupport#registerDefaultEditors</code></li>
</ul>
</li>
<li>可选依赖 - <code>org.springframework.core.convert.ConversionService</code> 实现</li>
</ul>
</li>
</ul>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">整体流程：<br><span class="hljs-regexp">//</span> AbstractApplicationContext -&gt; <span class="hljs-string">&quot;conversionService&quot;</span> ConversionService Bean<br><span class="hljs-regexp">//</span> -&gt; ConfigurableBeanFactory<span class="hljs-comment">#setConversionService(ConversionService)</span><br><span class="hljs-regexp">//</span> -&gt; AbstractAutowireCapableBeanFactory.instantiateBean<br><span class="hljs-regexp">//</span> -&gt; AbstractBeanFactory<span class="hljs-comment">#getConversionService -&gt;</span><br><span class="hljs-regexp">//</span> BeanDefinition -&gt; BeanWrapper -&gt; 属性转换（数据来源：PropertyValues）-&gt;<br><span class="hljs-regexp">//</span> setPropertyValues(PropertyValues) -&gt; TypeConverter<span class="hljs-comment">#convertIfNecessnary</span><br><span class="hljs-regexp">//</span> TypeConverterDelegate<span class="hljs-comment">#convertIfNecessnary  -&gt; PropertyEditor or ConversionService</span><br></code></pre></td></tr></table></figure>

<h3 id="面试题-6"><a href="#面试题-6" class="headerlink" title="面试题"></a>面试题</h3><h4 id="Spring-类型转换实现有哪些？"><a href="#Spring-类型转换实现有哪些？" class="headerlink" title="Spring 类型转换实现有哪些？"></a>Spring 类型转换实现有哪些？</h4><ol>
<li>基于 JavaBeans PropertyEditor 接口实现</li>
<li>Spring 3.0+ 通用类型转换实现</li>
</ol>
<h4 id="Spring-类型转换器接口有哪些？"><a href="#Spring-类型转换器接口有哪些？" class="headerlink" title="Spring 类型转换器接口有哪些？"></a>Spring 类型转换器接口有哪些？</h4><ul>
<li>类型转换接口 - <code>org.springframework.core.convert.converter.Converter</code></li>
<li>通用类型转换接口 - <code>org.springframework.core.convert.converter.GenericConverter</code></li>
<li>类型条件接口 - <code>org.springframework.core.convert.converter.ConditionalConverter</code></li>
<li>综合类型转换接口 -<br><code>org.springframework.core.convert.converter.ConditionalGenericConverter</code></li>
</ul>
<h2 id="第十六章：Spring-泛型处理"><a href="#第十六章：Spring-泛型处理" class="headerlink" title="第十六章：Spring 泛型处理"></a>第十六章：Spring 泛型处理</h2><h3 id="Java-泛型基础"><a href="#Java-泛型基础" class="headerlink" title="Java 泛型基础"></a>Java 泛型基础</h3><ul>
<li><p>泛型类型</p>
<ul>
<li>泛型类型是在类型上参数化的泛型类或接口</li>
</ul>
</li>
<li><p>泛型使用场景</p>
<ul>
<li>编译时强类型检查</li>
<li>避免类型强转</li>
<li>实现通用算法</li>
</ul>
</li>
<li><p>泛型类型擦写</p>
<ul>
<li>泛型被引入到 Java 语言中，以便在<strong>编译时</strong>提供更严格的类型检查并支持泛型编程。类型擦除确保不会为参数化类型创建新类；因此，泛型不会产生运行时开销。为了实现泛型，编译器将类型擦除应用于：<ul>
<li>将泛型类型中的所有类型参数替换为其边界，如果类型参数是无边界的，则将其替换为 <code>Object</code>。因此，生成的字节码只包含普通类、接口和方法。</li>
<li>必要时插入类型转换以保持类型安全。</li>
<li>生成桥方法以保留扩展泛型类型中的多态性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Java-5-类型接口"><a href="#Java-5-类型接口" class="headerlink" title="Java 5 类型接口"></a>Java 5 类型接口</h3><h4 id="Java-5-类型接口-java-lang-reflect-Type"><a href="#Java-5-类型接口-java-lang-reflect-Type" class="headerlink" title="Java 5 类型接口 - java.lang.reflect.Type"></a>Java 5 类型接口 - <code>java.lang.reflect.Type</code></h4><table><thead><tr><th>派生类或接口</th><th>说明</th></tr></thead><tbody><tr><td><code>java.lang.Class</code></td><td>Java 类 API，如 <code>java.lang.String</code></td></tr><tr><td><code>java.lang.reflect.GenericArrayType</code></td><td>泛型数组类型</td></tr><tr><td><code>java.lang.reflect.ParameterizedType</code></td><td>泛型参数类型</td></tr><tr><td><code>java.lang.reflect.TypeVariable</code></td><td>泛型类型变量，如 <code>Collection&lt;E&gt;</code> 中的 <code>E</code></td></tr><tr><td><code>java.lang.reflect.WildcardType</code></td><td>泛型通配类型</td></tr></tbody></table>

<h4 id="Java-泛型反射-API"><a href="#Java-泛型反射-API" class="headerlink" title="Java 泛型反射 API"></a>Java 泛型反射 API</h4><table><thead><tr><th>类型</th><th>API</th></tr></thead><tbody><tr><td>泛型信息（Generics Info）</td><td><code>java.lang.Class#getGenericInfo()</code></td></tr><tr><td>泛型参数（Parameters）</td><td><code>java.lang.reflect.ParameterizedType</code></td></tr><tr><td>泛型父类（Super Classes）</td><td><code>java.lang.Class#getGenericSuperclass()</code></td></tr><tr><td>泛型接口（Interfaces）</td><td><code>java.lang.Class#getGenericInterfaces()</code></td></tr><tr><td>泛型声明（Generics Declaration）</td><td><code>java.lang.reflect.GenericDeclaration</code></td></tr></tbody></table>

<h3 id="Spring-泛型类型辅助类"><a href="#Spring-泛型类型辅助类" class="headerlink" title="Spring 泛型类型辅助类"></a>Spring 泛型类型辅助类</h3><p>核心 API - <code>org.springframework.core.GenericTypeResolver</code></p>
<ul>
<li>版本支持：[2.5.2 ,)</li>
<li>处理类型相关（Type）相关方法<ul>
<li><code>resolveReturnType</code><ul>
<li>返回给定方法的返回类型</li>
</ul>
</li>
<li><code>resolveType</code></li>
</ul>
</li>
<li>处理泛型参数类型（ParameterizedType）相关方法<ul>
<li><code>resolveReturnTypeArgument</code><ul>
<li>返回给定方法返回类型的泛型参数类型</li>
</ul>
</li>
<li><code>resolveTypeArgument</code></li>
<li><code>resolveTypeArguments</code></li>
</ul>
</li>
<li>处理泛型类型变量（TypeVariable）相关方法<ul>
<li><code>getTypeVariableMap</code></li>
</ul>
</li>
</ul>
<h3 id="Spring-泛型集合类型辅助类"><a href="#Spring-泛型集合类型辅助类" class="headerlink" title="Spring 泛型集合类型辅助类"></a>Spring 泛型集合类型辅助类</h3><p>核心 API - <code>org.springframework.core.GenericCollectionTypeResolver</code></p>
<ul>
<li>版本支持：[2.0 , 4.3]</li>
<li>替换实现：<code>org.springframework.core.ResolvableType</code></li>
<li>处理 Collection 相关<ul>
<li><code>getCollection*Type</code></li>
</ul>
</li>
<li>处理 Map 相关<ul>
<li><code>getMapKey*Type</code></li>
<li><code>getMapValue*Type</code></li>
</ul>
</li>
</ul>
<h3 id="Spring-方法参数封装"><a href="#Spring-方法参数封装" class="headerlink" title="Spring 方法参数封装"></a>Spring 方法参数封装</h3><p>核心 API - <code>org.springframework.core.MethodParameter</code></p>
<ul>
<li>起始版本：[2.0 ,)</li>
<li>元信息<ul>
<li>关联的方法 - <code>Method</code></li>
<li>关联的构造器 - <code>Constructor</code></li>
<li>构造器或方法参数索引 - <code>parameterIndex</code></li>
<li>构造器或方法参数类型 - <code>parameterType</code></li>
<li>构造器或方法参数泛型类型 - <code>genericParameterType</code></li>
<li>构造器或方法参数参数名称 - <code>parameterName</code></li>
<li>所在的类 - <code>containingClass</code></li>
</ul>
</li>
</ul>
<p><code>Method</code> 和 <code>Constructor</code> 二选一</p>
<p><code>MethodParameter</code> 可以表示方法参数、构造器参数、返回类型</p>
<h3 id="Spring-4-0-泛型优化实现-ResolvableType"><a href="#Spring-4-0-泛型优化实现-ResolvableType" class="headerlink" title="Spring 4.0 泛型优化实现 - ResolvableType"></a>Spring 4.0 泛型优化实现 - ResolvableType</h3><p>核心 API - <code>org.springframework.core.ResolvableType</code></p>
<ul>
<li>起始版本：[4.0 ,)</li>
<li>扮演角色：<code>GenericTypeResolver</code> 和 <code>GenericCollectionTypeResolver</code> 替代者</li>
<li>工厂方法：<code>for*</code> 方法</li>
<li>转换方法：<code>as*</code> 方法</li>
<li>处理方法：<code>resolve*</code> 方法</li>
</ul>
<h3 id="ResolvableType-的局限性"><a href="#ResolvableType-的局限性" class="headerlink" title="ResolvableType 的局限性"></a>ResolvableType 的局限性</h3><ul>
<li>局限一：<code>ResolvableType</code> 无法处理泛型擦写</li>
<li>局限二：<code>ResolvableType</code> 无法处理非具体化的 <code>ParameterizedType</code></li>
</ul>
<h3 id="面试题-7"><a href="#面试题-7" class="headerlink" title="面试题"></a>面试题</h3><h4 id="Java-泛型擦写发生在编译时还是运行时？"><a href="#Java-泛型擦写发生在编译时还是运行时？" class="headerlink" title="Java 泛型擦写发生在编译时还是运行时？"></a>Java 泛型擦写发生在编译时还是运行时？</h4><p>运行时</p>
<h4 id="请介绍-Java-5-Type-类型的派生类或接口？"><a href="#请介绍-Java-5-Type-类型的派生类或接口？" class="headerlink" title="请介绍 Java 5 Type 类型的派生类或接口？"></a>请介绍 Java 5 Type 类型的派生类或接口？</h4><ul>
<li><code>java.lang.Class</code></li>
<li><code>java.lang.reflect.GenericArrayType</code></li>
<li><code>java.lang.reflect.ParameterizedType</code></li>
<li><code>java.lang.reflect.TypeVariable</code></li>
<li><code>java.lang.reflect.WildcardType</code></li>
</ul>
<h4 id="请说明-ResolvableType-的设计优势？"><a href="#请说明-ResolvableType-的设计优势？" class="headerlink" title="请说明 ResolvableType 的设计优势？"></a>请说明 ResolvableType 的设计优势？</h4><ul>
<li>简化 Java 5 Type API 开发，屏蔽复杂 API 的运用，如 <code>ParameterizedType</code></li>
<li>不变性设计（Immutability）</li>
<li>Fluent API 设计（Builder 模式），链式（流式）编程</li>
</ul>
<h2 id="第十七章：Spring-事件"><a href="#第十七章：Spring-事件" class="headerlink" title="第十七章：Spring 事件"></a>第十七章：Spring 事件</h2><h3 id="Java-事件-监听器编程模型"><a href="#Java-事件-监听器编程模型" class="headerlink" title="Java 事件 / 监听器编程模型"></a>Java 事件 / 监听器编程模型</h3><ul>
<li>设计模式 - 观察者模式扩展<ul>
<li>可观者对象（消息发送者）- <code>java.util.Observable</code></li>
<li>观察者 - <code>java.util.Observer</code></li>
</ul>
</li>
<li>标准化接口<ul>
<li>事件对象 - <code>java.util.EventObject</code></li>
<li>事件监听器 - <code>java.util.EventListener</code></li>
</ul>
</li>
</ul>
<h3 id="面向接口的事件-监听器设计模式"><a href="#面向接口的事件-监听器设计模式" class="headerlink" title="面向接口的事件 / 监听器设计模式"></a>面向接口的事件 / 监听器设计模式</h3><p>事件 / 监听器场景举例</p>
<table><thead><tr><th>Java 技术规范</th><th>事件接口</th><th>监听器接口</th></tr></thead><tbody><tr><td>JavaBeans</td><td><code>java.beans.PropertyChangeEvent</code></td><td><code>java.beans.PropertyChangeListener</code></td></tr><tr><td>Java AWT</td><td><code>java.awt.event.MouseEvent</code></td><td><code>java.awt.event.MouseListener</code></td></tr><tr><td>Java Swing</td><td><code>javax.swing.event.MenuEvent</code></td><td><code>javax.swing.event.MenuListener</code></td></tr><tr><td>Java Preference</td><td><code>java.util.prefs.PreferenceChangeEvent</code></td><td><code>java.util.prefs.PreferenceChangeListener</code></td></tr></tbody></table>

<h3 id="面向注解的事件-监听器设计模式"><a href="#面向注解的事件-监听器设计模式" class="headerlink" title="面向注解的事件 / 监听器设计模式"></a>面向注解的事件 / 监听器设计模式</h3><p>事件 / 监听器注解场景举例</p>
<table><thead><tr><th>Java 技术规范</th><th>事件注解</th><th>监听器注解</th></tr></thead><tbody><tr><td>Servlet 3.0+</td><td></td><td><code>@javax.servlet.annotation.WebListener</code></td></tr><tr><td>JPA 1.0+</td><td><code>@javax.persistence.PostPersist</code></td><td></td></tr><tr><td>Java Common</td><td><code>@PostConstruct</code></td><td></td></tr><tr><td>EJB 3.0+</td><td><code>@javax.ejb.PrePassivate</code></td><td></td></tr><tr><td>JSF 2.0+</td><td><code>@javax.faces.event.ListenerFor</code></td><td></td></tr></tbody></table>

<h3 id="Spring-标准事件-ApplicationEvent"><a href="#Spring-标准事件-ApplicationEvent" class="headerlink" title="Spring 标准事件 - ApplicationEvent"></a>Spring 标准事件 - ApplicationEvent</h3><ul>
<li><code>org.springframework.context.ApplicationEvent</code></li>
<li>Java 标准事件 <code>java.util.EventObject</code> 扩展<ul>
<li>扩展特性：事件发生时间戳</li>
</ul>
</li>
<li>Spring 应用上下文 <code>ApplicationEvent</code> 扩展 - <code>ApplicationContextEvent</code><ul>
<li><code>org.springframework.context.event.ApplicationContextEvent</code></li>
<li>Spring 应用上下文（ApplicationContext）作为事件源</li>
<li>具体实现：<ul>
<li><code>org.springframework.context.event.ContextClosedEvent</code></li>
<li><code>org.springframework.context.event.ContextRefreshedEvent</code></li>
<li><code>org.springframework.context.event.ContextStartedEvent</code></li>
<li><code>org.springframework.context.event.ContextStoppedEvent</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/hr6dKQi4GCZHD9f.png" srcset="/img/loading.gif" alt=""></p>
<h3 id="基于接口的-Spring-事件监听器"><a href="#基于接口的-Spring-事件监听器" class="headerlink" title="基于接口的 Spring 事件监听器"></a>基于接口的 Spring 事件监听器</h3><p>Java 标准事件监听器 <code>java.util.EventListener</code> 扩展</p>
<ul>
<li>扩展接口 - <code>org.springframework.context.ApplicationListener</code></li>
<li>设计特点：单一类型事件处理</li>
<li>处理方法：<code>onApplicationEvent(ApplicationEvent)</code></li>
<li>事件类型：<code>org.springframework.context.ApplicationEvent</code></li>
</ul>
<h3 id="基于注解的-Spring-事件监听器"><a href="#基于注解的-Spring-事件监听器" class="headerlink" title="基于注解的 Spring 事件监听器"></a>基于注解的 Spring 事件监听器</h3><p>Spring 注解 - <code>@org.springframework.context.event.EventListener</code></p>
<table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>设计特点</td><td>支持多 <code>ApplicationEvent</code> 类型，无需接口约束</td></tr><tr><td>注解目标</td><td>方法</td></tr><tr><td>是否支持异步执行</td><td>支持</td></tr><tr><td>是否支持泛型类型事件</td><td>支持</td></tr><tr><td>是指支持顺序控制</td><td>支持，配合 <code>@Order</code> 注解控制</td></tr></tbody></table>

<h3 id="注册-Spring-ApplicationListener"><a href="#注册-Spring-ApplicationListener" class="headerlink" title="注册 Spring ApplicationListener"></a>注册 Spring ApplicationListener</h3><ul>
<li>基于 Spring 接口：向 Spring 应用上下文注册事件<ul>
<li><code>ApplicationListener</code> 作为 Spring Bean 注册</li>
<li>通过 <code>ConfigurableApplicationContext#addApplicationListener</code> API 注册</li>
</ul>
</li>
<li>基于 Spring 注解：<code>@org.springframework.context.event.EventListener</code></li>
</ul>
<h3 id="Spring-事件发布器"><a href="#Spring-事件发布器" class="headerlink" title="Spring 事件发布器"></a>Spring 事件发布器</h3><ul>
<li>方法一：通过 <code>ApplicationEventPublisher</code> 发布 Spring 事件<ul>
<li>获取 ApplicationEventPublisher<ul>
<li>依赖注入</li>
</ul>
</li>
</ul>
</li>
<li>方法二：通过 <code>ApplicationEventMulticaster</code> 发布 Spring 事件<ul>
<li>获取 <code>ApplicationEventMulticaster</code><ul>
<li>依赖注入</li>
<li>依赖查找</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Spring-层次性上下文事件传播"><a href="#Spring-层次性上下文事件传播" class="headerlink" title="Spring 层次性上下文事件传播"></a>Spring 层次性上下文事件传播</h3><ul>
<li>发生说明<ul>
<li>当 Spring 应用出现多层次 Spring 应用上下文（ApplicationContext）时，如 Spring WebMVC、Spring Boot 或 Spring Cloud 场景下，由子 <code>ApplicationContext</code> 发起 Spring 事件可能会传递到其 Parent <code>ApplicationContext</code>（直到 Root）的过程</li>
</ul>
</li>
<li>如何避免<ul>
<li>定位 Spring 事件源（ApplicationContext）进行过滤处理</li>
</ul>
</li>
</ul>
<h3 id="Spring-内建事件"><a href="#Spring-内建事件" class="headerlink" title="Spring 内建事件"></a>Spring 内建事件</h3><p><code>ApplicationContextEvent</code> 派生事件</p>
<ul>
<li><code>ContextRefreshedEvent</code> ：Spring 应用上下文就绪事件</li>
<li><code>ContextStartedEvent</code> ：Spring 应用上下文启动事件</li>
<li><code>ContextStoppedEvent</code> ：Spring 应用上下文停止事件</li>
<li><code>ContextClosedEvent</code> ：Spring 应用上下文关闭事件</li>
</ul>
<h3 id="Spring-4-2-Payload-事件"><a href="#Spring-4-2-Payload-事件" class="headerlink" title="Spring 4.2 Payload 事件"></a>Spring 4.2 Payload 事件</h3><p>Spring Payload 事件 - <code>org.springframework.context.PayloadApplicationEvent</code></p>
<ul>
<li><p>使用场景：简化 Spring 事件发送，关注事件源主体</p>
</li>
<li><p>发送方法</p>
<ul>
<li><code>ApplicationEventPublisher#publishEvent(java.lang.Object)</code></li>
</ul>
</li>
</ul>
<h3 id="自定义-Spring-事件"><a href="#自定义-Spring-事件" class="headerlink" title="自定义 Spring 事件"></a>自定义 Spring 事件</h3><ol>
<li>扩展 <code>org.springframework.context.ApplicationEvent</code></li>
<li>实现 <code>org.springframework.context.ApplicationListener</code></li>
<li>将 <code>org.springframework.context.ApplicationListener</code> 注册到容器内</li>
</ol>
<h3 id="依赖注入-ApplicationEventPublisher"><a href="#依赖注入-ApplicationEventPublisher" class="headerlink" title="依赖注入 ApplicationEventPublisher"></a>依赖注入 ApplicationEventPublisher</h3><ul>
<li>通过 <code>ApplicationEventPublisherAware</code> 回调接口</li>
<li>通过 <code>@Autowired ApplicationEventPublisher</code></li>
</ul>
<h3 id="依赖查找-ApplicationEventMulticaster"><a href="#依赖查找-ApplicationEventMulticaster" class="headerlink" title="依赖查找 ApplicationEventMulticaster"></a>依赖查找 ApplicationEventMulticaster</h3><ul>
<li>查找条件<ul>
<li>Bean 名称：<code>applicationEventMulticaster</code></li>
<li>Bean 类型：<code>org.springframework.context.event.ApplicationEventMulticaster</code></li>
</ul>
</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">AbstractApplicationContext</span><span class="hljs-selector-id">#earlyApplicationEvents</span> 在 <span class="hljs-selector-tag">prepareRefresh</span>() 中从 <span class="hljs-selector-tag">null</span> 被赋值，在 <span class="hljs-selector-tag">registerListeners</span>() 的最后，重新被赋值为 <span class="hljs-selector-tag">null</span>，并进行了早期事件的发布，<br>因为可能存在一个 <span class="hljs-selector-tag">Bean</span> 同时实现 <span class="hljs-selector-tag">BeanPostProcessor</span> 和 <span class="hljs-selector-tag">ApplicationEventPublisherAware</span>，并在 <span class="hljs-selector-tag">ApplicationEventPublisherAware</span><span class="hljs-selector-id">#setApplicationEventPublisher</span> 方法中发送事件<br>因为实现了 <span class="hljs-selector-tag">BeanPostProcessor</span>，所以这个 <span class="hljs-selector-tag">Bean</span> 在 <span class="hljs-selector-tag">registerBeanPostProcessors</span>(beanFactory); 这个方法中初始化，而此时 <span class="hljs-selector-tag">initApplicationEventMulticaster</span>(); 还没有执行，所以 <span class="hljs-selector-tag">AbstractApplicationContext</span><span class="hljs-selector-id">#applicationEventMulticaster</span> 为空，无法发布事件，所以先将事件保存在 <span class="hljs-selector-tag">AbstractApplicationContext</span><span class="hljs-selector-id">#earlyApplicationEvents</span> 中<br></code></pre></td></tr></table></figure>

<h3 id="ApplicationEventPublisher-底层实现"><a href="#ApplicationEventPublisher-底层实现" class="headerlink" title="ApplicationEventPublisher 底层实现"></a>ApplicationEventPublisher 底层实现</h3><ul>
<li>接口：<code>org.springframework.context.event.ApplicationEventMulticaster</code><ul>
<li>抽象类：<code>org.springframework.context.event.AbstractApplicationEventMulticaster</code><ul>
<li>实现类：<code>org.springframework.context.event.SimpleApplicationEventMulticaster</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="同步和异步-Spring-事件广播"><a href="#同步和异步-Spring-事件广播" class="headerlink" title="同步和异步 Spring 事件广播"></a>同步和异步 Spring 事件广播</h3><ul>
<li>基于实现类 - <code>org.springframework.context.event.SimpleApplicationEventMulticaster</code><ul>
<li>模式切换：<code>setTaskExecutor(java.util.concurrent.Executor)</code> 方法<ul>
<li>默认模式：同步</li>
<li>异步模式：如 <code>java.util.concurrent.ThreadPoolExecutor</code></li>
</ul>
</li>
<li>设计缺陷：不是基于接口契约编程，实现依赖于类本身</li>
</ul>
</li>
<li>基于注解 - <code>@org.springframework.context.event.EventListener</code><ul>
<li>模式切换<ul>
<li>默认模式：同步</li>
<li>异步模式：标注 <code>@org.springframework.scheduling.annotation.Async</code></li>
</ul>
</li>
<li>实现限制：无法直接实现同步 / 异步动态切换</li>
</ul>
</li>
</ul>
<p>区别：</p>
<ul>
<li>使用 <code>SimpleApplicationEventMulticaster#setTaskExecutor</code> 的影响是全局的，使用 <code>@Async</code> 是局部的</li>
<li>使用 <code>SimpleApplicationEventMulticaster#setTaskExecutor</code> 需要手动关闭线程池，使用 <code>@Async</code> 不需要</li>
</ul>
<h3 id="Spring-4-1-事件异常处理"><a href="#Spring-4-1-事件异常处理" class="headerlink" title="Spring 4.1 事件异常处理"></a>Spring 4.1 事件异常处理</h3><ul>
<li>Spring 3.0 错误处理接口 - <code>org.springframework.util.ErrorHandler</code></li>
<li>使用场景<ul>
<li>Spring 事件（Events）</li>
<li><code>SimpleApplicationEventMulticaster</code> Spring 4.1 开始支持</li>
<li>Spring 本地调度（Scheduling）<ul>
<li><code>org.springframework.scheduling.concurrent.ConcurrentTaskScheduler</code></li>
<li><code>org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Spring-事件-监听器实现原理"><a href="#Spring-事件-监听器实现原理" class="headerlink" title="Spring 事件 / 监听器实现原理"></a>Spring 事件 / 监听器实现原理</h3><ul>
<li>核心类 - <code>org.springframework.context.event.SimpleApplicationEventMulticaster</code><ul>
<li>设计模式：观察者模式扩展<ul>
<li>被观察者 - <code>org.springframework.context.ApplicationListener</code><ul>
<li>API 添加</li>
<li>依赖查找</li>
</ul>
</li>
<li>通知对象 - <code>org.springframework.context.ApplicationEvent</code></li>
</ul>
</li>
<li>执行模式：同步 / 异步</li>
<li>异常处理：<code>org.springframework.util.ErrorHandler</code></li>
<li>泛型处理：<code>org.springframework.core.ResolvableType</code></li>
</ul>
</li>
</ul>
<h3 id="课外资料-2"><a href="#课外资料-2" class="headerlink" title="课外资料"></a>课外资料</h3><h4 id="Spring-Boot-事件"><a href="#Spring-Boot-事件" class="headerlink" title="Spring Boot 事件"></a>Spring Boot 事件</h4><table><thead><tr><th>事件类型</th><th>发生时机</th></tr></thead><tbody><tr><td>ApplicationStartingEvent</td><td>当 Spring Boot 应用已启动时</td></tr><tr><td>ApplicationStartedEvent</td><td>当 Spring Boot 应用已启动时</td></tr><tr><td>ApplicationEnvironmentPreparedEvent</td><td>当 Spring Boot Environment 实例已准备时</td></tr><tr><td>ApplicationPreparedEvent</td><td>当 Spring Boot 应用预备时</td></tr><tr><td>ApplicationReadyEvent</td><td>当 Spring Boot 应用完全可用时</td></tr><tr><td>ApplicationFailedEvent</td><td>当 Spring Boot 应用启动失败时</td></tr></tbody></table>

<h4 id="Spring-Cloud-事件"><a href="#Spring-Cloud-事件" class="headerlink" title="Spring Cloud 事件"></a>Spring Cloud 事件</h4><table><thead><tr><th>事件类型</th><th>发生时机</th></tr></thead><tbody><tr><td>EnvironmentChangeEvent</td><td>当 Environment 示例配置属性发生变化时</td></tr><tr><td>HeartbeatEvent</td><td>当 Discoveryclient 客户端发送心跳时</td></tr><tr><td>InstancePreRegisteredEvent</td><td>当服务实例注册前</td></tr><tr><td>InstanceRegisteredEvent</td><td>当服务实例注册后</td></tr><tr><td>RefreshEvent</td><td>当 RefreshEndpoint 被调用时</td></tr><tr><td>RefreshScopeRefreshedEvent</td><td>当 Refresh Scope Bean 刷新后</td></tr></tbody></table>

<h3 id="面试题-8"><a href="#面试题-8" class="headerlink" title="面试题"></a>面试题</h3><h4 id="Spring-事件核心接口-组件？"><a href="#Spring-事件核心接口-组件？" class="headerlink" title="Spring 事件核心接口 / 组件？"></a>Spring 事件核心接口 / 组件？</h4><ul>
<li>Spring 事件 - <code>org.springframework.context.ApplicationEvent</code></li>
<li>Spring 事件监听器 - <code>org.springframework.context.ApplicationListener</code></li>
<li>Spring 事件发布器 - <code>org.springframework.context.ApplicationEventPublisher</code></li>
<li>Spring 事件广播器 - <code>org.springframework.context.event.ApplicationEventMulticaster</code></li>
</ul>
<h4 id="Spring-同步和异步事件处理的使用场景？"><a href="#Spring-同步和异步事件处理的使用场景？" class="headerlink" title="Spring 同步和异步事件处理的使用场景？"></a>Spring 同步和异步事件处理的使用场景？</h4><ul>
<li>Spring 同步事件 - 绝大多数 Spring 使用场景，如 <code>ContextRefreshedEvent</code></li>
<li>Spring 异步事件 - 主要 <code>@EventListener</code> 与 <code>@Async</code> 配合，实现异步处理，不阻塞主线程，比如长时间的数据计算任务等。不要轻易调整 <code>SimpleApplicationEventMulticaster</code> 中关联的 <code>taskExecutor</code> 对象，除非使用者非常了解 Spring 事件机制，否则容易出现异常行为。</li>
</ul>
<h2 id="第十八章：Spring-注解"><a href="#第十八章：Spring-注解" class="headerlink" title="第十八章：Spring 注解"></a>第十八章：Spring 注解</h2><h3 id="Spring-注解驱动编程发展历程"><a href="#Spring-注解驱动编程发展历程" class="headerlink" title="Spring 注解驱动编程发展历程"></a>Spring 注解驱动编程发展历程</h3><ul>
<li>注解驱动启蒙时代：Spring Framework 1.x<ul>
<li><code>@Transactional</code></li>
<li><code>@ManagedResource</code></li>
</ul>
</li>
<li>注解驱动过渡时代：Spring Framework 2.x<ul>
<li><code>@Component</code></li>
<li><code>@Repository</code></li>
<li><code>@Service</code></li>
<li><code>@Controller</code></li>
</ul>
</li>
<li>注解驱动黄金时代：Spring Framework 3.x<ul>
<li><code>@Bean</code></li>
<li><code>@Profile</code></li>
<li><code>@Import</code></li>
<li><code>@ImportResource</code></li>
<li><code>@ComponentScan</code></li>
<li><code>@Lazy</code></li>
<li><code>@PropertySource</code></li>
</ul>
</li>
<li>注解驱动完善时代：Spring Framework 4.x<ul>
<li><code>@Conditional</code></li>
</ul>
</li>
<li>注解驱动当下时代：Spring Framework 5.x<ul>
<li><code>@Indexed</code></li>
</ul>
</li>
</ul>
<h3 id="Spring-核心注解场景分类"><a href="#Spring-核心注解场景分类" class="headerlink" title="Spring 核心注解场景分类"></a>Spring 核心注解场景分类</h3><h4 id="Spring-模式注解-1"><a href="#Spring-模式注解-1" class="headerlink" title="Spring 模式注解"></a>Spring 模式注解</h4><table><thead><tr><th>Spring 注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td>@Repository</td><td>数据仓储模式注解</td><td>2.0</td></tr><tr><td>@Component</td><td>通用组件模式注解</td><td>2.5</td></tr><tr><td>@Service</td><td>服务模式注解</td><td>2.5</td></tr><tr><td>@Controller</td><td>Web 控制器模式注解</td><td>2.5</td></tr><tr><td>@Configuration</td><td>配置类模式注解</td><td>3.0</td></tr></tbody></table>

<h4 id="装配注解"><a href="#装配注解" class="headerlink" title="装配注解"></a>装配注解</h4><table><thead><tr><th>Spring 注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td>@lmportResource</td><td>替换 XML 元素 <code>&lt;import&gt;</code></td><td>2.5</td></tr><tr><td>@lmport</td><td>导入 Configuration 类</td><td>2.5</td></tr><tr><td>@ComponentScan</td><td>扫描指定 package 下标注 Spring 模式注解的类</td><td>3.1</td></tr></tbody></table>

<h4 id="依赖注入注解"><a href="#依赖注入注解" class="headerlink" title="依赖注入注解"></a>依赖注入注解</h4><table><thead><tr><th>Spring 注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td>@Autowired</td><td>Bean 依赖注入，支持多种依赖查找方式</td><td>2.5</td></tr><tr><td>@Qualifier</td><td>细粒度的 @Autowired 依赖查找</td><td>2.5</td></tr></tbody></table>

<h3 id="Spring-注解编程模型"><a href="#Spring-注解编程模型" class="headerlink" title="Spring 注解编程模型"></a>Spring 注解编程模型</h3><ul>
<li>编程模型</li>
<li>元注解（Meta-Annotations）</li>
<li>Spring 模式注解（Stereotype Annotations）</li>
<li>Spring 组合注解（Composed Annotations）</li>
<li>Spring 注解属性别名和覆盖（Attribute Aliases and Overrides）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework/wiki/Spring-Annotation-Programming-Model">Wiki</a></p>
<h4 id="Spring-元注解（Meta-Annotations）"><a href="#Spring-元注解（Meta-Annotations）" class="headerlink" title="Spring 元注解（Meta-Annotations）"></a>Spring 元注解（Meta-Annotations）</h4><ul>
<li><code>java.lang.annotation.Documented</code></li>
<li><code>java.lang.annotation.Inherited</code></li>
<li><code>java.lang.annotation.Repeatable</code></li>
</ul>
<h4 id="Spring-模式注解（Stereotype-An-notations）"><a href="#Spring-模式注解（Stereotype-An-notations）" class="headerlink" title="Spring 模式注解（Stereotype An notations）"></a>Spring 模式注解（Stereotype An notations）</h4><ul>
<li><p>理解 <code>@Component</code> “派生性”</p>
<ul>
<li>元标注 <code>@Component</code> 的注解在 XML 元素 <code>&lt;context:component-scan&gt;</code> 或注解 <code>@ComponentScan</code> 扫描中 “派生” 了 <code>@Component</code> 的特性，并且从 Spring Framework 4.0 开始支持多层次 ” 派生性 “。</li>
</ul>
</li>
<li><p>举例说明</p>
<ul>
<li><code>@Repository</code></li>
<li><code>@Service</code></li>
<li><code>@Controller</code></li>
<li><code>@Configuration</code></li>
<li><code>@SpringBootConfiguration</code> （Spring Boot）</li>
</ul>
</li>
<li><p><code>@Component</code> “派生性” 原理</p>
<ul>
<li>核心组件 - <code>org.springframework.context.annotation.ClassPathBeanDefinitionScanner</code><ul>
<li><code>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider</code></li>
</ul>
</li>
<li>资源处理 - <code>org.springframework.core.io.support.ResourcePatternResolver</code></li>
<li>资源 - 类元信息<ul>
<li><code>org.springframework.core.type.classreading.MetadataReaderFactory</code></li>
</ul>
</li>
<li>类元信息 - <code>org.springframework.core.type.ClassMetadata</code><ul>
<li>ASM 实现 - <code>org.springframework.core.type.classreading.ClassMetadataReadingVisitor</code></li>
<li>反射实现 - <code>org.springframework.core.type.StandardAnnotationMetadata</code></li>
</ul>
</li>
<li>注解元信息 - <code>org.springframework.core.type.AnnotationMetadata</code><ul>
<li>ASM 实现 - <code>org.springframework.core.type.classreading.AnnotationMetadataReadingVisitor</code></li>
<li>反射实现 - <code>org.springframework.core.type.StandardAnnotationMetadata</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>org.springframework.context.annotation.ComponentScanAnnotationParser</code></p>
</li>
</ul>
<h4 id="Spring-组合注解（Composed-Annotations）"><a href="#Spring-组合注解（Composed-Annotations）" class="headerlink" title="Spring 组合注解（Composed Annotations）"></a>Spring 组合注解（Composed Annotations）</h4><ul>
<li>基本定义<ul>
<li>Spring 组合注解（Composed Annotations）中的元注解允许是 Spring 模式注解（Stereotype Annotation）与 其他 Spring 功能性注解的任意组合。</li>
</ul>
</li>
</ul>
<p>相关类：</p>
<ul>
<li><code>org.springframework.context.annotation.ConfigurationClassParser</code></li>
<li><code>org.springframework.core.annotation.AnnotationAttributes</code></li>
</ul>
<h4 id="Spring-注解属性别名（Attribute-Aliases）"><a href="#Spring-注解属性别名（Attribute-Aliases）" class="headerlink" title="Spring 注解属性别名（Attribute Aliases）"></a>Spring 注解属性别名（Attribute Aliases）</h4><ul>
<li>显性别名：一个注解类中两个属性通过 <code>@AliasFor</code> 互相声明别名<ul>
<li><code>org.springframework.context.annotation.ComponentScan</code> 的 <code>value</code> 和 <code>basePackages</code></li>
</ul>
</li>
<li>隐形别名：通过在注解属性上 <code>@AliasFor</code> 元注解的属性<ul>
<li><code>org.springframework.boot.autoconfigure.SpringBootApplication</code> 的 <code>exclude</code> 、<code>excludeName</code></li>
</ul>
</li>
<li>传递隐式别名：给定一个批注中的两个或更多属性，它们通过 <code>@AliasFor</code> 声明为元注解中的属性的显式替代，如果这些属性有效地替代了元注解中的同一属性，则它们是可传递的隐式别名。</li>
</ul>
<h4 id="Spring-注解属性覆盖（Attribute-Overrides）"><a href="#Spring-注解属性覆盖（Attribute-Overrides）" class="headerlink" title="Spring 注解属性覆盖（Attribute Overrides）"></a>Spring 注解属性覆盖（Attribute Overrides）</h4><ul>
<li>隐式覆盖：注解中存在和元注解中名称相同的属性</li>
<li>显式覆盖：不同名称属性，使用 <code>@AliasFor</code> 声明为元注解属性的别名</li>
<li>传递显式覆盖：</li>
</ul>
<h3 id="Spring-Enable-模块驱动"><a href="#Spring-Enable-模块驱动" class="headerlink" title="Spring @Enable 模块驱动"></a>Spring @Enable 模块驱动</h3><ul>
<li><p>@Enable 模块驱动</p>
<ul>
<li>@Enable 模块驱动是以 <code>@Enable</code> 为前缀的注解驱动编程模型。所谓 “模块” 是指具备相同领域的功能组件集合，组合所形成一个独立的单元。比如 WebMVC 模块、AspectJ 代理模块、Caching （缓存）模块、JMX （Java 管理扩展）模块、Async （异步处理）模块等。</li>
</ul>
</li>
<li><p>举例说明</p>
<ul>
<li><code>@EnableWebMvc</code></li>
<li><code>@EnableTransactionManagement</code></li>
<li><code>@EnableCaching</code></li>
<li><code>@EnableMBeanExport</code></li>
<li><code>@EnableAsync</code></li>
</ul>
</li>
<li><p>@Enable 模块驱动编程模式</p>
<ul>
<li>驱动注解：@EnableXXX</li>
<li>导入注解：<code>@lmport</code> 具体实现</li>
<li>具体实现<ul>
<li>基于 Configuration Class</li>
<li>基于 <code>ImportSelector</code> 接口实现</li>
<li>基于 <code>ImportBeanDefinitionRegistrar</code> 接口实现</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Spring-条件注解"><a href="#Spring-条件注解" class="headerlink" title="Spring 条件注解"></a>Spring 条件注解</h3><ul>
<li><p>基于配置条件注解 - <code>@org.springframework.context.annotation.Profile</code></p>
<ul>
<li>关联对象 - <code>org.springframework.core.env.Environment</code> 中的 Profiles</li>
<li>实现变化：从 Spring 4.0 开始，<code>@Profile</code> 基于 <code>@Conditional</code> 实现</li>
</ul>
</li>
<li><p>基于编程条件注解 - <code>@org.springframework.context.annotation.Conditional</code></p>
<ul>
<li>关联对象 - <code>org.springframework.context.annotation.Condition</code> 具体实现</li>
</ul>
</li>
<li><p><code>@Conditional</code> 实现原理</p>
<ul>
<li>上下文对象 - <code>org.springframework.context.annotation.ConditionContext</code></li>
<li>条件判断 - <code>org.springframework.context.annotation.ConditionEvaluator</code></li>
<li>配置阶段 - <code>org.springframework.context.annotation.ConfigurationCondition.ConfigurationPhase</code></li>
<li>判断入口 - <code>org.springframework.context.annotation.ConfigurationClassPostProcessor</code><ul>
<li><code>org.springframework.context.annotation.ConfigurationClassParser</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>@Conditional</code> 属性可传入多个 <code>Condition</code> 类作为条件，这些条件按照 Order 排序，如果一个条件通过，就返回 true</p>
<h3 id="课外资料-3"><a href="#课外资料-3" class="headerlink" title="课外资料"></a>课外资料</h3><ul>
<li>Spring Boot 注解</li>
</ul>
<table><thead><tr><th>注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td><code>@SpringBootConfiguration</code></td><td>Spring Boot 配置类</td><td>1.4.0</td></tr><tr><td><code>@SpringBootApplication</code></td><td>Spring Boot 应用引导注解</td><td>1.2.0</td></tr><tr><td><code>@EnableAutoConfiguration</code></td><td>Spring Boot 激活自动装配</td><td>1.0.0</td></tr></tbody></table>

<ul>
<li>Spring Cloud 注解</li>
</ul>
<table><thead><tr><th>注解</th><th>场景说明</th><th>起始版本</th></tr></thead><tbody><tr><td><code>@SpringCloudApplication</code></td><td>Spring Cloud 应用引导注解</td><td>1.0.0</td></tr><tr><td><code>@EnableDiscoveryClient</code></td><td>Spring Cloud 激活服务发现客户端注解</td><td>1.0.0</td></tr><tr><td><code>@EnableCircuitBreaker</code></td><td>Spring Cloud 激活熔断注解</td><td>1.0.0</td></tr></tbody></table>

<h3 id="面试题-9"><a href="#面试题-9" class="headerlink" title="面试题"></a>面试题</h3><h4 id="Spring-模式注解有哪些？"><a href="#Spring-模式注解有哪些？" class="headerlink" title="Spring 模式注解有哪些？"></a>Spring 模式注解有哪些？</h4><ul>
<li><code>@org.springframework.stereotype.Component</code></li>
<li><code>@org.springframework.stereotype.Repository</code></li>
<li><code>@org.springframework.stereotype.Service</code></li>
<li><code>@org.springframework.stereotype.Controller</code></li>
<li><code>@org.springframework.context.annotation.Configuration</code></li>
</ul>
<h4 id="EventListener-的工作原理？"><a href="#EventListener-的工作原理？" class="headerlink" title="@EventListener 的工作原理？"></a>@EventListener 的工作原理？</h4><p>源码导读 - <code>org.springframework.context.event.EventListenerMethodProcessor</code></p>
<h4 id="PropertySource-的工作原理？"><a href="#PropertySource-的工作原理？" class="headerlink" title="@PropertySource 的工作原理？"></a>@PropertySource 的工作原理？</h4><blockquote>
<p>本文由 <a target="_blank" rel="noopener" href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/huangwenjie/p/13946011.html">www.cnblogs.com</a></p>
</blockquote>
<h2 id="第十九章：Spring-Environment-抽象"><a href="#第十九章：Spring-Environment-抽象" class="headerlink" title="第十九章：Spring Environment 抽象"></a>第十九章：Spring Environment 抽象</h2><h3 id="理解-Spring-Environment-抽象"><a href="#理解-Spring-Environment-抽象" class="headerlink" title="理解 Spring Environment 抽象"></a>理解 Spring Environment 抽象</h3><ul>
<li><p>统一的 Spring 配置属性管理</p>
<ul>
<li><code>PropertySource</code></li>
<li>Spring Framework 3.1 开始引入 <code>Environment</code> 抽象，它统一 Spring 配置属性的存储，包括占位符处理和类型转换，不仅完整地替换 <code>PropertyPlaceholderConfigurer</code>，而且还支持更丰富的配置属性源（PropertySource）</li>
<li><code>PropertyPlaceholderConfigurer</code> 在 Spring 5.2 已过期</li>
</ul>
</li>
<li><p>条件化 Spring Bean 装配管理</p>
<ul>
<li>Profile</li>
<li>通过 Environment Profiles 信息，帮助 Spring 容器提供条件化地装配 Bean</li>
</ul>
</li>
<li><p>Environment 接口功能分析</p>
<ul>
<li>继承了 <code>org.springframework.core.env.PropertyResolver</code> 接口，此接口提供属性管理和解析占位符的能力</li>
<li><code>org.springframework.core.env.Environment</code> 接口提供管理 Profiles 的能力</li>
</ul>
</li>
<li><p>Spring 5.2 以后，<code>PropertySourcesPlaceholderConfigurer</code> 取代 <code>PropertyPlaceholderConfigurer</code> ，两者功能类似，都继承自 <code>PlaceholderConfigurerSupport</code> 优势在于 <code>Environment</code> 和 <code>PropertySource</code></p>
</li>
</ul>
<h3 id="Spring-Environment-接口使用场景"><a href="#Spring-Environment-接口使用场景" class="headerlink" title="Spring Environment 接口使用场景"></a>Spring Environment 接口使用场景</h3><ul>
<li>用于属性占位符处理</li>
<li>用于转换 Spring 配置属性类型</li>
<li>用于存储 Spring 配置属性源（PropertySource）</li>
<li>用于 Profiles 状态的维护</li>
</ul>
<h3 id="Environment-占位符处理"><a href="#Environment-占位符处理" class="headerlink" title="Environment 占位符处理"></a>Environment 占位符处理</h3><ul>
<li><p>Spring 3.1 前占位符处理</p>
<ul>
<li>组件：<code>org.springframework.beans.factory.config.PropertyPlaceholderConfigurer</code></li>
<li>接口：<code>org.springframework.util.StringValueResolver</code></li>
</ul>
</li>
<li><p>Spring 3.1+ 占位符处理</p>
<ul>
<li>组件：<code>org.springframework.context.support.PropertySourcesPlaceholderConfigurer</code></li>
<li>实现类：<code>org.springframework.beans.factory.config.EmbeddedValueResolver</code><ul>
<li>实现了 <code>StringValueResolver</code> 接口</li>
</ul>
</li>
</ul>
</li>
<li><p><code>PropertyPlaceholderConfigurer</code> 和 <code>PropertySourcesPlaceholderConfigurer</code> 都实现了<code>BeanFactoryPostProcessor</code>，两者对占位符的处理都位于 <code>BeanFactoryPostProcessor#postProcessBeanFactory</code> 方法中</p>
</li>
</ul>
<h3 id="理解条件配置-Spring-Profiles"><a href="#理解条件配置-Spring-Profiles" class="headerlink" title="理解条件配置 Spring Profiles"></a>理解条件配置 Spring Profiles</h3><ul>
<li><p>Spring 3.1 条件配置</p>
<ul>
<li>API: <code>org.springframework.core.env.ConfigurableEnvironment</code><ul>
<li>修改：<code>addActiveProfile(String</code>)、<code>setActiveProfiles(String...)</code> 和 <code>setDefaultProfiles(String...)</code></li>
<li>获取：<code>getActiveProfiles()</code> 和 <code>getDefaultProfiles()</code></li>
<li>匹配：<code>acceptsProfiles(String...)</code> 和 <code>acceptsProfiles(Profiles)</code></li>
</ul>
</li>
</ul>
</li>
<li><p>注解：<code>@org.springframework.context.annotation.Profile</code></p>
</li>
<li><p>属性值常量：<code>org.springframework.core.env.AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME</code></p>
<ul>
<li>即 <code>spring.profiles.active</code>，可以通过设置此属性，设置 active Profiles</li>
</ul>
</li>
</ul>
<h3 id="Spring-4-重构-Profile"><a href="#Spring-4-重构-Profile" class="headerlink" title="Spring 4 重构 @Profile"></a>Spring 4 重构 @Profile</h3><ul>
<li>基于 Spring 4 接口实现<ul>
<li><code>@org.springframework.context.annotation.Conditional</code></li>
<li><code>org.springframework.context.annotation.Condition</code><ul>
<li><code>org.springframework.context.annotation.ProfileCondition</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="依赖注入-Environment"><a href="#依赖注入-Environment" class="headerlink" title="依赖注入 Environment"></a>依赖注入 Environment</h3><ul>
<li><p>直接依赖注入</p>
<ul>
<li>通过 <code>EnvironmentAware</code> 接口回调</li>
<li>通过 <code>@Autowired</code> 注入 <code>Environment</code></li>
</ul>
</li>
<li><p>间接依赖注入</p>
<ul>
<li>通过 <code>ApplicationContextAware</code> 接口回调</li>
<li>通过 <code>@Autowired</code> 注入 <code>ApplicationContext</code></li>
</ul>
</li>
<li><p><code>ApplicationContext</code> 和 <code>Environment</code> 是一一对应的</p>
</li>
<li><p>在 <code>AbstractApplicationContext#prepareBeanFactory</code> 中，以单例形式，将 <code>Environment</code> 注入了 <code>BeanFactory</code></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (!beanFactory.contains<span class="hljs-constructor">LocalBean(ENVIRONMENT_BEAN_NAME)</span>) &#123;<br>	beanFactory.register<span class="hljs-constructor">Singleton(ENVIRONMENT_BEAN_NAME, <span class="hljs-params">getEnvironment</span>()</span>);<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="依赖查找-Environment"><a href="#依赖查找-Environment" class="headerlink" title="依赖查找 Environment"></a>依赖查找 Environment</h3><ul>
<li><p>直接依赖查找</p>
<ul>
<li>通过 <code>org.springframework.context.ConfigurableApplicationContext#ENVIRONMENT_BEAN_NAME</code></li>
</ul>
</li>
<li><p>间接依赖查找</p>
<ul>
<li>通过 <code>org.springframework.context.ConfigurableApplicationContext#getEnvironment</code></li>
</ul>
</li>
</ul>
<h3 id="依赖注入-Value"><a href="#依赖注入-Value" class="headerlink" title="依赖注入 @Value"></a>依赖注入 @Value</h3><ul>
<li><p>通过注入 <code>@Value</code></p>
<ul>
<li><p>实现 - <code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor</code></p>
</li>
<li><p><code>@Value</code> 注解的解析在 <code>populateBean</code> 阶段</p>
</li>
<li><p>解析的生命周期在 <code>InstantiationAwareBeanPostProcessor#postProcessProperties</code></p>
</li>
<li><p><code>AutowiredAnnotationBeanPostProcessor</code> 实现 <code>InstantiationAwareBeanPostProcessor</code></p>
</li>
<li><p>解析方法位于 <code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement#inject</code></p>
<ul>
<li><code>org.springframework.beans.factory.support.DefaultListableBeanFactory#doResolveDependency</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Spring-类型转换在-Environment-中的运用"><a href="#Spring-类型转换在-Environment-中的运用" class="headerlink" title="Spring 类型转换在 Environment 中的运用"></a>Spring 类型转换在 Environment 中的运用</h3><ul>
<li><p><code>Environment</code> 底层实现</p>
<ul>
<li>底层实现 - <code>org.springframework.core.env.PropertySourcesPropertyResolver</code><ul>
<li>核心方法 - <code>convertValueIfNecessary(Object, Class)</code></li>
</ul>
</li>
<li>底层服务 - <code>org.springframework.core.convert.ConversionService</code><ul>
<li>默认实现 - <code>org.springframework.core.convert.support.DefaultConversionService</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>Environment#getProperty</code> ，从这个方法开始分析</p>
</li>
<li><p><code>AbstractEnvironment#getProperty</code> 使用 <code>PropertySourcesPropertyResolver</code>，<code>PropertySourcesPropertyResolver</code> 使用 <code>ConversionService</code></p>
</li>
</ul>
<h3 id="Spring-类型转换在-Value-中的运用"><a href="#Spring-类型转换在-Value-中的运用" class="headerlink" title="Spring 类型转换在 @Value 中的运用"></a>Spring 类型转换在 @Value 中的运用</h3><ul>
<li><code>@Value</code> 底层实现<ul>
<li>底层实现 - <code>org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor</code><ul>
<li><code>org.springframework.beans.factory.support.DefaultListableBeanFactory#doResolveDependency</code></li>
</ul>
</li>
<li>底层服务 - <code>org.springframework.beans.TypeConverter</code><ul>
<li>默认实现 - <code>org.springframework.beans.TypeConverterDelegate</code><ul>
<li><code>java.beans.PropertyEditor</code></li>
<li><code>org.springframework.core.convert.ConversionService</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Spring-配置属性源-PropertySource"><a href="#Spring-配置属性源-PropertySource" class="headerlink" title="Spring 配置属性源 PropertySource"></a>Spring 配置属性源 PropertySource</h3><ul>
<li>API<ul>
<li>单配置属性源 - <code>org.springframework.core.env.PropertySource</code></li>
<li>多配置属性源 - <code>org.springframework.core.env.PropertySources</code></li>
</ul>
</li>
<li>注解<ul>
<li>单配置属性源 - <code>@org.springframework.context.annotation.PropertySource</code></li>
<li>多配置属性源 - <code>@org.springframework.context.annotation.PropertySources</code></li>
</ul>
</li>
<li>关联<ul>
<li>存储对象 - <code>org.springframework.core.env.MutablePropertySources</code></li>
<li>关联方法 - <code>org.springframework.core.env.ConfigurableEnvironment#getPropertySources</code></li>
</ul>
</li>
</ul>
<h3 id="Spring-内建的配置属性源"><a href="#Spring-内建的配置属性源" class="headerlink" title="Spring 内建的配置属性源"></a>Spring 内建的配置属性源</h3><ul>
<li>內建 <code>PropertySource</code></li>
</ul>
<table><thead><tr><th>PropertySource 类型</th><th>说明</th></tr></thead><tbody><tr><td><code>org.springframework.core.env.CommandLinePropertySource</code></td><td>命令行配置属性源</td></tr><tr><td><code>org.springframework.jndi.JndiPropertySource</code></td><td>JDNI 配置属性源</td></tr><tr><td><code>org.springframework.core.env.PropertiesPropertySource</code></td><td>Properties 配置属性源</td></tr><tr><td><code>org.springframework.web.context.support.ServletConfigPropertySource</code></td><td>Servlet 配置属性源</td></tr><tr><td><code>org.springframework.web.context.support.ServletContextPropertySource</code></td><td>ServletContext 配置属性源</td></tr><tr><td><code>org.springframework.core.env.SystemEnvironmentPropertySource</code></td><td>环境变量配置属性源</td></tr></tbody></table>

<h3 id="基于注解扩展-Spring-配置属性源"><a href="#基于注解扩展-Spring-配置属性源" class="headerlink" title="基于注解扩展 Spring 配置属性源"></a>基于注解扩展 Spring 配置属性源</h3><ul>
<li><p><code>@org.springframework.context.annotation.PropertySource</code> 实现原理</p>
<ul>
<li>入口 - <code>org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass</code><ul>
<li><code>org.springframework.context.annotation.ConfigurationClassParser#processPropertySource</code></li>
</ul>
</li>
<li>4.3 新增语义<ul>
<li>配置属性字符编码 - <code>encoding</code></li>
<li><code>org.springframework.core.io.support.PropertySourceFactory</code></li>
</ul>
</li>
<li>适配对象 - <code>org.springframework.core.env.CompositePropertySource</code></li>
</ul>
</li>
<li><p><code>PropertySource</code> 之前只支持 properties 文件，从 Spring 4.3 开始支持其他格式文件</p>
<ul>
<li><code>org.springframework.context.annotation.PropertySource#factory</code><ul>
<li><code>org.springframework.core.io.support.EncodedResource</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="基于-API-扩展-Spring-配置属性源"><a href="#基于-API-扩展-Spring-配置属性源" class="headerlink" title="基于 API 扩展 Spring 配置属性源"></a>基于 API 扩展 Spring 配置属性源</h3><ul>
<li><p>Spring 应用上下文启动前装配 <code>PropertySource</code></p>
</li>
<li><p>Spring 应用上下文启动后装配 <code>PropertySource</code></p>
</li>
<li><p>修改 <code>PropertySource</code> 里的属性值，是否影响 Bean 里的注入属性值，需要考虑到 Bean 的初始化时机</p>
</li>
<li><p><code>PropertySource</code> 存在顺序，总是取先匹配到的</p>
</li>
</ul>
<h3 id="课外资料-4"><a href="#课外资料-4" class="headerlink" title="课外资料"></a>课外资料</h3><ul>
<li>Spring 4.1 测试配置属性源 - <code>@TestPropertySource</code></li>
</ul>
<h3 id="面试题-10"><a href="#面试题-10" class="headerlink" title="面试题"></a>面试题</h3><h4 id="简单介绍-Spring-Environment-接口？"><a href="#简单介绍-Spring-Environment-接口？" class="headerlink" title="简单介绍 Spring Environment 接口？"></a>简单介绍 Spring Environment 接口？</h4><ul>
<li><p>核心接口 - <code>org.springframework.core.env.Environment</code></p>
</li>
<li><p>父接口 - <code>org.springframework.core.env.PropertyResolver</code></p>
</li>
<li><p>可配置接口 - <code>org.springframework.core.env.ConfigurableEnvironment</code></p>
</li>
<li><p>职责：</p>
<ul>
<li>管理 Spring 配置属性源</li>
<li>管理 Profiles</li>
</ul>
</li>
</ul>
<h4 id="如何控制-PropertySource-的优先级？"><a href="#如何控制-PropertySource-的优先级？" class="headerlink" title="如何控制 PropertySource 的优先级？"></a>如何控制 PropertySource 的优先级？</h4><ul>
<li><code>org.springframework.core.env.ConfigurableEnvironment#getPropertySources</code><ul>
<li><code>org.springframework.core.env.MutablePropertySources</code><ul>
<li><code>MutablePropertySources</code> 中存在控制 PropertySource 顺序的方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Environment-完整的生命周期是怎样的？"><a href="#Environment-完整的生命周期是怎样的？" class="headerlink" title="Environment 完整的生命周期是怎样的？"></a>Environment 完整的生命周期是怎样的？</h4><h2 id="第二十章：Spring-应用上下文生命周期"><a href="#第二十章：Spring-应用上下文生命周期" class="headerlink" title="第二十章：Spring 应用上下文生命周期"></a>第二十章：Spring 应用上下文生命周期</h2><h3 id="ApplicationContext-接口继承关系"><a href="#ApplicationContext-接口继承关系" class="headerlink" title="ApplicationContext 接口继承关系"></a>ApplicationContext 接口继承关系</h3><p><img src="https://cdn.jsdelivr.net/gh/ericshen90/oss@main/uPic/ofJSxp52KHYl4wT.png" srcset="/img/loading.gif" alt=""></p>
<h3 id="Spring-应用上下文生命周期"><a href="#Spring-应用上下文生命周期" class="headerlink" title="Spring 应用上下文生命周期"></a>Spring 应用上下文生命周期</h3><ul>
<li><p><code>AbstractApplicationContext#refresh</code></p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>public void refresh<span class="hljs-literal">()</span> throws BeansException, IllegalStateException &#123;<br>    synchronized (this.startupShutdownMonitor) &#123;<br>        <span class="hljs-comment">// Prepare this context for refreshing.</span><br>        prepare<span class="hljs-constructor">Refresh()</span>;<br><br>        <span class="hljs-comment">// Tell the subclass to refresh the internal bean factory.</span><br>        ConfigurableListableBeanFactory beanFactory = obtain<span class="hljs-constructor">FreshBeanFactory()</span>;<br><br>        <span class="hljs-comment">// Prepare the bean factory for use in this context.</span><br>        prepare<span class="hljs-constructor">BeanFactory(<span class="hljs-params">beanFactory</span>)</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// Allows post-processing of the bean factory in context subclasses.</span><br>            post<span class="hljs-constructor">ProcessBeanFactory(<span class="hljs-params">beanFactory</span>)</span>;<br><br>            <span class="hljs-comment">// Invoke factory processors registered as beans in the context.</span><br>            invoke<span class="hljs-constructor">BeanFactoryPostProcessors(<span class="hljs-params">beanFactory</span>)</span>;<br><br>            <span class="hljs-comment">// Register bean processors that intercept bean creation.</span><br>            register<span class="hljs-constructor">BeanPostProcessors(<span class="hljs-params">beanFactory</span>)</span>;<br><br>            <span class="hljs-comment">// Initialize message source for this context.</span><br>            init<span class="hljs-constructor">MessageSource()</span>;<br><br>            <span class="hljs-comment">// Initialize event multicaster for this context.</span><br>            init<span class="hljs-constructor">ApplicationEventMulticaster()</span>;<br><br>            <span class="hljs-comment">// Initialize other special beans in specific context subclasses.</span><br>            on<span class="hljs-constructor">Refresh()</span>;<br><br>            <span class="hljs-comment">// Check for listener beans and register them.</span><br>            register<span class="hljs-constructor">Listeners()</span>;<br><br>            <span class="hljs-comment">// Instantiate all remaining (non-lazy-init) singletons.</span><br>            finish<span class="hljs-constructor">BeanFactoryInitialization(<span class="hljs-params">beanFactory</span>)</span>;<br><br>            <span class="hljs-comment">// Last step: publish corresponding event.</span><br>            finish<span class="hljs-constructor">Refresh()</span>;<br>        &#125;<br><br>        catch (BeansException ex) &#123;<br>            <span class="hljs-keyword">if</span> (logger.is<span class="hljs-constructor">WarnEnabled()</span>) &#123;<br>                logger.warn(<span class="hljs-string">&quot;Exception encountered during context initialization - &quot;</span> +<br>                        <span class="hljs-string">&quot;cancelling refresh attempt: &quot;</span> + ex);<br>            &#125;<br><br>            <span class="hljs-comment">// Destroy already created singletons to avoid dangling resources.</span><br>            destroy<span class="hljs-constructor">Beans()</span>;<br><br>            <span class="hljs-comment">// Reset &#x27;active&#x27; flag.</span><br>            cancel<span class="hljs-constructor">Refresh(<span class="hljs-params">ex</span>)</span>;<br><br>            <span class="hljs-comment">// Propagate exception to caller.</span><br>            throw ex;<br>        &#125;<br><br>        finally &#123;<br>            <span class="hljs-comment">// Reset common introspection caches in Spring&#x27;s core, since we</span><br>            <span class="hljs-comment">// might not ever need metadata for singleton beans anymore...</span><br>            reset<span class="hljs-constructor">CommonCaches()</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="Spring-应用上下文启动准备阶段"><a href="#Spring-应用上下文启动准备阶段" class="headerlink" title="Spring 应用上下文启动准备阶段"></a>Spring 应用上下文启动准备阶段</h3><ul>
<li><code>AbstractApplicationContext#prepareRefresh()</code> 方法<ul>
<li>启动时间 - <code>startupDate</code></li>
<li>状态标识 - <code>closed(false)</code>、<code>active(true)</code></li>
<li>初始化 <code>PropertySources</code> - <code>initPropertySources()</code><ul>
<li>默认为空方法，子类可继承</li>
<li>Web 应用上下文继承这个方法，并将 Web 参数初始化为 <code>PropertySource</code></li>
</ul>
</li>
<li>检验 <code>Environment</code> 中必须属性<ul>
<li><code>AbstractPropertyResolver#requiredProperties</code>，默认为空，可设置</li>
</ul>
</li>
<li>初始化事件监听器集合<ul>
<li><code>earlyApplicationListeners</code></li>
<li><code>applicationListeners</code></li>
</ul>
</li>
<li>初始化早期 Spring 事件集合<ul>
<li><code>earlyApplicationEvents</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="BeanFactory-创建阶段"><a href="#BeanFactory-创建阶段" class="headerlink" title="BeanFactory 创建阶段"></a>BeanFactory 创建阶段</h3><ul>
<li><code>AbstractApplicationContext#obtainFreshBeanFactory</code> 方法<ul>
<li>抽象方法</li>
<li>子类实现，<code>AbstractRefreshableApplicationContext#refreshBeanFactory</code><ul>
<li>刷新 Spring 应用上下文底层 <code>BeanFactory</code> - <code>refreshBeanFactory()</code><ul>
<li>销毁或关闭 <code>BeanFactory</code> ，如果已存在的话</li>
<li>创建 <code>BeanFactory</code> - <code>createBeanFactory()</code><ul>
<li><code>DefaultListableBeanFactory</code></li>
</ul>
</li>
<li>设置 BeanFactory Id</li>
<li>自定义 <code>BeanFactory</code> 属性 - <code>customizeBeanFactory(beanFactory)</code></li>
<li>设置 “是否允许 BeanDefinition 重复定义” - <code>customizeBeanFactory(DefaultListableBeanFactory)</code><ul>
<li><code>AbstractRefreshableApplicationContext#allowBeanDefinitionOverriding</code></li>
<li>默认为 true</li>
<li>设置 “是否允许循环引用（依赖）” - <code>customizeBeanFactory(DefaultListableBeanFactory)</code><ul>
<li><code>AbstractRefreshableApplicationContext#allowCircularReferences</code></li>
<li>默认为 true</li>
</ul>
</li>
</ul>
</li>
<li>加载 <code>BeanDefinition</code> - <code>loadBeanDefinitions(DefaultListableBeanFactory)</code> 方法<ul>
<li>抽象方法</li>
</ul>
</li>
<li>关联新建 <code>BeanFactory</code> 到 Spring 应用上下文</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>返回 Spring 应用上下文底层 <code>BeanFactory</code> - <code>getBeanFactory()</code><ul>
<li>抽象方法</li>
</ul>
</li>
</ul>
<h3 id="BeanFactory-准备阶段"><a href="#BeanFactory-准备阶段" class="headerlink" title="BeanFactory 准备阶段"></a>BeanFactory 准备阶段</h3><ul>
<li><code>AbstractApplicationContext#prepareBeanFactory(ConfigurableListableBeanFactory)</code> 方法<ul>
<li>关联 <code>ClassLoader</code></li>
<li>设置 Bean 表达式处理器<ul>
<li>与 SpEL 表达式相关</li>
<li><code>org.springframework.context.expression.StandardBeanExpressionResolver</code></li>
</ul>
</li>
<li>添加 <code>PropertyEditorRegistrar</code> 实现 - <code>ResourceEditorRegistrar</code><ul>
<li><code>org.springframework.beans.support.ResourceEditorRegistrar</code></li>
</ul>
</li>
<li>添加 <code>Aware</code> 回调接口 <code>BeanPostProcessor</code> 实现 - <code>ApplicationContextAwareProcessor</code><ul>
<li><code>EnvironmentAware</code></li>
<li><code>EmbeddedValueResolverAware</code></li>
<li><code>ResourceLoaderAware</code></li>
<li><code>ApplicationEventPublisherAware</code></li>
<li><code>MessageSourceAware</code></li>
<li><code>ApplicationContextAware</code></li>
</ul>
</li>
<li>忽略 <code>Aware</code> 回调接口作为依赖注入接口</li>
<li>注册 ResolvableDependency 对象 - <code>BeanFactory</code>、<code>ResourceLoader</code>、<code>ApplicationEventPublisher</code> 以及 <code>Applicationcontext</code><ul>
<li><code>BeanFactory</code> 是 <code>ApplicationContext</code> 关联的 <code>BeanFactory</code></li>
<li><code>ResourceLoader</code>、<code>ApplicationEventPublisher</code> 以及 <code>Applicationcontext</code> 都是 <code>ApplicationContext</code></li>
</ul>
</li>
<li>添加 <code>BeanPostProcessor</code> - <code>ApplicationListenerDetector</code><ul>
<li>在 <code>BeanPostProcessor#postProcessAfterInitialization</code> 阶段，将单例的 <code>ApplicationListener</code> 加入 <code>ApplicationContext</code></li>
</ul>
</li>
<li>如果包含 beanName 是 <code>loadTimeWeaver</code> 的 bean，注册 <code>BeanPostProcessor</code> - <code>LoadTimeWeaverAwareProcessor</code> 对象，并设置容器的临时 <code>ClassLoader</code>， <code>AbstractBeanFactory#tempClassLoader</code><ul>
<li>与 AOP 相关</li>
</ul>
</li>
<li>注册单例对象 - <code>Environment</code>、Java System Properties 以及 OS 环境变量<ul>
<li><code>environment</code> - <code>ApplicationContext#environment</code></li>
<li><code>systemProperties</code> - <code>(Map) System.getProperties()</code></li>
<li><code>systemEnvironment</code> - <code>(Map) System.getenv()</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="BeanFactory-后置处理阶段"><a href="#BeanFactory-后置处理阶段" class="headerlink" title="BeanFactory 后置处理阶段"></a>BeanFactory 后置处理阶段</h3><ul>
<li><code>AbstractApplicationContext#postProcessBeanFactory(ConfigurableListableBeanFactory)</code> 方法<ul>
<li>由子类覆盖该方法</li>
</ul>
</li>
<li><code>org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory)</code> 方法<ul>
<li>判断 <code>BeanFactory</code> 是不是 <code>BeanDefinitionRegistry</code> 的实例<ul>
<li><code>DefaultListableBeanFactory</code> 实现 <code>BeanDefinitionRegistry</code></li>
<li>如果是，调用 <code>BeanFactoryPostProcessor</code> 或 <code>BeanDefinitionRegistryPostProcessor</code> 后置处理方法<ul>
<li><code>BeanDefinitionRegistryPostProcessor</code> 继承 <code>BeanFactoryPostProcessor</code></li>
<li><code>BeanFactoryPostProcessor#postProcessBeanFactory</code></li>
<li><code>BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry</code></li>
</ul>
</li>
<li>如果不是，只调用 <code>BeanFactoryPostProcessor</code> 后置处理方法 <code>BeanFactoryPostProcessor#postProcessBeanFactory</code></li>
</ul>
</li>
<li>如果包含 beanName 是 <code>loadTimeWeaver</code> 的 bean，注册 <code>BeanPostProcessor</code> - <code>LoadTimeWeaverAwareProcessor</code> 对象，并设置容器的临时 <code>ClassLoader</code>， <code>AbstractBeanFactory#tempClassLoader</code><ul>
<li>与 AOP 相关</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>执行顺序：</p>
<ol>
<li>对 <code>BeanDefinitionRegistryPostProcessor</code> 进行处理<ol>
<li>执行 <code>BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry</code><ol>
<li>按照添加顺序执行， <code>AbstractApplicationContext#beanFactoryPostProcessors</code> 中的 <code>BeanDefinitionRegistryPostProcessor</code></li>
<li>按照 Order 顺序执行，<code>BeanFactory</code> 中实现了 <code>PriorityOrdered</code> 的 <code>BeanDefinitionRegistryPostProcessor</code> Bean</li>
<li>按照 Order 顺序执行，<code>BeanFactory</code> 中实现了 <code>Ordered</code> 的 <code>BeanDefinitionRegistryPostProcessor</code> Bean</li>
<li>按照 Order 顺序执行，其他 <code>BeanFactory</code> 中的 <code>BeanDefinitionRegistryPostProcessor</code> Bean</li>
</ol>
</li>
<li>执行 <code>BeanFactoryPostProcessor#postProcessBeanFactory</code><ol>
<li><code>AbstractApplicationContext#beanFactoryPostProcessors</code> 中的普通 <code>BeanFactoryPostProcessor</code></li>
<li><code>BeanFactory</code> 中 <code>BeanDefinitionRegistryPostProcessor</code></li>
</ol>
</li>
</ol>
</li>
<li>对 <code>BeanFactoryPostProcessor</code> 继续处理，<code>BeanFactoryPostProcessor#postProcessBeanFactory</code><ol>
<li>按照 Order 顺序执行，实现 <code>PriorityOrdered</code> 接口的 <code>BeanFactoryPostProcessor</code></li>
<li>按照 Order 顺序执行，实现 <code>Ordered</code> 接口的 <code>BeanFactoryPostProcessor</code></li>
<li>其他常规 <code>BeanFactoryPostProcessor</code></li>
</ol>
</li>
</ol>
<h3 id="BeanFactory-注册-BeanPostProcessor-阶段"><a href="#BeanFactory-注册-BeanPostProcessor-阶段" class="headerlink" title="BeanFactory 注册 BeanPostProcessor 阶段"></a>BeanFactory 注册 BeanPostProcessor 阶段</h3><ul>
<li><code>AbstractApplicationContext#registerBeanPostProcessors(ConfigurableListableBeanFactory)</code> 方 法<ul>
<li>注册 <code>PriorityOrdered</code> 类型的 <code>BeanPostProcessor</code> Beans</li>
<li>注册 <code>Ordered</code> 类型的 <code>BeanPostProcessor</code> Beans</li>
<li>注册普通 <code>BeanPostProcessor</code> Beans</li>
<li>注册 <code>MergedBeanDefinitionPostProcessor</code> Beans<ul>
<li><code>MergedBeanDefinitionPostProcessor</code> 继承 <code>BeanPostProcessor</code>，生命周期在 MergedBeanDefinition 后</li>
</ul>
</li>
<li>重新注册 <code>ApplicationListenerDetector</code> 对象<ul>
<li>为了将 <code>ApplicationListenerDetector</code> 的顺序放到最后</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="初始化內建-Bean-MessageSource"><a href="#初始化內建-Bean-MessageSource" class="headerlink" title="初始化內建 Bean: MessageSource"></a>初始化內建 Bean: MessageSource</h3><ul>
<li><code>AbstractApplicationContext#initMessageSource</code> 方法<ul>
<li>如果 <code>BeanFactory</code> 中存在 beanName 为 <code>messageSource</code> 的 <code>MessageSource</code> ，则使用，否则注册 <code>DelegatingMessageSource</code></li>
<li>回顾章节 - 第十二章 Spring 国际化 - <code>MessageSource</code> 内建依赖</li>
</ul>
</li>
</ul>
<h3 id="初始化內建-Bean-Spring-事件广播器"><a href="#初始化內建-Bean-Spring-事件广播器" class="headerlink" title="初始化內建 Bean: Spring 事件广播器"></a>初始化內建 Bean: Spring 事件广播器</h3><ul>
<li><code>AbstractApplicationContext#initApplicationEventMulticaster</code> 方法<ul>
<li>如果 <code>BeanFactory</code> 中存在 beanName 为 <code>applicationEventMulticaster</code> 的 <code>ApplicationEventMulticaster</code> ，则使用，否则注册 <code>SimpleApplicationEventMulticaster</code></li>
<li>回顾章节 - 第十七章 Spring 事件 - <code>ApplicationEventPublisher</code> 底层实现</li>
</ul>
</li>
</ul>
<h3 id="Spring-应用上下文刷新阶段"><a href="#Spring-应用上下文刷新阶段" class="headerlink" title="Spring 应用上下文刷新阶段"></a>Spring 应用上下文刷新阶段</h3><ul>
<li><code>AbstractApplicationContext#onRefresh</code> 方法<ul>
<li>空方法，由子类覆盖该方法<ul>
<li><code>org.springframework.web.context.support.AbstractRefreshableWebApplicationContext#onRefresh</code></li>
<li><code>org.springframework.web.context.support.GenericWebApplicationContext#onRefresh</code></li>
<li><code>org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContext#onRefresh</code></li>
<li><code>org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext#onRefresh</code></li>
<li><code>org.springframework.web.context.support.StaticWebApplicationContext#onRefresh</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Spring-事件监听器注册阶段"><a href="#Spring-事件监听器注册阶段" class="headerlink" title="Spring 事件监听器注册阶段"></a>Spring 事件监听器注册阶段</h3><ul>
<li><code>AbstractApplicationContext#registerListeners</code> 方法<ul>
<li>将 <code>ApplicationListener</code> 添加到 <code>AbstractApplicationContext#applicationEventMulticaster</code><ul>
<li>添加当前应用上下文所关联的 <code>ApplicationListener</code> 对象（集合）</li>
<li>添加 <code>BeanFactory</code> 所注册 <code>ApplicationListener</code> Beans</li>
</ul>
</li>
<li>广播早期 Spring 事件<ul>
<li><code>AbstractApplicationContext#earlyApplicationEvents</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="BeanFactory-初始化完成阶段"><a href="#BeanFactory-初始化完成阶段" class="headerlink" title="BeanFactory 初始化完成阶段"></a>BeanFactory 初始化完成阶段</h3><ul>
<li><p><code>AbstractApplicationContext#finishBeanFactoryInitialization(ConfigurableListableBeanFactory)</code> 方法</p>
<ul>
<li><p><code>BeanFactory</code> 关联 <code>ConversionService</code> Bean，如果存在</p>
<ul>
<li>beanName 为 <code>conversionService</code> 的 <code>ConversionService</code></li>
</ul>
</li>
<li><p>添加 <code>StringValueResolver</code> 对象</p>
<ul>
<li><p>如果 <code>AbstractBeanFactory#embeddedValueResolvers</code> 为空，添加一个</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (!beanFactory.has<span class="hljs-constructor">EmbeddedValueResolver()</span>) &#123;<br>	beanFactory.add<span class="hljs-constructor">EmbeddedValueResolver(<span class="hljs-params">strVal</span> -&gt; <span class="hljs-params">getEnvironment</span>()</span>.resolve<span class="hljs-constructor">Placeholders(<span class="hljs-params">strVal</span>)</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>依赖查找 <code>LoadTimeWeaverAware</code> Bean</p>
</li>
<li><p><code>BeanFactory</code> 临时 <code>ClassLoader</code> 置为 <code>null</code></p>
</li>
<li><p><code>BeanFactory</code> 冻结配置</p>
<ul>
<li><code>DefaultListableBeanFactory#configurationFrozen</code></li>
<li><code>DefaultListableBeanFactory#frozenBeanDefinitionNames</code></li>
</ul>
</li>
<li><p><code>BeanFactory</code> 初始化非延迟单例 Beans</p>
<ol>
<li>初始化非延迟单例 Bean</li>
<li>触发单例 Bean 中的 <code>SmartInitializingSingleton</code> 的生命周期， <code>SmartInitializingSingleton#afterSingletonsInstantiated</code></li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="Spring-应用上下文刷新完成阶段"><a href="#Spring-应用上下文刷新完成阶段" class="headerlink" title="Spring 应用上下文刷新完成阶段"></a>Spring 应用上下文刷新完成阶段</h3><ul>
<li><code>AbstractApplicationContext#finishRefresh</code> 方法<ul>
<li>清除 <code>ResourceLoader</code> 缓存 - <code>clearResourceCaches()</code> @since 5.0</li>
<li>初始化 <code>LifecycleProcessor</code> 对象 - <code>initLifecycleProcessor()</code><ul>
<li>如果不存在 beanName 为 <code>lifecycleProcessor</code> 的 <code>LifecycleProcessor</code>，则使用 <code>DefaultLifecycleProcessor</code></li>
</ul>
</li>
<li>调用 <code>LifecycleProcessor#onRefresh()</code> 方法</li>
<li>发布 Spring 应用上下文已刷新事件 - <code>ContextRefreshedEvent</code></li>
<li>向 <code>MBeanServer</code> 托管 Live Beans</li>
</ul>
</li>
</ul>
<h3 id="Spring-应用上下文启动阶段"><a href="#Spring-应用上下文启动阶段" class="headerlink" title="Spring 应用上下文启动阶段"></a>Spring 应用上下文启动阶段</h3><ul>
<li><code>AbstractApplicationContext#start()</code> 方法<ul>
<li>启动 <code>LifecycleProcessor</code><ul>
<li>依赖查找 <code>Lifecycle</code> Beans</li>
<li>启动 <code>Lifecycle</code> Beans</li>
</ul>
</li>
</ul>
</li>
<li>发布 Spring 应用上下文已启动事件 - <code>ContextStartedEvent</code></li>
</ul>
<h3 id="Spring-应用上下文停止阶段"><a href="#Spring-应用上下文停止阶段" class="headerlink" title="Spring 应用上下文停止阶段"></a>Spring 应用上下文停止阶段</h3><ul>
<li><code>AbstractApplicationContext#stop()</code> 方法<ul>
<li>停止 <code>LifecycleProcessor</code></li>
<li>依赖查找 <code>Lifecycle</code> Beans</li>
<li>停止 <code>Lifecycle</code> Beans</li>
</ul>
</li>
<li>发布 Spring 应用上下文已停止事件 - <code>ContextStoppedEvent</code></li>
</ul>
<h3 id="Spring-应用上下文关闭阶段"><a href="#Spring-应用上下文关闭阶段" class="headerlink" title="Spring 应用上下文关闭阶段"></a>Spring 应用上下文关闭阶段</h3><ul>
<li><code>AbstractApplicationContext#close()</code> 方法</li>
<li>状态标识：<code>active(false)</code>、<code>closed(true)</code></li>
<li>Live Beans JMX 撤销托管<ul>
<li><code>LiveBeansView#unregisterApplicationContext(ConfigurableApplicationContext)</code></li>
</ul>
</li>
<li>发布 Spring 应用上下文已关闭事件 - <code>ContextCLosedEvent</code></li>
<li>关闭 <code>LifecycleProcessor</code><ul>
<li>依赖查找 <code>Lifecycle</code> Beans</li>
<li>停止 <code>Lifecycle</code> Beans</li>
</ul>
</li>
<li>销毁 Spring Beans</li>
<li>关闭 <code>BeanFactory</code></li>
<li>回调 <code>onClose()</code></li>
<li>注册 Shutdown Hook 线程（如果曾注册）</li>
</ul>
<h3 id="面试题-11"><a href="#面试题-11" class="headerlink" title="面试题"></a>面试题</h3><h4 id="Spring-应用上下文生命周期有哪些阶段"><a href="#Spring-应用上下文生命周期有哪些阶段" class="headerlink" title="Spring 应用上下文生命周期有哪些阶段?"></a>Spring 应用上下文生命周期有哪些阶段?</h4><ul>
<li>刷新阶段 - <code>ConfigurableApplicationContext#refresh()</code></li>
<li>启动阶段 - <code>ConfigurableApplicationContext#start()</code></li>
<li>停止阶段 - <code>ConfigurableApplicationContext#stop()</code></li>
<li>关闭阶段 - <code>ConfigurableApplicationContext#close()</code></li>
</ul>
<h4 id="Environment-完整的生命周期是怎样的？-1"><a href="#Environment-完整的生命周期是怎样的？-1" class="headerlink" title="Environment 完整的生命周期是怎样的？"></a>Environment 完整的生命周期是怎样的？</h4><h4 id="Spring-应用上下文生命周期执行动作"><a href="#Spring-应用上下文生命周期执行动作" class="headerlink" title="Spring 应用上下文生命周期执行动作?"></a>Spring 应用上下文生命周期执行动作?</h4><h2 id="课程加餐内容讨论"><a href="#课程加餐内容讨论" class="headerlink" title="课程加餐内容讨论"></a>课程加餐内容讨论</h2><h3 id="为什么说-ObjectFactory-提供的是延迟依赖查找？"><a href="#为什么说-ObjectFactory-提供的是延迟依赖查找？" class="headerlink" title="为什么说 ObjectFactory 提供的是延迟依赖查找？"></a>为什么说 ObjectFactory 提供的是延迟依赖查找？</h3><ul>
<li>原因<ul>
<li><code>ObjectFactory</code> （或 <code>ObjectProvider</code> ）可关联某一类型 Bean</li>
<li><code>ObjectFactory</code> 和 <code>ObjectProvider</code> 对象在被依赖注入和依赖查询时并未实时查找关联类型的 Bean</li>
<li><code>ObjectFactory</code> （或 <code>ObjectProvider</code> ）调用 <code>getObject()</code> 方法时，目标 Bean 才被依赖查找</li>
</ul>
</li>
<li>总结<ul>
<li><code>ObjectFactory</code> （或 <code>ObjectProvider</code> ）相当于某一类型 Bean 依赖查找代理对象</li>
</ul>
</li>
</ul>
<h3 id="依赖查找-注入-的-Bean-会被缓存吗？"><a href="#依赖查找-注入-的-Bean-会被缓存吗？" class="headerlink" title="依赖查找 (注入) 的 Bean 会被缓存吗？"></a>依赖查找 (注入) 的 Bean 会被缓存吗？</h3><ul>
<li>单例 Bean (Singleton) - 会<ul>
<li>缓存位置：<code>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#singletonObjects</code> 属性</li>
</ul>
</li>
<li>原型 Bean (Prototype) - 不会<ul>
<li>当依赖查询或依赖注入时，根据 <code>BeanDefinition</code> 每次创建</li>
</ul>
</li>
<li>其他 Scope Bean<ul>
<li>request : 每个 ServletRequest 内部缓存，生命周期维持在每次 HTTP 请求</li>
<li>session : 每个 HttpSession 内部缓存，生命周期维持在每个用户 HTTP 会话</li>
<li>application : 当前 Servlet 应用内部缓存</li>
</ul>
</li>
</ul>
<h4 id="Bean-的处理流程是怎样的"><a href="#Bean-的处理流程是怎样的" class="headerlink" title="@Bean 的处理流程是怎样的?"></a>@Bean 的处理流程是怎样的?</h4><ul>
<li>解析范围 - Configuration Class 中的 <code>@Bean</code> 方法</li>
<li>方法类型 - 静态 <code>@Bean</code> 方法和实例 <code>@Bean</code> 方法</li>
</ul>
<h4 id="BeanFactory-是如何处理循环依赖的？"><a href="#BeanFactory-是如何处理循环依赖的？" class="headerlink" title="BeanFactory 是如何处理循环依赖的？"></a>BeanFactory 是如何处理循环依赖的？</h4><ul>
<li>循环依赖开关（方法）- <code>AbstractAutowireCapableBeanFactory#setAllowCircularReferences</code></li>
<li>单例工程（属性）- <code>DefaultSingletonBeanRegistry#singletonFactories</code></li>
<li>获取早期未处理 Bean （方法）- <code>AbstractAutowireCapableBeanFactory#getEarlyBeanReference</code></li>
<li>早期未处理 Bean （属性）- <code>DefaultSingletonBeanRegistry#earlySingletonObjects</code></li>
</ul>
<h4 id="MyBatis-与-Spring-Framework-是如何集成的？"><a href="#MyBatis-与-Spring-Framework-是如何集成的？" class="headerlink" title="MyBatis 与 Spring Framework 是如何集成的？"></a>MyBatis 与 Spring Framework 是如何集成的？</h4>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Spring/">Spring</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Spring-Framework/">Spring Framework</a>
                    
                      <a class="hover-with-bg" href="/tags/Spring/">Spring</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/01/28/spring/BeanFactory%E5%92%8CFactoryBean%E5%92%8CObjectFactory/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">BeanFactory和FactoryBean和ObjectFactory</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/06/11/spring/SpringMVC%E7%9A%84DispatcherServlet%E6%BA%90%E7%A0%81Part1/">
                        <span class="hidden-mobile">DispatcherServlet解析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
