

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  
    <meta name="description" content="Fake Geeker, Hoops Lover!">
  
  <meta name="author" content="Eric Shen">
  <meta name="keywords" content="">
  
  <title>Nexus源替换及Gitlab迁移 - Eric Shen Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/solarized-dark.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"ericshen.xyz","root":"/","version":"1.8.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Eric Shen Blog" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Eric Shen Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Nexus源替换及Gitlab迁移">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Eric Shen
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2019-05-22 16:10" pubdate>
        星期三, 五月 22日 2019
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      3.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      45
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Nexus源替换及Gitlab迁移</h1>
            
            <div class="markdown-body">
              <h2 id="Netty-PortoBuf实现客户端"><a href="#Netty-PortoBuf实现客户端" class="headerlink" title="Netty + PortoBuf实现客户端"></a>Netty + PortoBuf实现客户端</h2><ul>
<li>构建Netty 客户端</li>
<li>利用protobuf定义消息格式</li>
<li>服务端空闲检测</li>
<li>客户端发送心跳包与断线重连</li>
</ul>
<h2 id="构建-Netty-客户端"><a href="#构建-Netty-客户端" class="headerlink" title="构建 Netty 客户端"></a>构建 Netty 客户端</h2><p>Netty 客户端代码与服务端类似，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String HOST = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">9999</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SocketChannel socketChannel;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            doConnect(<span class="hljs-keyword">new</span> Bootstrap(), group);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Bootstrap <span class="hljs-title">doConnect</span><span class="hljs-params">(Bootstrap bootstrap, EventLoopGroup group)</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;开始连接Netty服务端&quot;</span>);<br>        <span class="hljs-keyword">if</span> (bootstrap != <span class="hljs-keyword">null</span>) &#123;<br>            bootstrap.group(group).channel(NioSocketChannel.class)<br>                .option(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>).option(ChannelOption.TCP_NODELAY, <span class="hljs-keyword">true</span>)<br>                .handler(<span class="hljs-keyword">new</span> ClientHandlerInitializer(<span class="hljs-keyword">this</span>));<br>            bootstrap.remoteAddress(HOST, PORT);<br><br>            bootstrap.connect().addListener((ChannelFutureListener) future -&gt; &#123;<br>                <span class="hljs-keyword">final</span> EventLoop eventLoop = future.channel().eventLoop();<br>                <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>                    log.info(<span class="hljs-string">&quot;连接Netty服务端成功&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    log.info(<span class="hljs-string">&quot;连接失败，进行5秒重连&quot;</span>);<br>                    future.channel().eventLoop()<br>                        .schedule(() -&gt; doConnect(<span class="hljs-keyword">new</span> Bootstrap(), eventLoop), <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>                &#125;<br>                socketChannel = (SocketChannel) future.channel();<br>            &#125;);<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> bootstrap;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(MessageBase.Message message)</span> </span>&#123;<br>        socketChannel.writeAndFlush(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h2 id="使用-protobuf-构建通信协议"><a href="#使用-protobuf-构建通信协议" class="headerlink" title="使用 protobuf 构建通信协议"></a>使用 protobuf 构建通信协议</h2><p>在整合使用 Netty 的过程中，我们使用 Google 的protobuf定义消息格式，下面来简单介绍下 protobuf</p>
<h3 id="protobuf简介"><a href="#protobuf简介" class="headerlink" title="protobuf简介"></a>protobuf简介</h3><p>Google 官方给 protobuf的定义如下：</p>
<blockquote>
<p>Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据序列化，很适合做数据存储或 RPC 数据交换格式。它可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</p>
</blockquote>
<p>在 Netty 中常用 protobuf 来做序列化方案，当然也可以用 protobuf来构建 客户端与服务端之间的通信协议</p>
<h3 id="为什么要用protobuf"><a href="#为什么要用protobuf" class="headerlink" title="为什么要用protobuf"></a>为什么要用protobuf</h3><p>我们这里是用 protobuf 做为我们的序列化手段，那我们为什么要使用 protobuf,而不使用其他序列化方案呢，比如 jdk 自带的序列化，Thrift,fastjson等。</p>
<p>首先 jdk 自带序列化手段有很多缺点，比如：</p>
<ul>
<li>序列化后的码流太大</li>
<li>性能太低</li>
<li>无法跨语言</li>
</ul>
<p>而 Google Protobuf 跨语言，支持C++、java和python。然后利用protobuf 编码后的消息更小，有利于存储和传输，并且其性能也非常高，相比其他序列化框架，它也是非常有优势的，具体的关于Java 各种序列化框架比较此处就不多说了。总之，目前Google Protobuf 广泛的被使用到各种项目，它的诸多优点让我们选择使用它。</p>
<h3 id="怎么使用protobuf"><a href="#怎么使用protobuf" class="headerlink" title="怎么使用protobuf"></a>怎么使用protobuf</h3><p>对于 Java 而言，使用 protobuf 主要有以下几步：</p>
<ul>
<li>在 <code>.proto</code> 文件中定义消息格式</li>
<li>使用 protobuf 编译器编译 <code>.proto</code>文件 成 Java 类</li>
<li>使用 Java 对应的 protobuf API来写或读消息</li>
</ul>
<h4 id="定义-protobuf-协议格式"><a href="#定义-protobuf-协议格式" class="headerlink" title="定义 protobuf 协议格式"></a>定义 protobuf 协议格式</h4><p>这里为我Demo里的 <code>message.proto</code>文件为例，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs proto">&#x2F;&#x2F;protobuf语法有 proto2和proto3两种，这里指定 proto3<br>syntax &#x3D; &quot;proto3&quot;;<br><br>option java_package &#x3D; &quot;com.eric.netty.protocol.protobuf&quot;;<br>option java_outer_classname &#x3D; &quot;MessageBase&quot;;<br>import &quot;google&#x2F;protobuf&#x2F;any.proto&quot;;<br>import &quot;Command.proto&quot;;<br><br>message Message &#123;<br>  string requestId &#x3D; 1;<br>  Command cmd &#x3D; 2;<br>  string msg &#x3D; 3;<br>  google.protobuf.Any data &#x3D; 4;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>文件解读：</p>
<ul>
<li>文中的第一行指定正在使用 <code>proto3</code>语法，如果没有指定，编译器默认使用 <code>proto2</code>的语法。现在新项目中可能一般多用 <code>proto3</code>的语法，<code>proto3</code>比 <code>proto2</code>支持更多的语言但更简洁。如果首次使用 protobuf,可以选择使用 <code>proto3</code></li>
<li>定义 <code>.proto</code>文件时，可以标注一系列的选项，一些选项是文件级别的，比如上面的第二行和第三行，<code>java_package</code>文件选项表明protocol编译器编译 <code>.proto</code>文件生成的 Java 类所在的包，<code>java_outer_classname</code>选项表明想要生成的 Java 类的名称</li>
<li><code>Message</code>中定义了具体的消息格式，我这里定义了三个字段，每个字段都有唯一的一个数字标识符，这些标识符用来在消息的二进制格式中识别各个字段的</li>
<li><code>Message</code>中还添加了一个枚举类型，该枚举中含有类型 <code>CommandType</code>中所有的值，每个枚举类型必须将其第一个类型映射为 0，该0值为默认值。</li>
</ul>
<p><strong>消息模型定义</strong></p>
<p>关于消息格式，此处我只是非常非常简单的定义了几个字段，<code>requestId</code>代表消息Id,<code>CommandType</code>表示消息的类型，这里简单分为心跳消息类型和业务消息类型，然后<code>content</code>就是具体的消息内容。这里的消息格式定义是十分简陋，真正的项目实战中，关于自定义消息格式的要求是非常多的，是比较复杂的。</p>
<p>上面简单的介绍了 protobuf的一些语法规则，关于 protobuf语法的更多介绍参考官方文档：<a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/proto3">https://developers.google.com/protocol-buffers/docs/proto3</a></p>
<h4 id="使用-proto编译器编译"><a href="#使用-proto编译器编译" class="headerlink" title="使用 .proto编译器编译"></a>使用 <code>.proto</code>编译器编译</h4><p>第一步已经定义好了 protobuf的消息格式，然后我们用 <code>.proto</code>文件的编译器将我们定义的 消息格式编译生成对应的 Java类，以便于我们在项目中使用该消息类。</p>
<p>关于protobuf编译器的安装这里我就不细说，详情见官方文档： <a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a></p>
<p>安装好编译器以后，使用以下命令编译<code>.proto</code>文件：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">protoc -I = <span class="hljs-string">./</span> <span class="hljs-params">--java_out=</span><span class="hljs-string">./</span> <span class="hljs-string">./Message.proto</span><br></code></pre></td></tr></table></figure>
<ul>
<li><code>-I</code> 选项用于指定待编译的 <code>.proto</code>消息定义文件所在的目录，该选项也可以写作为 <code>--proto_path</code></li>
<li><code>--java_out</code>选项表示生成 Java代码后存放位置，对于不同语言，我们的选项可能不同，比如生成C++代码为 <code>--cpp_out</code></li>
<li>在前两个选项后再加上 待编译的消息定义文件</li>
</ul>
<h4 id="使用-Java-对应-的-protobuf-API来读写消息"><a href="#使用-Java-对应-的-protobuf-API来读写消息" class="headerlink" title="使用 Java 对应 的 protobuf API来读写消息"></a>使用 Java 对应 的 protobuf API来读写消息</h4><p>前面已经根据 <code>.proto</code>消息定义文件生成的Java类，我们这里代码根据 <code>Message.proto</code>生成了<code>MessageBase</code>类，但是要正常的使用生成的 Java 类，我们还需要引入 protobuf-java的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.protobuf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>protobuf-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p>使用 protobuf 生成的每一个 Java类中，都会包含两种内部类：Msg 和 Msg 包含的 Builder(这里的Msg就是实际消息传输类)。具体是<code>.proto</code>中定义的每一个message 都会生成一个 Msg，每一个Msg对应一个 Builder:</p>
<ul>
<li>Buidler提供了构建类，查询类的API</li>
<li>Msg提供了查询，序列化，反序列化的API</li>
</ul>
<p>比如我们使用 Builder来构建 Msg,例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageBaseTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MessageBase.Message message = MessageBase.Message.newBuilder()<br>                .setRequestId(UUID.randomUUID().toString())<br>                .setContent(<span class="hljs-string">&quot;hello world&quot;</span>).build();<br>        System.out.println(<span class="hljs-string">&quot;message: &quot;</span>+message.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里就不多介绍protobuf-java API的相关用法了，更多详情还是参考官方文档：<a target="_blank" rel="noopener" href="https://developers.google.com/protocol-buffers/docs/reference/java/">https://developers.google.com/protocol-buffers/docs/reference/java/</a></p>
<h3 id="protobuf的编解码器"><a href="#protobuf的编解码器" class="headerlink" title="protobuf的编解码器"></a>protobuf的编解码器</h3><p>上面说了这么多，消息传输格式已经定义好了，但是在客户端和服务端传输过程中我们还需要对这种 protobuf格式进行编解码，当然我们可以自定义消息的编解码，<code>protobuf-java</code> 的API中提供了相关的序列化和反序列化方法。好消息是，Netty 为了支持 protobuf提供了针对 protobuf的编解码器，如下表所示（摘自《Netty实战》) ：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ProtobufDecoder</td>
<td>使用 protobuf 对消息进行解码</td>
</tr>
<tr>
<td>ProtobufEncoder</td>
<td>使用 protobuf 对消息进行编码</td>
</tr>
<tr>
<td>ProtobufVarint32FrameDecoder</td>
<td>根据消息中的 Google Protocol Buffers 的 “Base 128 Varint” 整型长度字段值动态地分割所接收到的 ByteBuf</td>
</tr>
<tr>
<td>ProtobufVarint32LengthFieldPrepender</td>
<td>向 ByteBuf 前追加一个Google Protocol Buffers 的 “Base 128 Varint” 整型长度字段值</td>
</tr>
</tbody></table>
<p>有了这些编解码器，将其加入客户端和服务端的 ChannelPipeline中以用于对消息进行编解码，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandlerInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ch.pipeline()<br>                <span class="hljs-comment">//空闲检测</span><br>                .addLast(<span class="hljs-keyword">new</span> ServerIdleStateHandler())<br>                .addLast(<span class="hljs-keyword">new</span> ProtobufVarint32FrameDecoder())<br>                .addLast(<span class="hljs-keyword">new</span> ProtobufDecoder(MessageBase.Message.getDefaultInstance()))<br>                .addLast(<span class="hljs-keyword">new</span> ProtobufVarint32LengthFieldPrepender())<br>                .addLast(<span class="hljs-keyword">new</span> ProtobufEncoder())<br>                .addLast(<span class="hljs-keyword">new</span> NettyServerHandler());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="客户端心跳机制"><a href="#客户端心跳机制" class="headerlink" title="客户端心跳机制"></a>客户端心跳机制</h2><h3 id="心跳机制简介"><a href="#心跳机制简介" class="headerlink" title="心跳机制简介"></a>心跳机制简介</h3><p>心跳是在TCP长连接中，客户端与服务端之间定期发送的一种特殊的数据包，通知对方在线以确保TCP连接的有效性。</p>
<h3 id="如何实现心跳机制"><a href="#如何实现心跳机制" class="headerlink" title="如何实现心跳机制"></a>如何实现心跳机制</h3><p>有两种方式实现心跳机制：</p>
<ul>
<li>使用TCP协议层面的 keepalive 机制</li>
<li>在应用层上自定义的心跳机制</li>
</ul>
<p>TCP层面的 keepalive 机制我们在之前构建 Netty服务端和客户端启动过程中也有定义，我们需要手动开启，示例如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 设置TCP的长连接，默认的 keepalive的心跳时间是两个小时</span><br><span class="hljs-function"><span class="hljs-title">childOption</span><span class="hljs-params">(ChannelOption.SO_KEEPALIVE, true)</span></span><br></code></pre></td></tr></table></figure>
<p>除了开启 TCP协议的 keepalive 之外，在我研究了github的一些开源Demo发现，人们往往也会自定义自己的心跳机制，定义心跳数据包。而Netty也提供了 <strong>IdleStateHandler</strong> 来实现心跳机制</p>
<h3 id="Netty-实现心跳机制"><a href="#Netty-实现心跳机制" class="headerlink" title="Netty 实现心跳机制"></a>Netty 实现心跳机制</h3><p>下面来看看客户端如何实现心跳机制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeartbeatHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            <span class="hljs-keyword">if</span> (evt <span class="hljs-keyword">instanceof</span> IdleStateEvent) &#123;<br>                IdleStateEvent idleStateEvent = (IdleStateEvent) evt;<br>                <span class="hljs-keyword">if</span> (idleStateEvent.state() == IdleState.WRITER_IDLE) &#123;<br>                    log.info(<span class="hljs-string">&quot;10s空闲发送消息给服务端&quot;</span>);<br>                    Message heartbeat = Message.newBuilder().setCmd(Command.PING)<br>                        .setRequestId(UUID.randomUUID().toString()).setMsg(<span class="hljs-string">&quot;heartbeat&quot;</span>).build();<br>                    <span class="hljs-comment">//发送心跳消息，并在发送失败时关闭该连接</span><br>                    ctx.writeAndFlush(heartbeat).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">super</span>.userEventTriggered(ctx, evt);<br>            &#125;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们这里创建了一个ChannelHandler类并重写了<code>userEventTriggered</code>方法，在该方法里实现发送心跳数据包的逻辑，同时将 <code>IdleStateEvent</code>类加入逻辑处理链上。</p>
<p>实际上是当连接空闲时间太长时，将会触发一个 <code>IdleStateEvent</code>事件，然后我们调用 <code>userEventTriggered</code>来处理该 <code>IdleStateEvent</code>事件。</p>
<p>当启动客户端和服务端之后，控制台打印心跳</p>
<p>上面我们只讨论了客户端发送心跳消息给服务端，那么服务端还需要发心跳消息给客户端吗？</p>
<p>一般情况是，对于长连接而言，一种方案是两边都发送心跳消息，另一种是服务端作为被动接收一方，如果一段时间内服务端没有收到心跳包那么就直接断开连接。</p>
<p>我们这里采用第二种方案，只需要客户端发送心跳消息，然后服务端被动接收，然后设置一段时间，在这段时间内如果服务端没有收到任何消息，那么就主动断开连接，这也就是后面要说的 <strong>空闲检测</strong></p>
<h2 id="Netty-客户端断线重连"><a href="#Netty-客户端断线重连" class="headerlink" title="Netty 客户端断线重连"></a>Netty 客户端断线重连</h2><p>一般有以下两种情况，Netty 客户端需要重连服务端：</p>
<ul>
<li>Netty 客户端启动时，服务端挂掉，连不上服务端</li>
<li>在程序运行过程中，服务端突然挂掉</li>
</ul>
<p>第一种情况实现 <code>ChannelFutureListener</code>用来监测连接是否成功，不成功就进行断连重试机制，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String HOST = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">9999</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SocketChannel socketChannel;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            doConnect(<span class="hljs-keyword">new</span> Bootstrap(), group);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Bootstrap <span class="hljs-title">doConnect</span><span class="hljs-params">(Bootstrap bootstrap, EventLoopGroup group)</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;开始连接Netty服务端&quot;</span>);<br>        <span class="hljs-keyword">if</span> (bootstrap != <span class="hljs-keyword">null</span>) &#123;<br>            bootstrap.group(group).channel(NioSocketChannel.class)<br>                .option(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>).option(ChannelOption.TCP_NODELAY, <span class="hljs-keyword">true</span>)<br>                .handler(<span class="hljs-keyword">new</span> ClientHandlerInitializer(<span class="hljs-keyword">this</span>));<br>            bootstrap.remoteAddress(HOST, PORT);<br><br>            bootstrap.connect().addListener((ChannelFutureListener) future -&gt; &#123;<br>                <span class="hljs-keyword">final</span> EventLoop eventLoop = future.channel().eventLoop();<br>                <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>                    log.info(<span class="hljs-string">&quot;连接Netty服务端成功&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    log.info(<span class="hljs-string">&quot;连接失败，进行5秒重连&quot;</span>);<br>                    future.channel().eventLoop()<br>                        .schedule(() -&gt; doConnect(<span class="hljs-keyword">new</span> Bootstrap(), eventLoop), <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>                &#125;<br>                socketChannel = (SocketChannel) future.channel();<br>            &#125;);<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> bootstrap;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(MessageBase.Message message)</span> </span>&#123;<br>        socketChannel.writeAndFlush(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>ChannelFuture添加一个监听器，如果客户端连接服务端失败，调用 <code>channel().eventLoop().schedule()</code>方法执行重试逻辑。</p>
<p>第二种情况是运行过程中 服务端突然挂掉了，这种情况我们在处理数据读写的Handler中实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeartbeatHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> NettyClient nettyClient;<br>    <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            <span class="hljs-comment">//如果运行过程中服务端挂了,执行重连机制</span><br>            log.info(<span class="hljs-string">&quot;服务断开重连&quot;</span>);<br>            <span class="hljs-keyword">final</span> EventLoop eventLoop = ctx.channel().eventLoop();<br>            nettyClient.doConnect(<span class="hljs-keyword">new</span> Bootstrap(), eventLoop);<br>            <span class="hljs-keyword">super</span>.channelInactive(ctx);<br>        &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们这里直接在实现心跳机制的 Handler中重写<code>channelInactive</code>方法，然后在该方法中执行重试逻辑，这里注入了 <code>NettyClient</code>类，目的是方便调用 <code>NettyClient</code>的<code>start()</code>方法重新连接服务端</p>
<p><code>channelInactive()</code>方法是指如果当前Channel没有连接到远程节点，那么该方法将会被调用。</p>
<h2 id="服务端空闲检测"><a href="#服务端空闲检测" class="headerlink" title="服务端空闲检测"></a>服务端空闲检测</h2><p>空闲检测是什么？实际上空闲检测是每隔一段时间，检测这段时间内是否有数据读写。比如，服务端检测一段时间内，是否收到客户端发送来的数据，如果没有，就及时释放资源，关闭连接。</p>
<p>对于空闲检测，Netty 特地提供了 <strong>IdleStateHandler</strong> 来实现这个功能。下面的代码参考自<a target="_blank" rel="noopener" href="https://juejin.im/book/5b4bc28bf265da0f60130116/section/5b4db16de51d4519601ab69f#heading-2">《Netty 入门与实战：仿写微信 IM 即时通讯系统》</a>中空闲检测部分的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerIdleStateHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IdleStateHandler</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置空闲检测时间为 30s</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> READER_IDLE_TIME = <span class="hljs-number">30</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServerIdleStateHandler</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(READER_IDLE_TIME, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, TimeUnit.SECONDS);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelIdle</span><span class="hljs-params">(ChannelHandlerContext ctx, IdleStateEvent evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        log.info(<span class="hljs-string">&quot;&#123;&#125; 秒内没有读取到数据,关闭连接&quot;</span>, READER_IDLE_TIME);<br>        ctx.channel().close();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Controller方法测试"><a href="#Controller方法测试" class="headerlink" title="Controller方法测试"></a>Controller方法测试</h2><p>因为这是 SpringBoot 整合 Netty 的一个Demo,我们创建一个<code>Controller</code>方法对Netty 服务端与客户端之间的通信进行测试，controller代码如下，非常简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerController</span> </span>&#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/send&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">send</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;C:\\Users\\ahsbt\\Desktop\\20140106170547843.png&quot;</span>);<br><br>        MessageBase.Message message = MessageBase.Message.newBuilder().setCmd(Command.HIGH_PHOTO)<br>            .setMsg(<span class="hljs-string">&quot;hello server&quot;</span>).setRequestId(UUID.randomUUID().toString()).setData(Any.pack(<br>                ResultBase.Result.newBuilder().setShaValue(<span class="hljs-string">&quot;&quot;</span>)<br>                    .setFile(FileTransferUtil.fileToByteString(file)).build())).build();<br>        NettyClient.sendMsg(message);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;send ok&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注入 <code>NettyClient</code>，调用其 <code>sendMsg</code>方法发送消息，结果如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">c<span class="hljs-selector-class">.p</span><span class="hljs-selector-class">.server</span><span class="hljs-selector-class">.server</span><span class="hljs-selector-class">.NettyServerHandler</span>     : 收到客户端的业务消息：requestId: <span class="hljs-string">&quot;aba74c28-1b6e-42b3-9f27-889e7044dcbf&quot;</span><br><span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;hello server&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://juejin.im/book/5b4bc28bf265da0f60130116">Netty 入门与实战：仿写微信 IM 即时通讯系统</a></li>
<li><a target="_blank" rel="noopener" href="https://colobu.com/2015/08/14/netty-tcp-client-with-reconnect-handling/">Netty Client重连实现</a></li>
<li><a target="_blank" rel="noopener" href="https://crossoverjie.top/2018/05/24/netty/Netty(1)TCP-Heartbeat/">Netty(一) SpringBoot 整合长连接心跳机制</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006931568">浅析 Netty 实现心跳机制与断线重连</a></li>
<li><a target="_blank" rel="noopener" href="https://colobu.com/2017/03/16/Protobuf3-language-guide/">[转]Protobuf3 语法指南</a></li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/PaaS/">PaaS</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/docker/">docker</a>
                    
                      <a class="hover-with-bg" href="/tags/nexus/">nexus</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2019/05/22/Nexus%E6%BA%90%E6%9B%BF%E6%8D%A2%E5%8F%8AGitlab%E8%BF%81%E7%A7%BB/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Nexus源替换及Gitlab迁移</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2019/05/21/java/HashMap%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%B9%E9%87%8F%E6%80%BB%E6%98%AF%E4%B8%BA%202%20%E7%9A%84%E6%AC%A1%E5%B9%82/">
                        <span class="hidden-mobile">HashMap：为什么容量总是为 2 的次幂</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
